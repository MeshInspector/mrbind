#include "data_to_macros.h"

#include "common/meta.h"
#include "common/string_escape.h"

#include <unordered_set>
#include <utility>

namespace mrbind
{
    void ParsedFileToMacros(const ParsedFile &file, std::ofstream &out)
    {
        out <<
            "// Automatically generated by mrbind, do not edit.\n";

        if (file.num_fragments > 1)
            out << "// Segment " << file.fragment_index << "/" << file.num_fragments << '\n';

        out <<
            "\n"
            "#ifdef MRBIND_HEADER\n"
            "#include MRBIND_HEADER\n"
            "#endif // MRBIND_HEADER\n"
            "\n"
            "#ifndef MB_CHECK_FRAGMENT\n"
            "#if !defined(MB_NUM_FRAGMENTS) || MB_NUM_FRAGMENTS <= 1\n"
            "#define MB_CHECK_FRAGMENT(x) 1\n"
            "#else\n"
            "#define MB_CHECK_FRAGMENT(x) (x % MB_NUM_FRAGMENTS == MB_FRAGMENT)\n"
            "#endif\n"
            "#endif\n"
            "#ifndef MB_CHECK_FRAGMENT_TYPES\n"
            "#define MB_CHECK_FRAGMENT_TYPES(x) MB_CHECK_FRAGMENT(x)\n"
            "#endif\n"
            "\n"
            "#if MB_INCLUDE_ORIGINAL_HEADER\n"
            "#include " << EscapeQuoteString(file.original_file) << "\n"
            "#if MB_INCLUDE_ORIGINAL_HEADER >= 2 // Headers from the corresponding implementation file.\n"
            << file.impl_file_preprocessor_directives <<
            "#endif\n"
            "#undef MB_INCLUDE_ORIGINAL_HEADER\n"
            "#endif\n"
            "\n";

        #if 0 // Currently we don't need the baked typenames for anything.
        { // Bake the type names.
            bool first = true;

            std::unordered_set<std::string> visited_types;

            auto bake = [&](std::string_view name)
            {
                auto bake_low = [&](std::string_view name)
                {
                    if (visited_types.insert(std::string(name)).second)
                    {
                        if (first)
                        {
                            first = false;
                            out <<
                                "#ifdef MB_WANT_BAKED_TYPE_NAMES\n"
                                "#undef MB_WANT_BAKED_TYPE_NAMES\n"
                                "namespace MRBind {template <typename> struct BakedTypeName {};}\n";
                        }

                        out << "template <> struct MRBind::BakedTypeName<" << name << "> {static constexpr const char *value = " << EscapeQuoteString(name) << ";};\n";
                    }
                };

                bake_low(name);

                // Bake different variants:
                // We don't strictly need it at this point (I think?), but just in case.

                // The order matters, but we only really care about adding the ref-unqualified type, and ptr-cv-ref-unqualified one.

                // Referenced type:
                if (name.ends_with('&'))
                {
                    name = name.substr(0, name.find_last_not_of("& ") + 1);
                    bake_low(name);
                }

                // Pointed type.
                if (name.ends_with('*'))
                {
                    name = name.substr(0, name.find_last_not_of("* ") + 1);
                    bake_low(name);
                }

                // Const-unqualified type.
                if (name.starts_with("const "))
                {
                    name = name.substr(6);
                    bake_low(name);
                }
            };

            auto lambda = [&](auto &lambda, const Entity &e) -> void
            {
                std::visit(Overload{
                    [&](const EnumEntity &e)
                    {
                        bake(e.full_type);
                    },
                    [&](const FuncEntity &e)
                    {
                        bake(e.return_type.canonical);
                        for (const FuncParam &param : e.params)
                            bake(param.type.canonical);
                    },
                    [&](const ClassEntity &e)
                    {
                        bake(e.full_type);

                        for (const ClassMemberVariant &memvar : e.members)
                        {
                            std::visit(Overload{
                                [&](const ClassField &f)
                                {
                                    bake(f.type.canonical);
                                },
                                [&](const ClassMethod &m)
                                {
                                    bake(m.return_type.canonical);
                                    for (const FuncParam &param : m.params)
                                        bake(param.type.canonical);
                                },
                                [&](const ClassCtor &c)
                                {
                                    for (const FuncParam &param : c.params)
                                        bake(param.type.canonical);
                                },
                                [&](const ClassConvOp &o)
                                {
                                    bake(o.return_type.canonical);
                                },
                            }, memvar);
                        }

                        for (const ClassBase &base : e.bases)
                            bake(base.type.canonical);

                        for (const auto &elem : e.nested)
                            lambda(lambda, elem);
                    },
                    [&](const TypedefEntity &t)
                    {
                        bake(t.type.canonical);
                    },
                    [&](const NamespaceEntity &e)
                    {
                        for (const auto &elem : e.nested)
                            lambda(lambda, elem);
                    },
                }, *e.variant);
            };
            for (const Entity &e : file.entities.nested)
                lambda(lambda, e);

            if (!first)
                out << "#endif // MB_WANT_BAKED_TYPE_NAMES\n\n";
        }
        #endif

        out << "MB_FILE\n\n";

        { // Dump file contents.
            auto dump_params = [&](const std::vector<FuncParam> &params, bool indent_twice = true)
            {
                if (params.empty())
                {
                    out << "/*no params*/";
                    return;
                }

                out << "/*params:*/\n";
                for (const FuncParam &param : params)
                {
                    if (indent_twice)
                        out << "    ";
                    out << "    ("
                        << "(" << param.type.pretty << "), "
                        << (param.name ? *param.name : "/*unnamed*/") << ", "
                        << (param.default_argument ? "(" + param.default_argument->original_spelling + ")" : "/*no default argument*/") << ", "
                        << (param.default_argument ? "(" + param.default_argument->as_cpp_expression + ")" : "/*no default argument*/")
                        << ")\n";
                }

                if (indent_twice && !params.empty())
                    out << "    ";
            };

            std::vector<std::string> namespace_stack;

            auto NsStackToString = [&]
            {
                std::string ret;
                if (namespace_stack.empty())
                {
                    ret = "/*::*/";
                }
                else
                {
                    for (const auto &fragment : namespace_stack)
                        ret += fragment;
                }
                return ret;
            };

            // Those controls the placement of multiplexing `#if`s around the entities.

            int multiplex_depth = 0;
            int multiplex_counter = 0;
            auto BeginMultiplexBlock = [&](bool is_type_registration = false)
            {
                if (multiplex_depth++ == 0)
                    out << "#if " << (is_type_registration ? "MB_CHECK_FRAGMENT_TYPES" : "MB_CHECK_FRAGMENT") << "(" << multiplex_counter++ << ")\n";
            };
            auto EndMultiplexBlock = [&]
            {
                if (--multiplex_depth == 0)
                    out << "#endif\n";
            };


            auto lambda = [&](auto &lambda, const Entity &e) -> void
            {
                std::visit(Overload{
                    [&](const EnumEntity &e)
                    {
                        BeginMultiplexBlock();
                        out << "MB_ENUM("
                            // Is enum class?
                            << (e.is_scoped ? "class" : "/*not enum-class*/") << ", "
                            // Name.
                            << e.name << ", "
                            // Qualified name.
                            << "(" << e.full_type << "), "
                            // Namespace stack.
                            << NsStackToString() << ", "
                            // Underlying type.
                            << e.canonical_underlying_type << ", "
                            // Comment.
                            << (e.comment ? EscapeQuoteString(e.comment->text) : "/*no comment*/") << ", ";

                        if (e.elems.empty())
                        {
                            out << "/*no elements*/);\n";
                        }
                        else
                        {
                            out << "\n";
                            for (const EnumElem &elem : e.elems)
                            {
                                out << "    (" << elem.name << ", ";
                                if (e.is_signed)
                                    out << std::int64_t(elem.unsigned_value);
                                else
                                    out << std::uint64_t(elem.unsigned_value);
                                out << ", " << (elem.comment ? EscapeQuoteString(elem.comment->text) : "/*no comment*/") << ")\n";
                            }
                            out << ")\n";
                        }
                        EndMultiplexBlock();
                    },
                    [&](const FuncEntity &e)
                    {
                        BeginMultiplexBlock();
                        out << "MB_FUNC("
                            << "/*returns*/(" << e.return_type.pretty << "), "
                            << e.name << ", "
                            << e.simple_name << ", "
                            << "(" << e.qual_name << "), "
                            << "(" << e.full_qual_name << "), "
                            << NsStackToString() << ", "
                            << (e.deprecation_message ? "/*deprecated:*/" + EscapeQuoteString(*e.deprecation_message) : "/*not deprecated*/") + ", "
                            << (e.comment ? EscapeQuoteString(e.comment->text) : "/*no comment*/")
                            << ", ";
                        dump_params(e.params, false);
                        out << ")\n";
                        EndMultiplexBlock();
                    },
                    [&](const ClassEntity &e)
                    {
                        BeginMultiplexBlock();
                        out << "MB_CLASS(";
                        switch (e.kind)
                        {
                            case ClassKind::class_: out << "class"; break;
                            case ClassKind::struct_: out << "struct"; break;
                            case ClassKind::union_: out << "union"; break;
                        };
                        out
                            << ", "
                            << e.name << ", "
                            << "(" << e.full_type << "), "
                            << NsStackToString() << ", "
                            << "/*is aggregate:*/" << int(e.is_aggregate) << ", "
                            << (e.comment ? EscapeQuoteString(e.comment->text) : "/*no comment*/") << ",";

                        // Bases.
                        if (e.bases.empty())
                        {
                            out << " /*no bases*/,";
                        }
                        else
                        {
                            out << "\n    /*bases:*/\n";
                            for (const ClassBase &base : e.bases)
                                out << "    ((" << base.type.pretty << "), " << (base.is_virtual ? "virtual" : "/*not virtual*/") << ")\n";
                            out << "    ,";
                        }

                        // Members.
                        if (e.members.empty())
                        {
                            out << " /*no members*/)\n";
                        }
                        else
                        {
                            if (e.bases.empty())
                                out << "\n    ";
                            out << "/*members:*/\n";
                            for (const ClassMemberVariant &member : e.members)
                            {
                                std::visit(Overload{
                                    [&](const ClassField &field)
                                    {
                                        out
                                            << "    (field, "
                                            << (field.is_static ? "static" : "/*non-static*/") << ", "
                                            << "(" << field.type.canonical << "), " // Pretty types can lack some qualifiers here.
                                            << field.name << ", "
                                            << "(" << field.full_name << "), "
                                            << (field.comment ? EscapeQuoteString(field.comment->text) : "/*no comment*/")
                                            << ")\n";
                                    },
                                    [&](const ClassCtor &ctor)
                                    {
                                        out
                                            << "    (ctor, "
                                            << (ctor.is_explicit ? "explicit" : "/*not explicit*/") << ", ";
                                        switch (ctor.kind)
                                        {
                                            case CopyMoveKind::none: out << "none"; break;
                                            case CopyMoveKind::copy: out << "copy"; break;
                                            case CopyMoveKind::move: out << "move"; break;
                                            case CopyMoveKind::by_value_assignment: throw std::logic_error("Internal error: `CopyMoveKind::by_value_assignment` on a constructor");
                                        }
                                        out << ", "
                                            << (ctor.deprecation_message ? "/*deprecated:*/" + EscapeQuoteString(*ctor.deprecation_message) : "/*not deprecated*/") + ", "
                                            << (ctor.comment ? EscapeQuoteString(ctor.comment->text) : "/*no comment*/") << ", ";
                                        dump_params(ctor.params);
                                        out << ")\n";
                                    },
                                    [&](const ClassMethod &method)
                                    {
                                        out
                                            << "    (method, "
                                            << (method.is_static ? "static" : "/*non-static*/") << ", ";
                                        switch (method.assignment_kind)
                                        {
                                            case CopyMoveKind::none: out << "none"; break;
                                            case CopyMoveKind::copy: out << "copy"; break;
                                            case CopyMoveKind::move: out << "move"; break;
                                            case CopyMoveKind::by_value_assignment: out << "by_value_assignment"; break;
                                        }
                                        out
                                            << ", "
                                            << "(" << method.return_type.pretty << "), "
                                            << method.name << ", "
                                            << method.simple_name << ", "
                                            << "(" << method.full_name << "), "
                                            << (method.is_const ? "const" : "/*not const*/") << ", "
                                            << (method.deprecation_message ? "/*deprecated:*/" + EscapeQuoteString(*method.deprecation_message) : "/*not deprecated*/") + ", "
                                            << (method.comment ? EscapeQuoteString(method.comment->text) : "/*no comment*/") << ", ";
                                        dump_params(method.params);
                                        out << ")\n";
                                    },
                                    [&](const ClassConvOp &conv_op)
                                    {
                                        out
                                            << "    (conv_op, "
                                            << (conv_op.is_explicit ? "explicit" : "/*not explicit*/") << ", "
                                            << "(" << conv_op.return_type.pretty << "), "
                                            << (conv_op.is_const ? "const" : "/*not const*/") << ", "
                                            << (conv_op.deprecation_message ? "/*deprecated:*/" + EscapeQuoteString(*conv_op.deprecation_message) : "/*not deprecated*/") + ", "
                                            << (conv_op.comment ? EscapeQuoteString(conv_op.comment->text) : "/*no comment*/")
                                            << ")\n";
                                    },
                                    [&](const ClassDtor &conv_op)
                                    {
                                        // Don't write those to the macros?
                                        // Because the macro users can check `std::is_destructible_v` directly.
                                        (void)conv_op;
                                    },
                                }, member);
                            }
                            out << ")\n";
                        }

                        // Push to the namespace stack.
                        namespace_stack.push_back("(" + e.name + ",cl)");

                        for (const auto &elem : e.nested)
                            lambda(lambda, elem);

                        // Push the namespace stack.
                        namespace_stack.pop_back();

                        out << "MB_END_CLASS(" << e.name << ")\n";
                        EndMultiplexBlock();
                    },
                    [&](const TypedefEntity &t)
                    {
                        BeginMultiplexBlock();
                        out << "MB_TYPEDEF("
                            << t.name << ", "
                            << "(" << t.full_name << "), "
                            << NsStackToString() << ", "
                            << "(" << t.type.pretty << "), "
                            << (t.comment ? EscapeQuoteString(t.comment->text) : "/*no comment*/")
                            << ")\n";
                        EndMultiplexBlock();
                    },
                    [&](const NamespaceEntity &ns)
                    {
                        out << "MB_NAMESPACE("
                            << (ns.name ? *ns.name : "/*anonymous*/") << ", "
                            << (ns.is_inline ? "inline" : "/*not inline*/") << ", "
                            << NsStackToString() << ", "
                            << (ns.comment ? EscapeQuoteString(ns.comment->text) : "/*no comment*/") << ")\n";

                        namespace_stack.push_back("(" + ns.name.value_or("") + ",ns)");

                        for (const auto &elem : ns.nested)
                            lambda(lambda, elem);

                        namespace_stack.pop_back();

                        out << "MB_END_NAMESPACE("
                            << (ns.name ? *ns.name : "/*anonymous*/") << ", "
                            << (ns.is_inline ? "inline" : "/*not inline*/") << ", "
                            << NsStackToString() << ")\n";
                    },
                }, *e.variant);
            };
            for (const Entity &e : file.entities.nested)
                lambda(lambda, e);

            // Dump type spellings.
            if (!file.type_info.empty())
            {
                // Calls `func` for every set bit in `uses`. `func` is `(TypeUses bit, const char *name) -> void`.
                auto UsesBitsToStrings = [](TypeUses uses, auto &&func)
                {
                    for (TypeUses bit = TypeUses(1); bool(bit & TypeUses::_valid_bits_spelling); bit <<= 1)
                    {
                        if (bool(bit & uses))
                        {
                            switch (bit)
                            {
                                case TypeUses::returned:              func(std::as_const(bit), "RETURNED"); break;
                                case TypeUses::parameter:             func(std::as_const(bit), "PARAM"); break;
                                case TypeUses::parsed:                func(std::as_const(bit), "PARSED"); break;
                                case TypeUses::base:                  func(std::as_const(bit), "BASE"); break;
                                case TypeUses::nonstatic_data_member: func(std::as_const(bit), "NONSTATIC_DATA_MEMBER"); break;
                                case TypeUses::static_data_member:    func(std::as_const(bit), "STATIC_DATA_MEMBER"); break;
                                case TypeUses::typedef_target:        func(std::as_const(bit), "TYPEDEF_TARGET"); break;
                                case TypeUses::typedef_name:          func(std::as_const(bit), "TYPEDEF_NAME"); break;
                                case TypeUses::_poisoned:             break; // Should be unreachable.
                            }
                        }
                    }
                };

                out << "\n";
                for (const auto &outer_type : file.type_info)
                {
                    BeginMultiplexBlock(true);

                    // This is supposed to be the same across the entire submap.
                    bool has_custom_name = outer_type.second.begin()->second.has_custom_canonical_name;
                    std::string custom_name_desc;
                    if (has_custom_name)
                        custom_name_desc = "/*name source:*/custom";
                    else
                        custom_name_desc = "/*name source: auto*/";

                    out << "MB_REGISTER_TYPE(" << (multiplex_counter - 1) << ", " << custom_name_desc << ", " << outer_type.first << ")\n";

                    for (const auto &type : outer_type.second)
                    {
                        if (type.second.has_custom_canonical_name != has_custom_name)
                            throw std::logic_error("Internal error: inconsistent `has_custom_canonical_name` across the different variations of the same type.");

                        UsesBitsToStrings(type.second.uses, [&](TypeUses bit, const char *name)
                        {
                            (void)bit;
                            out << "MB_REGISTER_TYPE_" << name << "(" << (multiplex_counter - 1) << ", " << custom_name_desc << ", " << type.first << ")\n";
                        });

                        for (const auto &spelling : type.second.alt_spellings)
                        {
                            if (spelling.second.poisoned)
                                continue; // Ignore the poisoned spelling.

                            out << "MB_ALT_TYPE_SPELLING("
                                << (multiplex_counter - 1) << ", "
                                << custom_name_desc << ", "
                                << "(" << type.first << "), "
                                << "(" << spelling.first << ")"
                                << ")\n";

                            UsesBitsToStrings(spelling.second.uses, [&](TypeUses bit, const char *name)
                            {
                                (void)bit;
                                out << "MB_ALT_TYPE_SPELLING_" << name << "("
                                    << (multiplex_counter - 1) << ", "
                                    << custom_name_desc << ", "
                                    << "(" << type.first << "), "
                                    << "(" << spelling.first << ")"
                                    << ")\n";
                            });
                        }
                    }

                    EndMultiplexBlock();
                }
            }
        }

        out << "\nMB_END_FILE\n\n";

        out <<
            "#ifdef MB_AGAIN\n"
            "#undef MB_AGAIN\n"
            "#include __FILE__\n"
            "#endif // MB_AGAIN\n";
    }
}

public static partial class MR
{
    public static partial class CS
    {
        public static partial class CSharp
        {
            /// Enum comment.
            public enum E1 : int
            {
                // A
                A = 10,
                // B
                B = 20,
                // C
                C = 30,
            }

            /// This enum is intended to be boolean.
            public enum E2 : byte
            {
                A = 0,
                B = 1,
            }

            /// Generated from class `MR::CSharp::A`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::C`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::B`
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the const half of the class.
            public class Const_A : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_Destroy(_Underlying *_this);
                    __MR_CSharp_A_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_A() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_A() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_A_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::A::A`.
                public unsafe Const_A(MR.CS.CSharp._ByValue_A _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_A_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::A::bar`.
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_A_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::A::static_foo`.
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_static_foo();
                    __MR_CSharp_A_static_foo();
                }

                /// Generated from method `MR::CSharp::A::static_bar`.
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_static_bar(int _1, int _2);
                    __MR_CSharp_A_static_bar(_1, _2);
                }

                /// Generated from method `MR::CSharp::A::virtual_bar`.
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_A_virtual_bar(_UnderlyingPtr, _1, _2);
                }
            }

            /// Generated from class `MR::CSharp::A`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::C`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::B`
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the non-const half of the class.
            public class A : Const_A
            {
                internal unsafe A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe A() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_A_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::A::A`.
                public unsafe A(MR.CS.CSharp._ByValue_A _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_A_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::A::operator=`.
                public unsafe MR.CS.CSharp.A assign(MR.CS.CSharp._ByValue_A _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    return new(__MR_CSharp_A_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::A::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_foo(_Underlying *_this);
                    __MR_CSharp_A_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::A::virtual_foo`.
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_virtual_foo(_Underlying *_this);
                    __MR_CSharp_A_virtual_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::A::refs`.
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_A_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_A_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }
            }

            /// This is used as a function parameter when the underlying function receives `A` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `A`/`Const_A` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_A
            {
                internal readonly Const_A? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_A() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_A(Const_A new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_A(Const_A arg) {return new(arg);}
                public _ByValue_A(MR.CS.Misc._Moved<A> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_A(MR.CS.Misc._Moved<A> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `A` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `A`/`Const_A` directly.
            public class _InOptMut_A
            {
                public A? Opt;

                public _InOptMut_A() {}
                public _InOptMut_A(A value) {Opt = value;}
                public static implicit operator _InOptMut_A(A value) {return new(value);}
            }

            /// This is used for optional parameters of class `A` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `A`/`Const_A` to pass it to the function.
            public class _InOptConst_A
            {
                public Const_A? Opt;

                public _InOptConst_A() {}
                public _InOptConst_A(Const_A value) {Opt = value;}
                public static implicit operator _InOptConst_A(Const_A value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::B`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            /// This is the const half of the class.
            public class Const_B : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_B(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_Destroy(_Underlying *_this);
                    __MR_CSharp_B_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_B() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_B self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_B_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_B_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_B?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_B ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_B() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_B_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::B::B`.
                public unsafe Const_B(MR.CS.CSharp._ByValue_B _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_B_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::B::B`.
                public unsafe Const_B(int a, int b) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_Construct(int a, int b);
                    _UnderlyingPtr = __MR_CSharp_B_Construct(a, b);
                }

                /// Generated from method `MR::CSharp::B::bar`.
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_B_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::B::static_foo`.
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_static_foo();
                    __MR_CSharp_B_static_foo();
                }

                /// Generated from method `MR::CSharp::B::static_bar`.
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_static_bar(int _1, int _2);
                    __MR_CSharp_B_static_bar(_1, _2);
                }

                /// Generated from method `MR::CSharp::B::virtual_bar`.
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_B_virtual_bar(_UnderlyingPtr, _1, _2);
                }
            }

            /// Generated from class `MR::CSharp::B`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            /// This is the non-const half of the class.
            public class B : Const_B
            {
                internal unsafe B(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(B self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_B_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_B_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator B?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    B ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe B() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_B_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::B::B`.
                public unsafe B(MR.CS.CSharp._ByValue_B _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_B_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::B::B`.
                public unsafe B(int a, int b) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_Construct(int a, int b);
                    _UnderlyingPtr = __MR_CSharp_B_Construct(a, b);
                }

                /// Generated from method `MR::CSharp::B::operator=`.
                public unsafe MR.CS.CSharp.B assign(MR.CS.CSharp._ByValue_B _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    return new(__MR_CSharp_B_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::B::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_foo(_Underlying *_this);
                    __MR_CSharp_B_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::B::virtual_foo`.
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_virtual_foo(_Underlying *_this);
                    __MR_CSharp_B_virtual_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::B::refs`.
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_B_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_B_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }
            }

            /// This is used as a function parameter when the underlying function receives `B` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `B`/`Const_B` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_B
            {
                internal readonly Const_B? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_B() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_B(Const_B new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_B(Const_B arg) {return new(arg);}
                public _ByValue_B(MR.CS.Misc._Moved<B> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_B(MR.CS.Misc._Moved<B> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `B` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_B`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `B`/`Const_B` directly.
            public class _InOptMut_B
            {
                public B? Opt;

                public _InOptMut_B() {}
                public _InOptMut_B(B value) {Opt = value;}
                public static implicit operator _InOptMut_B(B value) {return new(value);}
            }

            /// This is used for optional parameters of class `B` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_B`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `B`/`Const_B` to pass it to the function.
            public class _InOptConst_B
            {
                public Const_B? Opt;

                public _InOptConst_B() {}
                public _InOptConst_B(Const_B value) {Opt = value;}
                public static implicit operator _InOptConst_B(Const_B value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::C`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::A`
            /// This is the const half of the class.
            public class Const_C : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_C(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_Destroy(_Underlying *_this);
                    __MR_CSharp_C_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_C() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_C self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_C_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_C_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_C?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_C ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_C() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_C_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::C::C`.
                public unsafe Const_C(MR.CS.CSharp._ByValue_C _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_C_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::C::bar`.
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_C_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::C::static_foo`.
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_static_foo();
                    __MR_CSharp_C_static_foo();
                }

                /// Generated from method `MR::CSharp::C::static_bar`.
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_static_bar(int _1, int _2);
                    __MR_CSharp_C_static_bar(_1, _2);
                }

                /// Generated from method `MR::CSharp::C::virtual_bar`.
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_C_virtual_bar(_UnderlyingPtr, _1, _2);
                }
            }

            /// Generated from class `MR::CSharp::C`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::A`
            /// This is the non-const half of the class.
            public class C : Const_C
            {
                internal unsafe C(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(C self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_C_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_C_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator C?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    C ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe C() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_C_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::C::C`.
                public unsafe C(MR.CS.CSharp._ByValue_C _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_C_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::C::operator=`.
                public unsafe MR.CS.CSharp.C assign(MR.CS.CSharp._ByValue_C _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    return new(__MR_CSharp_C_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::C::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_foo(_Underlying *_this);
                    __MR_CSharp_C_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::C::virtual_foo`.
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_virtual_foo(_Underlying *_this);
                    __MR_CSharp_C_virtual_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::C::refs`.
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_C_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_C_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }
            }

            /// This is used as a function parameter when the underlying function receives `C` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `C`/`Const_C` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_C
            {
                internal readonly Const_C? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_C() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_C(Const_C new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_C(Const_C arg) {return new(arg);}
                public _ByValue_C(MR.CS.Misc._Moved<C> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_C(MR.CS.Misc._Moved<C> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `C` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_C`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `C`/`Const_C` directly.
            public class _InOptMut_C
            {
                public C? Opt;

                public _InOptMut_C() {}
                public _InOptMut_C(C value) {Opt = value;}
                public static implicit operator _InOptMut_C(C value) {return new(value);}
            }

            /// This is used for optional parameters of class `C` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_C`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `C`/`Const_C` to pass it to the function.
            public class _InOptConst_C
            {
                public Const_C? Opt;

                public _InOptConst_C() {}
                public _InOptConst_C(Const_C value) {Opt = value;}
                public static implicit operator _InOptConst_C(Const_C value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::D`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the const half of the class.
            public class Const_D : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_D(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_Destroy(_Underlying *_this);
                    __MR_CSharp_D_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_D() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_D() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_D_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::D::D`.
                public unsafe Const_D(MR.CS.CSharp.Const_D _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_ConstructFromAnother(MR.CS.CSharp.D._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_D_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::D::d1`.
                public unsafe void d1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_d1", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_d1(_Underlying *_this);
                    __MR_CSharp_D_d1(_UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::D`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the non-const half of the class.
            public class D : Const_D
            {
                internal unsafe D(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe D() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_D_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::D::D`.
                public unsafe D(MR.CS.CSharp.Const_D _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_ConstructFromAnother(MR.CS.CSharp.D._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_D_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::D::operator=`.
                public unsafe MR.CS.CSharp.D assign(MR.CS.CSharp.Const_D _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.D._Underlying *_other);
                    return new(__MR_CSharp_D_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::D::d2`.
                public unsafe void d2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_d2", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_d2(_Underlying *_this);
                    __MR_CSharp_D_d2(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `D` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_D`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `D`/`Const_D` directly.
            public class _InOptMut_D
            {
                public D? Opt;

                public _InOptMut_D() {}
                public _InOptMut_D(D value) {Opt = value;}
                public static implicit operator _InOptMut_D(D value) {return new(value);}
            }

            /// This is used for optional parameters of class `D` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_D`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `D`/`Const_D` to pass it to the function.
            public class _InOptConst_D
            {
                public Const_D? Opt;

                public _InOptConst_D() {}
                public _InOptConst_D(Const_D value) {Opt = value;}
                public static implicit operator _InOptConst_D(Const_D value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::E`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::G`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            /// This is the const half of the class.
            public class Const_E : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_E(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_Destroy(_Underlying *_this);
                    __MR_CSharp_E_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_E() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_E() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_E_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::E::E`.
                public unsafe Const_E(MR.CS.CSharp.Const_E _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_ConstructFromAnother(MR.CS.CSharp.E._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_E_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::E::e1`.
                public unsafe void e1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_e1", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_e1(_Underlying *_this);
                    __MR_CSharp_E_e1(_UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::E`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::G`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            /// This is the non-const half of the class.
            public class E : Const_E
            {
                internal unsafe E(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe E() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_E_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::E::E`.
                public unsafe E(MR.CS.CSharp.Const_E _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_ConstructFromAnother(MR.CS.CSharp.E._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_E_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::E::operator=`.
                public unsafe MR.CS.CSharp.E assign(MR.CS.CSharp.Const_E _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.E._Underlying *_other);
                    return new(__MR_CSharp_E_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::E::e2`.
                public unsafe void e2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_e2", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_e2(_Underlying *_this);
                    __MR_CSharp_E_e2(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `E` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_E`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `E`/`Const_E` directly.
            public class _InOptMut_E
            {
                public E? Opt;

                public _InOptMut_E() {}
                public _InOptMut_E(E value) {Opt = value;}
                public static implicit operator _InOptMut_E(E value) {return new(value);}
            }

            /// This is used for optional parameters of class `E` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_E`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `E`/`Const_E` to pass it to the function.
            public class _InOptConst_E
            {
                public Const_E? Opt;

                public _InOptConst_E() {}
                public _InOptConst_E(Const_E value) {Opt = value;}
                public static implicit operator _InOptConst_E(Const_E value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::F`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            ///     `MR::CSharp::E`
            /// This is the const half of the class.
            public class Const_F : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_F(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_Destroy(_Underlying *_this);
                    __MR_CSharp_F_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_F() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_D(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_D._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.Const_D ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_E(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_E._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.Const_E ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_F?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_F ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_F() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_F_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::F::F`.
                public unsafe Const_F(MR.CS.CSharp._ByValue_F _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_F_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::F::bar`.
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_F_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::F::static_foo`.
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_static_foo();
                    __MR_CSharp_F_static_foo();
                }

                /// Generated from method `MR::CSharp::F::static_bar`.
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_static_bar(int _1, int _2);
                    __MR_CSharp_F_static_bar(_1, _2);
                }

                /// Generated from method `MR::CSharp::F::virtual_bar`.
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_F_virtual_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::F::d1`.
                public unsafe void d1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_d1", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_d1(_Underlying *_this);
                    __MR_CSharp_F_d1(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::F::e1`.
                public unsafe void e1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_e1", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_e1(_Underlying *_this);
                    __MR_CSharp_F_e1(_UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::F`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            ///     `MR::CSharp::E`
            /// This is the non-const half of the class.
            public class F : Const_F
            {
                internal unsafe F(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.D(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.D ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.E(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.E ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator F?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    F ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe F() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_F_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::F::F`.
                public unsafe F(MR.CS.CSharp._ByValue_F _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_F_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::F::operator=`.
                public unsafe MR.CS.CSharp.F assign(MR.CS.CSharp._ByValue_F _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    return new(__MR_CSharp_F_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::F::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_foo(_Underlying *_this);
                    __MR_CSharp_F_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::F::virtual_foo`.
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_virtual_foo(_Underlying *_this);
                    __MR_CSharp_F_virtual_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::F::refs`.
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_F_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_F_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }

                /// Generated from method `MR::CSharp::F::d2`.
                public unsafe void d2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_d2", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_d2(_Underlying *_this);
                    __MR_CSharp_F_d2(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::F::e2`.
                public unsafe void e2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_e2", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_e2(_Underlying *_this);
                    __MR_CSharp_F_e2(_UnderlyingPtr);
                }
            }

            /// This is used as a function parameter when the underlying function receives `F` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `F`/`Const_F` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_F
            {
                internal readonly Const_F? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_F() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_F(Const_F new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_F(Const_F arg) {return new(arg);}
                public _ByValue_F(MR.CS.Misc._Moved<F> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_F(MR.CS.Misc._Moved<F> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `F` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_F`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `F`/`Const_F` directly.
            public class _InOptMut_F
            {
                public F? Opt;

                public _InOptMut_F() {}
                public _InOptMut_F(F value) {Opt = value;}
                public static implicit operator _InOptMut_F(F value) {return new(value);}
            }

            /// This is used for optional parameters of class `F` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_F`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `F`/`Const_F` to pass it to the function.
            public class _InOptConst_F
            {
                public Const_F? Opt;

                public _InOptConst_F() {}
                public _InOptConst_F(Const_F value) {Opt = value;}
                public static implicit operator _InOptConst_F(Const_F value) {return new(value);}
            }

            // Even if the secondary bases are virtual, this doesn't affect anything.
            /// Generated from class `MR::CSharp::G`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::E`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            /// This is the const half of the class.
            public class Const_G : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_G(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_Destroy(_Underlying *_this);
                    __MR_CSharp_G_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_G() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_D(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_D._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.Const_D ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_E(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_E._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.Const_E ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_G?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_G ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_G() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_G_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::G::G`.
                public unsafe Const_G(MR.CS.CSharp._ByValue_G _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_G_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::G::bar`.
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_G_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::G::static_foo`.
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_static_foo();
                    __MR_CSharp_G_static_foo();
                }

                /// Generated from method `MR::CSharp::G::static_bar`.
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_static_bar(int _1, int _2);
                    __MR_CSharp_G_static_bar(_1, _2);
                }

                /// Generated from method `MR::CSharp::G::virtual_bar`.
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_G_virtual_bar(_UnderlyingPtr, _1, _2);
                }

                /// Generated from method `MR::CSharp::G::d1`.
                public unsafe void d1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_d1", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_d1(_Underlying *_this);
                    __MR_CSharp_G_d1(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::G::e1`.
                public unsafe void e1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_e1", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_e1(_Underlying *_this);
                    __MR_CSharp_G_e1(_UnderlyingPtr);
                }
            }

            // Even if the secondary bases are virtual, this doesn't affect anything.
            /// Generated from class `MR::CSharp::G`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::E`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            /// This is the non-const half of the class.
            public class G : Const_G
            {
                internal unsafe G(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.D(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.D ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.E(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.E ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAlive(self);
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator G?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    G ret = new(ptr, is_owning: false);
                    ret._KeepAlive(parent);
                    return ret;
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe G() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_G_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::G::G`.
                public unsafe G(MR.CS.CSharp._ByValue_G _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_G_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::G::operator=`.
                public unsafe MR.CS.CSharp.G assign(MR.CS.CSharp._ByValue_G _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    return new(__MR_CSharp_G_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::G::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_foo(_Underlying *_this);
                    __MR_CSharp_G_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::G::virtual_foo`.
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_virtual_foo(_Underlying *_this);
                    __MR_CSharp_G_virtual_foo(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::G::refs`.
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_G_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_G_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }

                /// Generated from method `MR::CSharp::G::d2`.
                public unsafe void d2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_d2", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_d2(_Underlying *_this);
                    __MR_CSharp_G_d2(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::G::e2`.
                public unsafe void e2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_e2", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_e2(_Underlying *_this);
                    __MR_CSharp_G_e2(_UnderlyingPtr);
                }
            }

            /// This is used as a function parameter when the underlying function receives `G` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `G`/`Const_G` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_G
            {
                internal readonly Const_G? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_G() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_G(Const_G new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_G(Const_G arg) {return new(arg);}
                public _ByValue_G(MR.CS.Misc._Moved<G> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_G(MR.CS.Misc._Moved<G> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `G` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_G`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `G`/`Const_G` directly.
            public class _InOptMut_G
            {
                public G? Opt;

                public _InOptMut_G() {}
                public _InOptMut_G(G value) {Opt = value;}
                public static implicit operator _InOptMut_G(G value) {return new(value);}
            }

            /// This is used for optional parameters of class `G` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_G`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `G`/`Const_G` to pass it to the function.
            public class _InOptConst_G
            {
                public Const_G? Opt;

                public _InOptConst_G() {}
                public _InOptConst_G(Const_G value) {Opt = value;}
                public static implicit operator _InOptConst_G(Const_G value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::Trivial`.
            /// This is the const half of the class.
            public class Const_Trivial : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_Trivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_Trivial_Destroy(_Underlying *_this);
                    __MR_CSharp_Trivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_Trivial() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_Trivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Trivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                public unsafe Const_Trivial(MR.CS.CSharp.Const_Trivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_ConstructFromAnother(MR.CS.CSharp.Trivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Trivial_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::Trivial`.
            /// This is the non-const half of the class.
            public class Trivial : Const_Trivial
            {
                internal unsafe Trivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Trivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Trivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                public unsafe Trivial(MR.CS.CSharp.Const_Trivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_ConstructFromAnother(MR.CS.CSharp.Trivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Trivial_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::Trivial::operator=`.
                public unsafe MR.CS.CSharp.Trivial assign(MR.CS.CSharp.Const_Trivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Trivial._Underlying *_other);
                    return new(__MR_CSharp_Trivial_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `Trivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_Trivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Trivial`/`Const_Trivial` directly.
            public class _InOptMut_Trivial
            {
                public Trivial? Opt;

                public _InOptMut_Trivial() {}
                public _InOptMut_Trivial(Trivial value) {Opt = value;}
                public static implicit operator _InOptMut_Trivial(Trivial value) {return new(value);}
            }

            /// This is used for optional parameters of class `Trivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_Trivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Trivial`/`Const_Trivial` to pass it to the function.
            public class _InOptConst_Trivial
            {
                public Const_Trivial? Opt;

                public _InOptConst_Trivial() {}
                public _InOptConst_Trivial(Const_Trivial value) {Opt = value;}
                public static implicit operator _InOptConst_Trivial(Const_Trivial value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TrivialDerived`.
            /// This is the const half of the class.
            public class Const_TrivialDerived : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TrivialDerived(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TrivialDerived_Destroy(_Underlying *_this);
                    __MR_CSharp_TrivialDerived_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TrivialDerived() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_TrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                public unsafe Const_TrivialDerived(MR.CS.CSharp.Const_TrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_ConstructFromAnother(MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::TrivialDerived`.
            /// This is the non-const half of the class.
            public class TrivialDerived : Const_TrivialDerived
            {
                internal unsafe TrivialDerived(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe TrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                public unsafe TrivialDerived(MR.CS.CSharp.Const_TrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_ConstructFromAnother(MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TrivialDerived::operator=`.
                public unsafe MR.CS.CSharp.TrivialDerived assign(MR.CS.CSharp.Const_TrivialDerived _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    return new(__MR_CSharp_TrivialDerived_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `TrivialDerived` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TrivialDerived`/`Const_TrivialDerived` directly.
            public class _InOptMut_TrivialDerived
            {
                public TrivialDerived? Opt;

                public _InOptMut_TrivialDerived() {}
                public _InOptMut_TrivialDerived(TrivialDerived value) {Opt = value;}
                public static implicit operator _InOptMut_TrivialDerived(TrivialDerived value) {return new(value);}
            }

            /// This is used for optional parameters of class `TrivialDerived` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TrivialDerived`/`Const_TrivialDerived` to pass it to the function.
            public class _InOptConst_TrivialDerived
            {
                public Const_TrivialDerived? Opt;

                public _InOptConst_TrivialDerived() {}
                public _InOptConst_TrivialDerived(Const_TrivialDerived value) {Opt = value;}
                public static implicit operator _InOptConst_TrivialDerived(Const_TrivialDerived value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::NonTrivial`.
            /// This is the const half of the class.
            public class Const_NonTrivial : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_NonTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivial() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_NonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                public unsafe Const_NonTrivial(MR.CS.CSharp._ByValue_NonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// Generated from class `MR::CSharp::NonTrivial`.
            /// This is the non-const half of the class.
            public class NonTrivial : Const_NonTrivial
            {
                internal unsafe NonTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe NonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                public unsafe NonTrivial(MR.CS.CSharp._ByValue_NonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::NonTrivial::operator=`.
                public unsafe MR.CS.CSharp.NonTrivial assign(MR.CS.CSharp._ByValue_NonTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    return new(__MR_CSharp_NonTrivial_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `NonTrivial` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_NonTrivial
            {
                internal readonly Const_NonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivial(Const_NonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivial(Const_NonTrivial arg) {return new(arg);}
                public _ByValue_NonTrivial(MR.CS.Misc._Moved<NonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivial(MR.CS.Misc._Moved<NonTrivial> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives an optional `NonTrivial` by value,
            ///   and also has a default argument, meaning it has two different null states.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument.
            /// * Pass `MR.CS.Misc.NullOptType` to pass no object.
            public class _ByValueOptOpt_NonTrivial
            {
                internal readonly Const_NonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueOptOpt_NonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueOptOpt_NonTrivial(Const_NonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueOptOpt_NonTrivial(Const_NonTrivial arg) {return new(arg);}
                public _ByValueOptOpt_NonTrivial(MR.CS.Misc._Moved<NonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueOptOpt_NonTrivial(MR.CS.Misc._Moved<NonTrivial> arg) {return new(arg);}
                public _ByValueOptOpt_NonTrivial(MR.CS.Misc.NullOptType nullopt) {PassByMode = MR.CS.Misc._PassBy.no_object;}
                public static implicit operator _ByValueOptOpt_NonTrivial(MR.CS.Misc.NullOptType nullopt) {return new(nullopt);}
            }

            /// This is used for optional parameters of class `NonTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` directly.
            public class _InOptMut_NonTrivial
            {
                public NonTrivial? Opt;

                public _InOptMut_NonTrivial() {}
                public _InOptMut_NonTrivial(NonTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivial(NonTrivial value) {return new(value);}
            }

            /// This is used for optional parameters of class `NonTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to pass it to the function.
            public class _InOptConst_NonTrivial
            {
                public Const_NonTrivial? Opt;

                public _InOptConst_NonTrivial() {}
                public _InOptConst_NonTrivial(Const_NonTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivial(Const_NonTrivial value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::NonTrivialDerived`.
            /// This is the const half of the class.
            public class Const_NonTrivialDerived : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_NonTrivialDerived(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivialDerived_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivialDerived_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivialDerived() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_NonTrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                public unsafe Const_NonTrivialDerived(MR.CS.CSharp._ByValue_NonTrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// Generated from class `MR::CSharp::NonTrivialDerived`.
            /// This is the non-const half of the class.
            public class NonTrivialDerived : Const_NonTrivialDerived
            {
                internal unsafe NonTrivialDerived(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe NonTrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                public unsafe NonTrivialDerived(MR.CS.CSharp._ByValue_NonTrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::NonTrivialDerived::operator=`.
                public unsafe MR.CS.CSharp.NonTrivialDerived assign(MR.CS.CSharp._ByValue_NonTrivialDerived _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    return new(__MR_CSharp_NonTrivialDerived_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `NonTrivialDerived` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_NonTrivialDerived
            {
                internal readonly Const_NonTrivialDerived? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivialDerived() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivialDerived(Const_NonTrivialDerived new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivialDerived(Const_NonTrivialDerived arg) {return new(arg);}
                public _ByValue_NonTrivialDerived(MR.CS.Misc._Moved<NonTrivialDerived> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivialDerived(MR.CS.Misc._Moved<NonTrivialDerived> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `NonTrivialDerived` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` directly.
            public class _InOptMut_NonTrivialDerived
            {
                public NonTrivialDerived? Opt;

                public _InOptMut_NonTrivialDerived() {}
                public _InOptMut_NonTrivialDerived(NonTrivialDerived value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivialDerived(NonTrivialDerived value) {return new(value);}
            }

            /// This is used for optional parameters of class `NonTrivialDerived` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` to pass it to the function.
            public class _InOptConst_NonTrivialDerived
            {
                public Const_NonTrivialDerived? Opt;

                public _InOptConst_NonTrivialDerived() {}
                public _InOptConst_NonTrivialDerived(Const_NonTrivialDerived value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivialDerived(Const_NonTrivialDerived value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SA`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the const half of the class.
            public class Const_SA : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SA_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SA_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SA_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SA(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SA(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SA _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SA_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SA_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SA() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SA_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SA::SA`.
                public unsafe Const_SA(MR.CS.CSharp.Const_SA _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_ConstructFromAnother(MR.CS.CSharp.SA._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SA_ConstructFromAnother(_other._UnderlyingPtr));
                }
            }

            /// Generated from class `MR::CSharp::SA`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the non-const half of the class.
            public class SA : Const_SA
            {
                internal unsafe SA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SA(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe SA() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SA_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SA::SA`.
                public unsafe SA(MR.CS.CSharp.Const_SA _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_ConstructFromAnother(MR.CS.CSharp.SA._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SA_ConstructFromAnother(_other._UnderlyingPtr));
                }

                /// Generated from method `MR::CSharp::SA::operator=`.
                public unsafe MR.CS.CSharp.SA assign(MR.CS.CSharp.Const_SA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.SA._Underlying *_other);
                    return new(__MR_CSharp_SA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SA` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SA`/`Const_SA` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SA
            {
                internal readonly Const_SA? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SA() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SA(Const_SA new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SA(Const_SA arg) {return new(arg);}
                public _ByValueShared_SA(MR.CS.Misc._Moved<SA> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SA(MR.CS.Misc._Moved<SA> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SA`/`Const_SA` directly.
            public class _InOptMut_SA
            {
                public SA? Opt;

                public _InOptMut_SA() {}
                public _InOptMut_SA(SA value) {Opt = value;}
                public static implicit operator _InOptMut_SA(SA value) {return new(value);}
            }

            /// This is used for optional parameters of class `SA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SA`/`Const_SA` to pass it to the function.
            public class _InOptConst_SA
            {
                public Const_SA? Opt;

                public _InOptConst_SA() {}
                public _InOptConst_SA(Const_SA value) {Opt = value;}
                public static implicit operator _InOptConst_SA(Const_SA value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SB`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the const half of the class.
            public class Const_SB : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SB_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SB_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SB_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SB_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SB_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SB_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SB(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SB_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SB_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SB_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SB_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SB(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SB _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SB_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SB_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SB_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SB_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SB_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SB_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SB_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SB() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SB_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SB::SB`.
                public unsafe Const_SB(MR.CS.CSharp._ByValue_SB _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }
            }

            /// Generated from class `MR::CSharp::SB`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the non-const half of the class.
            public class SB : Const_SB
            {
                internal unsafe SB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SB(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe SB() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SB_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SB::SB`.
                public unsafe SB(MR.CS.CSharp._ByValue_SB _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }

                /// Generated from method `MR::CSharp::SB::operator=`.
                public unsafe MR.CS.CSharp.SB assign(MR.CS.CSharp._ByValue_SB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    return new(__MR_CSharp_SB_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SB` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SB`/`Const_SB` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_SB
            {
                internal readonly Const_SB? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SB() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SB(Const_SB new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SB(Const_SB arg) {return new(arg);}
                public _ByValue_SB(MR.CS.Misc._Moved<SB> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SB(MR.CS.Misc._Moved<SB> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives `SB` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SB`/`Const_SB` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SB
            {
                internal readonly Const_SB? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SB() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SB(Const_SB new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SB(Const_SB arg) {return new(arg);}
                public _ByValueShared_SB(MR.CS.Misc._Moved<SB> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SB(MR.CS.Misc._Moved<SB> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SB`/`Const_SB` directly.
            public class _InOptMut_SB
            {
                public SB? Opt;

                public _InOptMut_SB() {}
                public _InOptMut_SB(SB value) {Opt = value;}
                public static implicit operator _InOptMut_SB(SB value) {return new(value);}
            }

            /// This is used for optional parameters of class `SB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SB`/`Const_SB` to pass it to the function.
            public class _InOptConst_SB
            {
                public Const_SB? Opt;

                public _InOptConst_SB() {}
                public _InOptConst_SB(Const_SB value) {Opt = value;}
                public static implicit operator _InOptConst_SB(Const_SB value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SC`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SA`
            ///     `MR::CSharp::SB`
            /// This is the const half of the class.
            public class Const_SC : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SC_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SC_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SC_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SC_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SC_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SC_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SC(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SC_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SC_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SC_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SC_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SC(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SC _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SC_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SC_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SC_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SC_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SC_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SC_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SC_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SC() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_SA(Const_SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SA._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(_Underlying *_this);
                    return MR.CS.CSharp.Const_SA._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SC_UpcastTo_MR_CSharp_SA(self._UnderlyingPtr));
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_SB(Const_SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SB._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(_Underlying *_this);
                    return MR.CS.CSharp.Const_SB._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SC_UpcastTo_MR_CSharp_SB(self._UnderlyingPtr));
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SC() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SC_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SC::SC`.
                public unsafe Const_SC(MR.CS.CSharp._ByValue_SC _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }
            }

            /// Generated from class `MR::CSharp::SC`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SA`
            ///     `MR::CSharp::SB`
            /// This is the non-const half of the class.
            public class SC : Const_SC
            {
                internal unsafe SC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SC(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.SA(SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(_Underlying *_this);
                    return MR.CS.CSharp.SA._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SC_UpcastTo_MR_CSharp_SA(self._UnderlyingPtr));
                }
                public static unsafe implicit operator MR.CS.CSharp.SB(SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(_Underlying *_this);
                    return MR.CS.CSharp.SB._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SC_UpcastTo_MR_CSharp_SB(self._UnderlyingPtr));
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe SC() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SC_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SC::SC`.
                public unsafe SC(MR.CS.CSharp._ByValue_SC _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }

                /// Generated from method `MR::CSharp::SC::operator=`.
                public unsafe MR.CS.CSharp.SC assign(MR.CS.CSharp._ByValue_SC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    return new(__MR_CSharp_SC_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SC`/`Const_SC` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_SC
            {
                internal readonly Const_SC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SC(Const_SC new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SC(Const_SC arg) {return new(arg);}
                public _ByValue_SC(MR.CS.Misc._Moved<SC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SC(MR.CS.Misc._Moved<SC> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives `SC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SC`/`Const_SC` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SC
            {
                internal readonly Const_SC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SC(Const_SC new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SC(Const_SC arg) {return new(arg);}
                public _ByValueShared_SC(MR.CS.Misc._Moved<SC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SC(MR.CS.Misc._Moved<SC> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SC`/`Const_SC` directly.
            public class _InOptMut_SC
            {
                public SC? Opt;

                public _InOptMut_SC() {}
                public _InOptMut_SC(SC value) {Opt = value;}
                public static implicit operator _InOptMut_SC(SC value) {return new(value);}
            }

            /// This is used for optional parameters of class `SC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SC`/`Const_SC` to pass it to the function.
            public class _InOptConst_SC
            {
                public Const_SC? Opt;

                public _InOptConst_SC() {}
                public _InOptConst_SC(Const_SC value) {Opt = value;}
                public static implicit operator _InOptConst_SC(Const_SC value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SD`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the const half of the class.
            public class Const_SD : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SD_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SD_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SD_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SD_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SD_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SD_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SD(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SD_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SD_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SD_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SD_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SD(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SD _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SD_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SD_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SD_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SD_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SD_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SD_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SD_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SD() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SD_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SD::SD`.
                public unsafe Const_SD(MR.CS.CSharp._ByValue_SD _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SD_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }
            }

            /// Generated from class `MR::CSharp::SD`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the non-const half of the class.
            public class SD : Const_SD
            {
                internal unsafe SD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SD(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe SD() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SD_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SD::SD`.
                public unsafe SD(MR.CS.CSharp._ByValue_SD _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SD_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }

                /// Generated from method `MR::CSharp::SD::operator=`.
                public unsafe MR.CS.CSharp.SD assign(MR.CS.CSharp._ByValue_SD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    return new(__MR_CSharp_SD_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SD` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SD`/`Const_SD` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_SD
            {
                internal readonly Const_SD? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SD() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SD(Const_SD new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SD(Const_SD arg) {return new(arg);}
                public _ByValue_SD(MR.CS.Misc._Moved<SD> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SD(MR.CS.Misc._Moved<SD> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives `SD` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SD`/`Const_SD` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SD
            {
                internal readonly Const_SD? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SD() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SD(Const_SD new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SD(Const_SD arg) {return new(arg);}
                public _ByValueShared_SD(MR.CS.Misc._Moved<SD> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SD(MR.CS.Misc._Moved<SD> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SD`/`Const_SD` directly.
            public class _InOptMut_SD
            {
                public SD? Opt;

                public _InOptMut_SD() {}
                public _InOptMut_SD(SD value) {Opt = value;}
                public static implicit operator _InOptMut_SD(SD value) {return new(value);}
            }

            /// This is used for optional parameters of class `SD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SD`/`Const_SD` to pass it to the function.
            public class _InOptConst_SD
            {
                public Const_SD? Opt;

                public _InOptConst_SD() {}
                public _InOptConst_SD(Const_SD value) {Opt = value;}
                public static implicit operator _InOptConst_SD(Const_SD value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SE`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the const half of the class.
            public class Const_SE : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SE_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SE_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SE_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SE(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SE(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SE _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SE_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SE_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SE() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SE_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SE::SE`.
                public unsafe Const_SE(MR.CS.CSharp._ByValue_SE _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }
            }

            /// Generated from class `MR::CSharp::SE`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the non-const half of the class.
            public class SE : Const_SE
            {
                internal unsafe SE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SE(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe SE() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SE_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SE::SE`.
                public unsafe SE(MR.CS.CSharp._ByValue_SE _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }

                /// Generated from method `MR::CSharp::SE::operator=`.
                public unsafe MR.CS.CSharp.SE assign(MR.CS.CSharp._ByValue_SE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    return new(__MR_CSharp_SE_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SE`/`Const_SE` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_SE
            {
                internal readonly Const_SE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SE(Const_SE new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SE(Const_SE arg) {return new(arg);}
                public _ByValue_SE(MR.CS.Misc._Moved<SE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SE(MR.CS.Misc._Moved<SE> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives `SE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SE`/`Const_SE` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SE
            {
                internal readonly Const_SE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SE(Const_SE new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SE(Const_SE arg) {return new(arg);}
                public _ByValueShared_SE(MR.CS.Misc._Moved<SE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SE(MR.CS.Misc._Moved<SE> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SE`/`Const_SE` directly.
            public class _InOptMut_SE
            {
                public SE? Opt;

                public _InOptMut_SE() {}
                public _InOptMut_SE(SE value) {Opt = value;}
                public static implicit operator _InOptMut_SE(SE value) {return new(value);}
            }

            /// This is used for optional parameters of class `SE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SE`/`Const_SE` to pass it to the function.
            public class _InOptConst_SE
            {
                public Const_SE? Opt;

                public _InOptConst_SE() {}
                public _InOptConst_SE(Const_SE value) {Opt = value;}
                public static implicit operator _InOptConst_SE(Const_SE value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::SF`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SD`
            ///     `MR::CSharp::SE`
            /// This is the const half of the class.
            public class Const_SF : MR.CS.Misc.SharedObject, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SF_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SF_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SF_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SF_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SF_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SF_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                internal unsafe Const_SF(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SF_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SF_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SF_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SF_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SF(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SF _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SF_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SF_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SF_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SF_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SF_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SF_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SF_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SF() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_SD(Const_SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SD._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(_Underlying *_this);
                    return MR.CS.CSharp.Const_SD._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SF_UpcastTo_MR_CSharp_SD(self._UnderlyingPtr));
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_SE(Const_SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SE._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(_Underlying *_this);
                    return MR.CS.CSharp.Const_SE._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SF_UpcastTo_MR_CSharp_SE(self._UnderlyingPtr));
                }

                // Downcasts:
                public static unsafe explicit operator Const_SF?(MR.CS.CSharp.Const_SD parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(MR.CS.CSharp.Const_SD._Underlying *_this);
                    var ptr = __MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    return Const_SF._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)parent._UnderlyingSharedPtr, ptr);
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_SF() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SF_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SF::SF`.
                public unsafe Const_SF(MR.CS.CSharp._ByValue_SF _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }
            }

            /// Generated from class `MR::CSharp::SF`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SD`
            ///     `MR::CSharp::SE`
            /// This is the non-const half of the class.
            public class SF : Const_SF
            {
                internal unsafe SF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SF(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.SD(SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(_Underlying *_this);
                    return MR.CS.CSharp.SD._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SF_UpcastTo_MR_CSharp_SD(self._UnderlyingPtr));
                }
                public static unsafe implicit operator MR.CS.CSharp.SE(SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(_Underlying *_this);
                    return MR.CS.CSharp.SE._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)self._UnderlyingSharedPtr, __MR_CSharp_SF_UpcastTo_MR_CSharp_SE(self._UnderlyingPtr));
                }

                // Downcasts:
                public static unsafe explicit operator SF?(MR.CS.CSharp.SD parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(MR.CS.CSharp.SD._Underlying *_this);
                    var ptr = __MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    return SF._MakeAliasing((MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *)parent._UnderlyingSharedPtr, ptr);
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe SF() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SF_DefaultConstruct());
                }

                /// Generated from constructor `MR::CSharp::SF::SF`.
                public unsafe SF(MR.CS.CSharp._ByValue_SF _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                }

                /// Generated from method `MR::CSharp::SF::operator=`.
                public unsafe MR.CS.CSharp.SF assign(MR.CS.CSharp._ByValue_SF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    return new(__MR_CSharp_SF_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `SF` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SF`/`Const_SF` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_SF
            {
                internal readonly Const_SF? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SF() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SF(Const_SF new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SF(Const_SF arg) {return new(arg);}
                public _ByValue_SF(MR.CS.Misc._Moved<SF> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SF(MR.CS.Misc._Moved<SF> arg) {return new(arg);}
            }

            /// This is used as a function parameter when the underlying function receives `SF` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SF`/`Const_SF` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_SF
            {
                internal readonly Const_SF? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SF() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SF(Const_SF new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SF(Const_SF arg) {return new(arg);}
                public _ByValueShared_SF(MR.CS.Misc._Moved<SF> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SF(MR.CS.Misc._Moved<SF> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `SF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SF`/`Const_SF` directly.
            public class _InOptMut_SF
            {
                public SF? Opt;

                public _InOptMut_SF() {}
                public _InOptMut_SF(SF value) {Opt = value;}
                public static implicit operator _InOptMut_SF(SF value) {return new(value);}
            }

            /// This is used for optional parameters of class `SF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SF`/`Const_SF` to pass it to the function.
            public class _InOptConst_SF
            {
                public Const_SF? Opt;

                public _InOptConst_SF() {}
                public _InOptConst_SF(Const_SF value) {Opt = value;}
                public static implicit operator _InOptConst_SF(Const_SF value) {return new(value);}
            }

            // Nested classes.
            /// Generated from class `MR::CSharp::Outer`.
            /// This is the const half of the class.
            public class Const_Outer : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_Outer(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_Outer_Destroy(_Underlying *_this);
                    __MR_CSharp_Outer_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_Outer() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_Outer() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Outer_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                public unsafe Const_Outer(MR.CS.CSharp.Const_Outer _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_ConstructFromAnother(MR.CS.CSharp.Outer._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Outer_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from class `MR::CSharp::Outer::Inner`.
                /// This is the const half of the class.
                public class Const_Inner : MR.CS.Misc.Object, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    internal unsafe Const_Inner(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_Outer_Inner_Destroy(_Underlying *_this);
                        __MR_CSharp_Outer_Inner_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_Inner() {Dispose(false);}

                    /// Constructs an empty (default-constructed) instance.
                    public unsafe Const_Inner() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_DefaultConstruct();
                    }

                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    public unsafe Const_Inner(MR.CS.CSharp.Outer.Const_Inner _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_ConstructFromAnother(MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_ConstructFromAnother(_other._UnderlyingPtr);
                    }
                }

                /// Generated from class `MR::CSharp::Outer::Inner`.
                /// This is the non-const half of the class.
                public class Inner : Const_Inner
                {
                    internal unsafe Inner(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    /// Constructs an empty (default-constructed) instance.
                    public unsafe Inner() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_DefaultConstruct();
                    }

                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    public unsafe Inner(MR.CS.CSharp.Outer.Const_Inner _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_ConstructFromAnother(MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_ConstructFromAnother(_other._UnderlyingPtr);
                    }

                    /// Generated from method `MR::CSharp::Outer::Inner::operator=`.
                    public unsafe MR.CS.CSharp.Outer.Inner assign(MR.CS.CSharp.Outer.Const_Inner _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        return new(__MR_CSharp_Outer_Inner_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }

                    /// Generated from method `MR::CSharp::Outer::Inner::bar`.
                    public unsafe void bar()
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_bar", ExactSpelling = true)]
                        extern static void __MR_CSharp_Outer_Inner_bar(_Underlying *_this);
                        __MR_CSharp_Outer_Inner_bar(_UnderlyingPtr);
                    }
                }

                /// This is used for optional parameters of class `Inner` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_Inner`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Inner`/`Const_Inner` directly.
                public class _InOptMut_Inner
                {
                    public Inner? Opt;

                    public _InOptMut_Inner() {}
                    public _InOptMut_Inner(Inner value) {Opt = value;}
                    public static implicit operator _InOptMut_Inner(Inner value) {return new(value);}
                }

                /// This is used for optional parameters of class `Inner` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_Inner`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Inner`/`Const_Inner` to pass it to the function.
                public class _InOptConst_Inner
                {
                    public Const_Inner? Opt;

                    public _InOptConst_Inner() {}
                    public _InOptConst_Inner(Const_Inner value) {Opt = value;}
                    public static implicit operator _InOptConst_Inner(Const_Inner value) {return new(value);}
                }
            }

            // Nested classes.
            /// Generated from class `MR::CSharp::Outer`.
            /// This is the non-const half of the class.
            public class Outer : Const_Outer
            {
                internal unsafe Outer(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Outer() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Outer_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                public unsafe Outer(MR.CS.CSharp.Const_Outer _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_ConstructFromAnother(MR.CS.CSharp.Outer._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Outer_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::Outer::operator=`.
                public unsafe MR.CS.CSharp.Outer assign(MR.CS.CSharp.Const_Outer _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Outer._Underlying *_other);
                    return new(__MR_CSharp_Outer_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::Outer::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_Outer_foo(_Underlying *_this);
                    __MR_CSharp_Outer_foo(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `Outer` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_Outer`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Outer`/`Const_Outer` directly.
            public class _InOptMut_Outer
            {
                public Outer? Opt;

                public _InOptMut_Outer() {}
                public _InOptMut_Outer(Outer value) {Opt = value;}
                public static implicit operator _InOptMut_Outer(Outer value) {return new(value);}
            }

            /// This is used for optional parameters of class `Outer` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_Outer`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Outer`/`Const_Outer` to pass it to the function.
            public class _InOptConst_Outer
            {
                public Const_Outer? Opt;

                public _InOptConst_Outer() {}
                public _InOptConst_Outer(Const_Outer value) {Opt = value;}
                public static implicit operator _InOptConst_Outer(Const_Outer value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TestFields`.
            /// This is the const half of the class.
            public class Const_TestFields : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TestFields(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestFields_Destroy(_Underlying *_this);
                    __MR_CSharp_TestFields_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestFields() {Dispose(false);}

                public static unsafe ref int StaticI
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_static_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_GetMutable_static_i();
                        return ref *__MR_CSharp_TestFields_GetMutable_static_i();
                    }
                }

                public static unsafe int StaticConstI
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_const_i();
                        return *__MR_CSharp_TestFields_Get_static_const_i();
                    }
                }

                public static unsafe ref int StaticIRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_i_ref();
                        return ref *__MR_CSharp_TestFields_Get_static_i_ref();
                    }
                }

                public static unsafe int StaticConstIRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_const_i_ref();
                        return *__MR_CSharp_TestFields_Get_static_const_i_ref();
                    }
                }

                public static unsafe MR.CS.Std.String StaticS
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_static_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_GetMutable_static_s();
                        return new(__MR_CSharp_TestFields_GetMutable_static_s(), is_owning: false);
                    }
                }

                public static unsafe MR.CS.Std.Const_String StaticConstS
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_static_const_s();
                        return new(__MR_CSharp_TestFields_Get_static_const_s(), is_owning: false);
                    }
                }

                public static unsafe MR.CS.Std.String StaticSRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_Get_static_s_ref();
                        return new(__MR_CSharp_TestFields_Get_static_s_ref(), is_owning: false);
                    }
                }

                public static unsafe MR.CS.Std.Const_String StaticConstSRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_static_const_s_ref();
                        return new(__MR_CSharp_TestFields_Get_static_const_s_ref(), is_owning: false);
                    }
                }

                public unsafe int i
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_i(_Underlying *_this);
                        return *__MR_CSharp_TestFields_Get_i(_UnderlyingPtr);
                    }
                }

                public unsafe int constI
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_const_i(_Underlying *_this);
                        return *__MR_CSharp_TestFields_Get_const_i(_UnderlyingPtr);
                    }
                }

                public unsafe ref int iRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_i_ref(_Underlying *_this);
                        return ref *__MR_CSharp_TestFields_Get_i_ref(_UnderlyingPtr);
                    }
                }

                public unsafe int constIRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_const_i_ref(_Underlying *_this);
                        return *__MR_CSharp_TestFields_Get_const_i_ref(_UnderlyingPtr);
                    }
                }

                public unsafe MR.CS.Std.Const_String s
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_s(_Underlying *_this);
                        return new(__MR_CSharp_TestFields_Get_s(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.Std.Const_String constS
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_const_s(_Underlying *_this);
                        return new(__MR_CSharp_TestFields_Get_const_s(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.Std.String sRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_Get_s_ref(_Underlying *_this);
                        return new(__MR_CSharp_TestFields_Get_s_ref(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.Std.Const_String constSRef
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_const_s_ref(_Underlying *_this);
                        return new(__MR_CSharp_TestFields_Get_const_s_ref(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                public unsafe Const_TestFields(MR.CS.CSharp._ByValue_TestFields _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestFields._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Constructs `MR::CSharp::TestFields` elementwise.
                public unsafe Const_TestFields(int i, int const_i, ref int i_ref, int const_i_ref, ReadOnlySpan<char> s, ReadOnlySpan<char> const_s, MR.CS.Std.String s_ref, ReadOnlySpan<char> const_s_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFrom(int i, int const_i, int *i_ref, int *const_i_ref, byte *s, byte *s_end, byte *const_s, byte *const_s_end, MR.CS.Std.String._Underlying *s_ref, byte *const_s_ref, byte *const_s_ref_end);
                    fixed (int *__ptr_i_ref = &i_ref)
                    {
                        byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                        int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                        fixed (byte *__ptr_s = __bytes_s)
                        {
                            byte[] __bytes_const_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s.Length)];
                            int __len_const_s = System.Text.Encoding.UTF8.GetBytes(const_s, __bytes_const_s);
                            fixed (byte *__ptr_const_s = __bytes_const_s)
                            {
                                byte[] __bytes_const_s_ref = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s_ref.Length)];
                                int __len_const_s_ref = System.Text.Encoding.UTF8.GetBytes(const_s_ref, __bytes_const_s_ref);
                                fixed (byte *__ptr_const_s_ref = __bytes_const_s_ref)
                                {
                                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFrom(i, const_i, __ptr_i_ref, &const_i_ref, __ptr_s, __ptr_s + __len_s, __ptr_const_s, __ptr_const_s + __len_const_s, s_ref._UnderlyingPtr, __ptr_const_s_ref, __ptr_const_s_ref + __len_const_s_ref);
                                }
                            }
                        }
                    }
                }
            }

            /// Generated from class `MR::CSharp::TestFields`.
            /// This is the non-const half of the class.
            public class TestFields : Const_TestFields
            {
                internal unsafe TestFields(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe ref int i
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_GetMutable_i(_Underlying *_this);
                        return ref *__MR_CSharp_TestFields_GetMutable_i(_UnderlyingPtr);
                    }
                }

                public new unsafe MR.CS.Std.String s
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_GetMutable_s(_Underlying *_this);
                        return new(__MR_CSharp_TestFields_GetMutable_s(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                public unsafe TestFields(MR.CS.CSharp._ByValue_TestFields _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestFields._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Constructs `MR::CSharp::TestFields` elementwise.
                public unsafe TestFields(int i, int const_i, ref int i_ref, int const_i_ref, ReadOnlySpan<char> s, ReadOnlySpan<char> const_s, MR.CS.Std.String s_ref, ReadOnlySpan<char> const_s_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFrom(int i, int const_i, int *i_ref, int *const_i_ref, byte *s, byte *s_end, byte *const_s, byte *const_s_end, MR.CS.Std.String._Underlying *s_ref, byte *const_s_ref, byte *const_s_ref_end);
                    fixed (int *__ptr_i_ref = &i_ref)
                    {
                        byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                        int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                        fixed (byte *__ptr_s = __bytes_s)
                        {
                            byte[] __bytes_const_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s.Length)];
                            int __len_const_s = System.Text.Encoding.UTF8.GetBytes(const_s, __bytes_const_s);
                            fixed (byte *__ptr_const_s = __bytes_const_s)
                            {
                                byte[] __bytes_const_s_ref = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s_ref.Length)];
                                int __len_const_s_ref = System.Text.Encoding.UTF8.GetBytes(const_s_ref, __bytes_const_s_ref);
                                fixed (byte *__ptr_const_s_ref = __bytes_const_s_ref)
                                {
                                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFrom(i, const_i, __ptr_i_ref, &const_i_ref, __ptr_s, __ptr_s + __len_s, __ptr_const_s, __ptr_const_s + __len_const_s, s_ref._UnderlyingPtr, __ptr_const_s_ref, __ptr_const_s_ref + __len_const_s_ref);
                                }
                            }
                        }
                    }
                }
            }

            /// This is used as a function parameter when the underlying function receives `TestFields` by value.
            /// Usage:
            /// * Pass an instance of `TestFields`/`Const_TestFields` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_TestFields
            {
                internal readonly Const_TestFields? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_TestFields(Const_TestFields new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_TestFields(Const_TestFields arg) {return new(arg);}
                public _ByValue_TestFields(MR.CS.Misc._Moved<TestFields> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_TestFields(MR.CS.Misc._Moved<TestFields> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `TestFields` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestFields`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestFields`/`Const_TestFields` directly.
            public class _InOptMut_TestFields
            {
                public TestFields? Opt;

                public _InOptMut_TestFields() {}
                public _InOptMut_TestFields(TestFields value) {Opt = value;}
                public static implicit operator _InOptMut_TestFields(TestFields value) {return new(value);}
            }

            /// This is used for optional parameters of class `TestFields` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestFields`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestFields`/`Const_TestFields` to pass it to the function.
            public class _InOptConst_TestFields
            {
                public Const_TestFields? Opt;

                public _InOptConst_TestFields() {}
                public _InOptConst_TestFields(Const_TestFields value) {Opt = value;}
                public static implicit operator _InOptConst_TestFields(Const_TestFields value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TestConstness`.
            /// This is the const half of the class.
            public class Const_TestConstness : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TestConstness(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_Destroy(_Underlying *_this);
                    __MR_CSharp_TestConstness_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestConstness() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_TestConstness() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TestConstness_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                public unsafe Const_TestConstness(MR.CS.CSharp.Const_TestConstness _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_ConstructFromAnother(MR.CS.CSharp.TestConstness._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestConstness_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestConstness::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_foo_const", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_foo_const(_Underlying *_this);
                    __MR_CSharp_TestConstness_foo_const(_UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::TestConstness`.
            /// This is the non-const half of the class.
            public class TestConstness : Const_TestConstness
            {
                internal unsafe TestConstness(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe TestConstness() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TestConstness_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                public unsafe TestConstness(MR.CS.CSharp.Const_TestConstness _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_ConstructFromAnother(MR.CS.CSharp.TestConstness._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestConstness_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestConstness::operator=`.
                public unsafe MR.CS.CSharp.TestConstness assign(MR.CS.CSharp.Const_TestConstness _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestConstness._Underlying *_other);
                    return new(__MR_CSharp_TestConstness_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::TestConstness::foo`.
                public unsafe new void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_foo(_Underlying *_this);
                    __MR_CSharp_TestConstness_foo(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `TestConstness` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestConstness`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestConstness`/`Const_TestConstness` directly.
            public class _InOptMut_TestConstness
            {
                public TestConstness? Opt;

                public _InOptMut_TestConstness() {}
                public _InOptMut_TestConstness(TestConstness value) {Opt = value;}
                public static implicit operator _InOptMut_TestConstness(TestConstness value) {return new(value);}
            }

            /// This is used for optional parameters of class `TestConstness` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestConstness`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestConstness`/`Const_TestConstness` to pass it to the function.
            public class _InOptConst_TestConstness
            {
                public Const_TestConstness? Opt;

                public _InOptConst_TestConstness() {}
                public _InOptConst_TestConstness(Const_TestConstness value) {Opt = value;}
                public static implicit operator _InOptConst_TestConstness(Const_TestConstness value) {return new(value);}
            }

            // This is the happy path.
            // This emits static operators in the const half, and non-static operators (or functions pre C# 14) in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrA`.
            /// This is the const half of the class.
            public class Const_IncrDecrA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrA_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                public unsafe Const_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_ConstructFromAnother(MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrA::operator++`.
                public static unsafe IncrDecrA operator++(MR.CS.CSharp.Const_IncrDecrA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_incr_MR_CSharp_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA._Underlying *_this);
                    IncrDecrA __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrA __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrA(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrA::operator--`.
                public static unsafe IncrDecrA operator--(MR.CS.CSharp.Const_IncrDecrA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_decr_MR_CSharp_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA._Underlying *_this);
                    IncrDecrA __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrA __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrA(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This is the happy path.
            // This emits static operators in the const half, and non-static operators (or functions pre C# 14) in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrA`.
            /// This is the non-const half of the class.
            public class IncrDecrA : Const_IncrDecrA
            {
                internal unsafe IncrDecrA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                public unsafe IncrDecrA(MR.CS.CSharp.Const_IncrDecrA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_ConstructFromAnother(MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrA::operator=`.
                public unsafe MR.CS.CSharp.IncrDecrA assign(MR.CS.CSharp.Const_IncrDecrA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    return new(__MR_CSharp_IncrDecrA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrA::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_incr_MR_CSharp_IncrDecrA(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrA __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrA(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrA::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_decr_MR_CSharp_IncrDecrA(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrA __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrA(_UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `IncrDecrA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrA`/`Const_IncrDecrA` directly.
            public class _InOptMut_IncrDecrA
            {
                public IncrDecrA? Opt;

                public _InOptMut_IncrDecrA() {}
                public _InOptMut_IncrDecrA(IncrDecrA value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrA(IncrDecrA value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrA`/`Const_IncrDecrA` to pass it to the function.
            public class _InOptConst_IncrDecrA
            {
                public Const_IncrDecrA? Opt;

                public _InOptConst_IncrDecrA() {}
                public _InOptConst_IncrDecrA(Const_IncrDecrA value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrA(Const_IncrDecrA value) {return new(value);}
            }

            // This is a somewhat happy path. Same as above, but everything gets emitted in the const half.
            /// Generated from class `MR::CSharp::IncrDecrB`.
            /// This is the const half of the class.
            public class Const_IncrDecrB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrB_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                public unsafe Const_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_ConstructFromAnother(MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrB::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_incr_MR_CSharp_IncrDecrB(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrB __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrB(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrB::operator++`.
                public static unsafe IncrDecrB operator++(MR.CS.CSharp.Const_IncrDecrB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_incr_MR_CSharp_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB._Underlying *_this);
                    IncrDecrB __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrB __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrB(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrB::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_decr_MR_CSharp_IncrDecrB(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrB __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrB(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrB::operator--`.
                public static unsafe IncrDecrB operator--(MR.CS.CSharp.Const_IncrDecrB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_decr_MR_CSharp_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB._Underlying *_this);
                    IncrDecrB __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrB __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrB(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This is a somewhat happy path. Same as above, but everything gets emitted in the const half.
            /// Generated from class `MR::CSharp::IncrDecrB`.
            /// This is the non-const half of the class.
            public class IncrDecrB : Const_IncrDecrB
            {
                internal unsafe IncrDecrB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                public unsafe IncrDecrB(MR.CS.CSharp.Const_IncrDecrB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_ConstructFromAnother(MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrB::operator=`.
                public unsafe MR.CS.CSharp.IncrDecrB assign(MR.CS.CSharp.Const_IncrDecrB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    return new(__MR_CSharp_IncrDecrB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `IncrDecrB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrB`/`Const_IncrDecrB` directly.
            public class _InOptMut_IncrDecrB
            {
                public IncrDecrB? Opt;

                public _InOptMut_IncrDecrB() {}
                public _InOptMut_IncrDecrB(IncrDecrB value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrB(IncrDecrB value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrB`/`Const_IncrDecrB` to pass it to the function.
            public class _InOptConst_IncrDecrB
            {
                public Const_IncrDecrB? Opt;

                public _InOptConst_IncrDecrB() {}
                public _InOptConst_IncrDecrB(Const_IncrDecrB value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrB(Const_IncrDecrB value) {return new(value);}
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are not marked const, so they're also in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrC`.
            /// This is the const half of the class.
            public class Const_IncrDecrC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrC_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrC::IncrDecrC`.
                public unsafe Const_IncrDecrC(MR.CS.CSharp.Const_IncrDecrC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_ConstructFromAnother(MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are not marked const, so they're also in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrC`.
            /// This is the non-const half of the class.
            public class IncrDecrC : Const_IncrDecrC
            {
                internal unsafe IncrDecrC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrC::IncrDecrC`.
                public unsafe IncrDecrC(MR.CS.CSharp.Const_IncrDecrC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_ConstructFromAnother(MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrC::operator=`.
                public unsafe MR.CS.CSharp.IncrDecrC assign(MR.CS.CSharp.Const_IncrDecrC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    return new(__MR_CSharp_IncrDecrC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrC::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_incr_MR_CSharp_IncrDecrC(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrC __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrC(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrC::operator++`.
                public static unsafe IncrDecrC operator++(MR.CS.CSharp.IncrDecrC _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_incr_MR_CSharp_IncrDecrC(MR.CS.CSharp.IncrDecrC._Underlying *_this);
                    IncrDecrC __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrC __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrC(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrC::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_decr_MR_CSharp_IncrDecrC(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrC __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrC(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrC::operator--`.
                public static unsafe IncrDecrC operator--(MR.CS.CSharp.IncrDecrC _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_decr_MR_CSharp_IncrDecrC(MR.CS.CSharp.IncrDecrC._Underlying *_this);
                    IncrDecrC __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrC __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrC(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            /// This is used for optional parameters of class `IncrDecrC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrC`/`Const_IncrDecrC` directly.
            public class _InOptMut_IncrDecrC
            {
                public IncrDecrC? Opt;

                public _InOptMut_IncrDecrC() {}
                public _InOptMut_IncrDecrC(IncrDecrC value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrC(IncrDecrC value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrC`/`Const_IncrDecrC` to pass it to the function.
            public class _InOptConst_IncrDecrC
            {
                public Const_IncrDecrC? Opt;

                public _InOptConst_IncrDecrC() {}
                public _InOptConst_IncrDecrC(Const_IncrDecrC value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrC(Const_IncrDecrC value) {return new(value);}
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are in the const half due to being marked const.
            /// Generated from class `MR::CSharp::IncrDecrD`.
            /// This is the const half of the class.
            public class Const_IncrDecrD : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrD_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrD::IncrDecrD`.
                public unsafe Const_IncrDecrD(MR.CS.CSharp.Const_IncrDecrD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_ConstructFromAnother(MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrD::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_incr_MR_CSharp_IncrDecrD(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrD __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrD(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrD::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_decr_MR_CSharp_IncrDecrD(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrD __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrD(_UnderlyingPtr), is_owning: false);
                }
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are in the const half due to being marked const.
            /// Generated from class `MR::CSharp::IncrDecrD`.
            /// This is the non-const half of the class.
            public class IncrDecrD : Const_IncrDecrD
            {
                internal unsafe IncrDecrD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrD::IncrDecrD`.
                public unsafe IncrDecrD(MR.CS.CSharp.Const_IncrDecrD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_ConstructFromAnother(MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrD::operator=`.
                public unsafe MR.CS.CSharp.IncrDecrD assign(MR.CS.CSharp.Const_IncrDecrD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    return new(__MR_CSharp_IncrDecrD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrD::operator++`.
                public static unsafe IncrDecrD operator++(MR.CS.CSharp.IncrDecrD _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_incr_MR_CSharp_IncrDecrD(MR.CS.CSharp.IncrDecrD._Underlying *_this);
                    IncrDecrD __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrD __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrD(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrD::operator--`.
                public static unsafe IncrDecrD operator--(MR.CS.CSharp.IncrDecrD _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_decr_MR_CSharp_IncrDecrD(MR.CS.CSharp.IncrDecrD._Underlying *_this);
                    IncrDecrD __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrD __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrD(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            /// This is used for optional parameters of class `IncrDecrD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrD`/`Const_IncrDecrD` directly.
            public class _InOptMut_IncrDecrD
            {
                public IncrDecrD? Opt;

                public _InOptMut_IncrDecrD() {}
                public _InOptMut_IncrDecrD(IncrDecrD value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrD(IncrDecrD value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrD`/`Const_IncrDecrD` to pass it to the function.
            public class _InOptConst_IncrDecrD
            {
                public Const_IncrDecrD? Opt;

                public _InOptConst_IncrDecrD() {}
                public _InOptConst_IncrDecrD(Const_IncrDecrD value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrD(Const_IncrDecrD value) {return new(value);}
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrE`.
            /// This is the const half of the class.
            public class Const_IncrDecrE : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrE_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrE::IncrDecrE`.
                public unsafe Const_IncrDecrE(MR.CS.CSharp._ByValue_IncrDecrE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the non-const half.
            /// Generated from class `MR::CSharp::IncrDecrE`.
            /// This is the non-const half of the class.
            public class IncrDecrE : Const_IncrDecrE
            {
                internal unsafe IncrDecrE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrE::IncrDecrE`.
                public unsafe IncrDecrE(MR.CS.CSharp._ByValue_IncrDecrE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::IncrDecrE::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_C_incr_MR_CSharp_IncrDecrE(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrE __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrE(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrE::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_C_decr_MR_CSharp_IncrDecrE(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrE __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrE(_UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `IncrDecrE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_IncrDecrE
            {
                internal readonly Const_IncrDecrE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IncrDecrE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IncrDecrE(MR.CS.Misc._Moved<IncrDecrE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IncrDecrE(MR.CS.Misc._Moved<IncrDecrE> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `IncrDecrE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrE`/`Const_IncrDecrE` directly.
            public class _InOptMut_IncrDecrE
            {
                public IncrDecrE? Opt;

                public _InOptMut_IncrDecrE() {}
                public _InOptMut_IncrDecrE(IncrDecrE value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrE(IncrDecrE value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrE`/`Const_IncrDecrE` to pass it to the function.
            public class _InOptConst_IncrDecrE
            {
                public Const_IncrDecrE? Opt;

                public _InOptConst_IncrDecrE() {}
                public _InOptConst_IncrDecrE(Const_IncrDecrE value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrE(Const_IncrDecrE value) {return new(value);}
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the const half.
            /// Generated from class `MR::CSharp::IncrDecrF`.
            /// This is the const half of the class.
            public class Const_IncrDecrF : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrF_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrF() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrF::IncrDecrF`.
                public unsafe Const_IncrDecrF(MR.CS.CSharp._ByValue_IncrDecrF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::IncrDecrF::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrF", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrF._Underlying *__MR_C_incr_MR_CSharp_IncrDecrF(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrF __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrF(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrF::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrF", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrF._Underlying *__MR_C_decr_MR_CSharp_IncrDecrF(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrF __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrF(_UnderlyingPtr), is_owning: false);
                }
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the const half.
            /// Generated from class `MR::CSharp::IncrDecrF`.
            /// This is the non-const half of the class.
            public class IncrDecrF : Const_IncrDecrF
            {
                internal unsafe IncrDecrF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrF::IncrDecrF`.
                public unsafe IncrDecrF(MR.CS.CSharp._ByValue_IncrDecrF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// This is used as a function parameter when the underlying function receives `IncrDecrF` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_IncrDecrF
            {
                internal readonly Const_IncrDecrF? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IncrDecrF() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IncrDecrF(MR.CS.Misc._Moved<IncrDecrF> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IncrDecrF(MR.CS.Misc._Moved<IncrDecrF> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `IncrDecrF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrF`/`Const_IncrDecrF` directly.
            public class _InOptMut_IncrDecrF
            {
                public IncrDecrF? Opt;

                public _InOptMut_IncrDecrF() {}
                public _InOptMut_IncrDecrF(IncrDecrF value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrF(IncrDecrF value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrF`/`Const_IncrDecrF` to pass it to the function.
            public class _InOptConst_IncrDecrF
            {
                public Const_IncrDecrF? Opt;

                public _InOptConst_IncrDecrF() {}
                public _InOptConst_IncrDecrF(Const_IncrDecrF value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrF(Const_IncrDecrF value) {return new(value);}
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// Generated from class `MR::CSharp::IncrDecrG`.
            /// This is the const half of the class.
            public class Const_IncrDecrG : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrG_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrG() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrG::IncrDecrG`.
                public unsafe Const_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_ConstructFromAnother(MR.CS.CSharp.IncrDecrG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrG::operator++`.
                public static unsafe IncrDecrG operator++(MR.CS.CSharp.Const_IncrDecrG _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_incr_MR_CSharp_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG._Underlying *_this);
                    IncrDecrG __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrG __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrG(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrG::operator--`.
                public static unsafe IncrDecrG operator--(MR.CS.CSharp.Const_IncrDecrG _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_decr_MR_CSharp_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG._Underlying *_this);
                    IncrDecrG __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrG __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrG(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// Generated from class `MR::CSharp::IncrDecrG`.
            /// This is the non-const half of the class.
            public class IncrDecrG : Const_IncrDecrG
            {
                internal unsafe IncrDecrG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrG::IncrDecrG`.
                public unsafe IncrDecrG(MR.CS.CSharp.Const_IncrDecrG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_ConstructFromAnother(MR.CS.CSharp.IncrDecrG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrG::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_incr_MR_CSharp_IncrDecrG(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrG __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrG(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrG::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_decr_MR_CSharp_IncrDecrG(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrG __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrG(_UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `IncrDecrG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrG`/`Const_IncrDecrG` directly.
            public class _InOptMut_IncrDecrG
            {
                public IncrDecrG? Opt;

                public _InOptMut_IncrDecrG() {}
                public _InOptMut_IncrDecrG(IncrDecrG value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrG(IncrDecrG value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrG`/`Const_IncrDecrG` to pass it to the function.
            public class _InOptConst_IncrDecrG
            {
                public Const_IncrDecrG? Opt;

                public _InOptConst_IncrDecrG() {}
                public _InOptConst_IncrDecrG(Const_IncrDecrG value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrG(Const_IncrDecrG value) {return new(value);}
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// Generated from class `MR::CSharp::IncrDecrH`.
            /// This is the const half of the class.
            public class Const_IncrDecrH : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrH_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrH() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrH::IncrDecrH`.
                public unsafe Const_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_ConstructFromAnother(MR.CS.CSharp.IncrDecrH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrH::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_incr_MR_CSharp_IncrDecrH(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrH __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrH(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrH::operator++`.
                public static unsafe IncrDecrH operator++(MR.CS.CSharp.Const_IncrDecrH _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_incr_MR_CSharp_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH._Underlying *_this);
                    IncrDecrH __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrH __unused_ret = new(__MR_C_incr_MR_CSharp_IncrDecrH(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::IncrDecrH::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_decr_MR_CSharp_IncrDecrH(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrH __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrH(_UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IncrDecrH::operator--`.
                public static unsafe IncrDecrH operator--(MR.CS.CSharp.Const_IncrDecrH _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_decr_MR_CSharp_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH._Underlying *_this);
                    IncrDecrH __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrH __unused_ret = new(__MR_C_decr_MR_CSharp_IncrDecrH(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// Generated from class `MR::CSharp::IncrDecrH`.
            /// This is the non-const half of the class.
            public class IncrDecrH : Const_IncrDecrH
            {
                internal unsafe IncrDecrH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrH::IncrDecrH`.
                public unsafe IncrDecrH(MR.CS.CSharp.Const_IncrDecrH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_ConstructFromAnother(MR.CS.CSharp.IncrDecrH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `IncrDecrH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrH`/`Const_IncrDecrH` directly.
            public class _InOptMut_IncrDecrH
            {
                public IncrDecrH? Opt;

                public _InOptMut_IncrDecrH() {}
                public _InOptMut_IncrDecrH(IncrDecrH value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrH(IncrDecrH value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrH`/`Const_IncrDecrH` to pass it to the function.
            public class _InOptConst_IncrDecrH
            {
                public Const_IncrDecrH? Opt;

                public _InOptConst_IncrDecrH() {}
                public _InOptConst_IncrDecrH(Const_IncrDecrH value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrH(Const_IncrDecrH value) {return new(value);}
            }

            // Friend functions.
            /// Generated from class `MR::CSharp::IncrDecrI`.
            /// This is the const half of the class.
            public class Const_IncrDecrI : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IncrDecrI(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrI_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrI_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrI() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IncrDecrI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                public unsafe Const_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_ConstructFromAnother(MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_incr_MR_CSharp_IncrDecrI(_Underlying *_1);
                    int __unused_ret = __MR_C_incr_MR_CSharp_IncrDecrI(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator++`.
                public static unsafe IncrDecrI operator++(MR.CS.CSharp.Const_IncrDecrI _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_incr_MR_CSharp_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI._Underlying *_1);
                    IncrDecrI __this_copy = new(_1);
                    int __unused_ret = __MR_C_incr_MR_CSharp_IncrDecrI(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                /// Generated from function `MR::CSharp::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_decr_MR_CSharp_IncrDecrI(_Underlying *_1);
                    int __unused_ret = __MR_C_decr_MR_CSharp_IncrDecrI(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public static unsafe IncrDecrI operator--(MR.CS.CSharp.Const_IncrDecrI _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_decr_MR_CSharp_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI._Underlying *_1);
                    IncrDecrI __this_copy = new(_1);
                    int __unused_ret = __MR_C_decr_MR_CSharp_IncrDecrI(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }
            }

            // Friend functions.
            /// Generated from class `MR::CSharp::IncrDecrI`.
            /// This is the non-const half of the class.
            public class IncrDecrI : Const_IncrDecrI
            {
                internal unsafe IncrDecrI(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IncrDecrI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                public unsafe IncrDecrI(MR.CS.CSharp.Const_IncrDecrI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_ConstructFromAnother(MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IncrDecrI::operator=`.
                public unsafe MR.CS.CSharp.IncrDecrI assign(MR.CS.CSharp.Const_IncrDecrI _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    return new(__MR_CSharp_IncrDecrI_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `IncrDecrI` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrI`/`Const_IncrDecrI` directly.
            public class _InOptMut_IncrDecrI
            {
                public IncrDecrI? Opt;

                public _InOptMut_IncrDecrI() {}
                public _InOptMut_IncrDecrI(IncrDecrI value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrI(IncrDecrI value) {return new(value);}
            }

            /// This is used for optional parameters of class `IncrDecrI` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrI`/`Const_IncrDecrI` to pass it to the function.
            public class _InOptConst_IncrDecrI
            {
                public Const_IncrDecrI? Opt;

                public _InOptConst_IncrDecrI() {}
                public _InOptConst_IncrDecrI(Const_IncrDecrI value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrI(Const_IncrDecrI value) {return new(value);}
            }

            // Test equality comparison.
            /// Generated from class `MR::CSharp::EqualityA`.
            /// This is the const half of the class.
            public class Const_EqualityA : MR.CS.Misc.Object, System.IDisposable, System.IEquatable<MR.CS.CSharp.Const_EqualityA>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_EqualityA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityA_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_EqualityA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                public unsafe Const_EqualityA(MR.CS.CSharp.Const_EqualityA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_ConstructFromAnother(MR.CS.CSharp.EqualityA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityA::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Const_EqualityA _this, MR.CS.CSharp.Const_EqualityA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityA", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityA(MR.CS.CSharp.Const_EqualityA._Underlying *_this, MR.CS.CSharp.Const_EqualityA._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityA(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Const_EqualityA _this, MR.CS.CSharp.Const_EqualityA _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.Const_EqualityA? _1)
                {
                    if (_1 is null)
                        return false;
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.Const_EqualityA)
                        return this == (MR.CS.CSharp.Const_EqualityA)other;
                    return false;
                }
            }

            // Test equality comparison.
            /// Generated from class `MR::CSharp::EqualityA`.
            /// This is the non-const half of the class.
            public class EqualityA : Const_EqualityA, System.IEquatable<int>
            {
                internal unsafe EqualityA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe EqualityA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                public unsafe EqualityA(MR.CS.CSharp.Const_EqualityA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_ConstructFromAnother(MR.CS.CSharp.EqualityA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityA::operator=`.
                public unsafe MR.CS.CSharp.EqualityA assign(MR.CS.CSharp.Const_EqualityA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityA._Underlying *_other);
                    return new(__MR_CSharp_EqualityA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::EqualityA::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.EqualityA _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityA_int", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityA_int(MR.CS.CSharp.EqualityA._Underlying *_this, int _1);
                    return __MR_C_equal_MR_CSharp_EqualityA_int(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityA _this, int _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(int _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is int)
                        return this == (int)other;
                    return base.Equals(other);
                }
            }

            /// This is used for optional parameters of class `EqualityA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityA`/`Const_EqualityA` directly.
            public class _InOptMut_EqualityA
            {
                public EqualityA? Opt;

                public _InOptMut_EqualityA() {}
                public _InOptMut_EqualityA(EqualityA value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityA(EqualityA value) {return new(value);}
            }

            /// This is used for optional parameters of class `EqualityA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityA`/`Const_EqualityA` to pass it to the function.
            public class _InOptConst_EqualityA
            {
                public Const_EqualityA? Opt;

                public _InOptConst_EqualityA() {}
                public _InOptConst_EqualityA(Const_EqualityA value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityA(Const_EqualityA value) {return new(value);}
            }

            // Return type isn't `bool`.
            /// Generated from class `MR::CSharp::EqualityB`.
            /// This is the const half of the class.
            public class Const_EqualityB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_EqualityB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityB_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_EqualityB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                public unsafe Const_EqualityB(MR.CS.CSharp.Const_EqualityB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_ConstructFromAnother(MR.CS.CSharp.EqualityB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityB::operator==`.
                public unsafe int equal(MR.CS.CSharp.Const_EqualityB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityB", ExactSpelling = true)]
                    extern static int __MR_C_equal_MR_CSharp_EqualityB(_Underlying *_this, MR.CS.CSharp.Const_EqualityB._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityB(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // Return type isn't `bool`.
            /// Generated from class `MR::CSharp::EqualityB`.
            /// This is the non-const half of the class.
            public class EqualityB : Const_EqualityB
            {
                internal unsafe EqualityB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe EqualityB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                public unsafe EqualityB(MR.CS.CSharp.Const_EqualityB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_ConstructFromAnother(MR.CS.CSharp.EqualityB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityB::operator=`.
                public unsafe MR.CS.CSharp.EqualityB assign(MR.CS.CSharp.Const_EqualityB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityB._Underlying *_other);
                    return new(__MR_CSharp_EqualityB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::EqualityB::operator==`.
                public unsafe int equal(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityB_int", ExactSpelling = true)]
                    extern static int __MR_C_equal_MR_CSharp_EqualityB_int(_Underlying *_this, int _1);
                    return __MR_C_equal_MR_CSharp_EqualityB_int(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::EqualityB::operator!=`.
                public unsafe int notEqual(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_equal_MR_CSharp_EqualityB_int", ExactSpelling = true)]
                    extern static int __MR_C_not_equal_MR_CSharp_EqualityB_int(_Underlying *_this, int _1);
                    return __MR_C_not_equal_MR_CSharp_EqualityB_int(_UnderlyingPtr, _1);
                }
            }

            /// This is used for optional parameters of class `EqualityB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityB`/`Const_EqualityB` directly.
            public class _InOptMut_EqualityB
            {
                public EqualityB? Opt;

                public _InOptMut_EqualityB() {}
                public _InOptMut_EqualityB(EqualityB value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityB(EqualityB value) {return new(value);}
            }

            /// This is used for optional parameters of class `EqualityB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityB`/`Const_EqualityB` to pass it to the function.
            public class _InOptConst_EqualityB
            {
                public Const_EqualityB? Opt;

                public _InOptConst_EqualityB() {}
                public _InOptConst_EqualityB(Const_EqualityB value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityB(Const_EqualityB value) {return new(value);}
            }

            // Return type is `void`.
            /// Generated from class `MR::CSharp::EqualityC`.
            /// This is the const half of the class.
            public class Const_EqualityC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_EqualityC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityC_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_EqualityC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                public unsafe Const_EqualityC(MR.CS.CSharp.Const_EqualityC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_ConstructFromAnother(MR.CS.CSharp.EqualityC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityC::operator==`.
                public unsafe void equal(MR.CS.CSharp.Const_EqualityC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityC", ExactSpelling = true)]
                    extern static void __MR_C_equal_MR_CSharp_EqualityC(_Underlying *_this, MR.CS.CSharp.Const_EqualityC._Underlying *_1);
                    __MR_C_equal_MR_CSharp_EqualityC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // Return type is `void`.
            /// Generated from class `MR::CSharp::EqualityC`.
            /// This is the non-const half of the class.
            public class EqualityC : Const_EqualityC
            {
                internal unsafe EqualityC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe EqualityC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                public unsafe EqualityC(MR.CS.CSharp.Const_EqualityC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_ConstructFromAnother(MR.CS.CSharp.EqualityC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityC::operator=`.
                public unsafe MR.CS.CSharp.EqualityC assign(MR.CS.CSharp.Const_EqualityC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityC._Underlying *_other);
                    return new(__MR_CSharp_EqualityC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::EqualityC::operator==`.
                public unsafe void equal(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityC_int", ExactSpelling = true)]
                    extern static void __MR_C_equal_MR_CSharp_EqualityC_int(_Underlying *_this, int _1);
                    __MR_C_equal_MR_CSharp_EqualityC_int(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::EqualityC::operator!=`.
                public unsafe void notEqual(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_equal_MR_CSharp_EqualityC_int", ExactSpelling = true)]
                    extern static void __MR_C_not_equal_MR_CSharp_EqualityC_int(_Underlying *_this, int _1);
                    __MR_C_not_equal_MR_CSharp_EqualityC_int(_UnderlyingPtr, _1);
                }
            }

            /// This is used for optional parameters of class `EqualityC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityC`/`Const_EqualityC` directly.
            public class _InOptMut_EqualityC
            {
                public EqualityC? Opt;

                public _InOptMut_EqualityC() {}
                public _InOptMut_EqualityC(EqualityC value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityC(EqualityC value) {return new(value);}
            }

            /// This is used for optional parameters of class `EqualityC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityC`/`Const_EqualityC` to pass it to the function.
            public class _InOptConst_EqualityC
            {
                public Const_EqualityC? Opt;

                public _InOptConst_EqualityC() {}
                public _InOptConst_EqualityC(Const_EqualityC value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityC(Const_EqualityC value) {return new(value);}
            }

            // The C# parameter type ends with `?`, and isn't a managed type.
            /// Generated from class `MR::CSharp::EqualityD`.
            /// This is the const half of the class.
            public class Const_EqualityD : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_EqualityD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityD_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_EqualityD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                public unsafe Const_EqualityD(MR.CS.CSharp.Const_EqualityD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_ConstructFromAnother(MR.CS.CSharp.EqualityD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityD_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The C# parameter type ends with `?`, and isn't a managed type.
            /// Generated from class `MR::CSharp::EqualityD`.
            /// This is the non-const half of the class.
            public class EqualityD : Const_EqualityD, System.IEquatable<int?>
            {
                internal unsafe EqualityD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe EqualityD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                public unsafe EqualityD(MR.CS.CSharp.Const_EqualityD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_ConstructFromAnother(MR.CS.CSharp.EqualityD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityD::operator=`.
                public unsafe MR.CS.CSharp.EqualityD assign(MR.CS.CSharp.Const_EqualityD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityD._Underlying *_other);
                    return new(__MR_CSharp_EqualityD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::EqualityD::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.EqualityD _this, int? _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityD_const_int_ptr", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityD_const_int_ptr(MR.CS.CSharp.EqualityD._Underlying *_this, int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    return __MR_C_equal_MR_CSharp_EqualityD_const_int_ptr(_this._UnderlyingPtr, _1.HasValue ? &__deref__1 : null) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityD _this, int? _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(int? _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is int)
                        return this == (int)other;
                    return false;
                }
            }

            /// This is used for optional parameters of class `EqualityD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityD`/`Const_EqualityD` directly.
            public class _InOptMut_EqualityD
            {
                public EqualityD? Opt;

                public _InOptMut_EqualityD() {}
                public _InOptMut_EqualityD(EqualityD value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityD(EqualityD value) {return new(value);}
            }

            /// This is used for optional parameters of class `EqualityD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityD`/`Const_EqualityD` to pass it to the function.
            public class _InOptConst_EqualityD
            {
                public Const_EqualityD? Opt;

                public _InOptConst_EqualityD() {}
                public _InOptConst_EqualityD(Const_EqualityD value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityD(Const_EqualityD value) {return new(value);}
            }

            // The C# parameter type ends with `?`, and is a managed type.
            /// Generated from class `MR::CSharp::EqualityE`.
            /// This is the const half of the class.
            public class Const_EqualityE : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_EqualityE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityE_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_EqualityE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                public unsafe Const_EqualityE(MR.CS.CSharp.Const_EqualityE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_ConstructFromAnother(MR.CS.CSharp.EqualityE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityE_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The C# parameter type ends with `?`, and is a managed type.
            /// Generated from class `MR::CSharp::EqualityE`.
            /// This is the non-const half of the class.
            public class EqualityE : Const_EqualityE, System.IEquatable<MR.CS.CSharp.EqualityD?>
            {
                internal unsafe EqualityE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe EqualityE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                public unsafe EqualityE(MR.CS.CSharp.Const_EqualityE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_ConstructFromAnother(MR.CS.CSharp.EqualityE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityE_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::EqualityE::operator=`.
                public unsafe MR.CS.CSharp.EqualityE assign(MR.CS.CSharp.Const_EqualityE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityE._Underlying *_other);
                    return new(__MR_CSharp_EqualityE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::EqualityE::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.EqualityE _this, MR.CS.CSharp.EqualityD? _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr(MR.CS.CSharp.EqualityE._Underlying *_this, MR.CS.CSharp.EqualityD._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr(_this._UnderlyingPtr, _1 is not null ? _1._UnderlyingPtr : null) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityE _this, MR.CS.CSharp.EqualityD? _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.EqualityD? _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.EqualityD)
                        return this == (MR.CS.CSharp.EqualityD)other;
                    return false;
                }
            }

            /// This is used for optional parameters of class `EqualityE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityE`/`Const_EqualityE` directly.
            public class _InOptMut_EqualityE
            {
                public EqualityE? Opt;

                public _InOptMut_EqualityE() {}
                public _InOptMut_EqualityE(EqualityE value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityE(EqualityE value) {return new(value);}
            }

            /// This is used for optional parameters of class `EqualityE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityE`/`Const_EqualityE` to pass it to the function.
            public class _InOptConst_EqualityE
            {
                public Const_EqualityE? Opt;

                public _InOptConst_EqualityE() {}
                public _InOptConst_EqualityE(Const_EqualityE value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityE(Const_EqualityE value) {return new(value);}
            }

            // The happy path, the operator is const.
            /// Generated from class `MR::CSharp::RelationalA`.
            /// This is the const half of the class.
            public class Const_RelationalA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalA_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                public unsafe Const_RelationalA(MR.CS.CSharp.Const_RelationalA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_ConstructFromAnother(MR.CS.CSharp.RelationalA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalA::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalA", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalA(MR.CS.CSharp.Const_RelationalA._Underlying *_this, MR.CS.CSharp.Const_RelationalA._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalA(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return !(_this < _1);
                }
            }

            // The happy path, the operator is const.
            /// Generated from class `MR::CSharp::RelationalA`.
            /// This is the non-const half of the class.
            public class RelationalA : Const_RelationalA
            {
                internal unsafe RelationalA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                public unsafe RelationalA(MR.CS.CSharp.Const_RelationalA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_ConstructFromAnother(MR.CS.CSharp.RelationalA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalA::operator=`.
                public unsafe MR.CS.CSharp.RelationalA assign(MR.CS.CSharp.Const_RelationalA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalA._Underlying *_other);
                    return new(__MR_CSharp_RelationalA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `RelationalA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalA`/`Const_RelationalA` directly.
            public class _InOptMut_RelationalA
            {
                public RelationalA? Opt;

                public _InOptMut_RelationalA() {}
                public _InOptMut_RelationalA(RelationalA value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalA(RelationalA value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalA`/`Const_RelationalA` to pass it to the function.
            public class _InOptConst_RelationalA
            {
                public Const_RelationalA? Opt;

                public _InOptConst_RelationalA() {}
                public _InOptConst_RelationalA(Const_RelationalA value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalA(Const_RelationalA value) {return new(value);}
            }

            // The happy path, the operator is non-const.
            /// Generated from class `MR::CSharp::RelationalB`.
            /// This is the const half of the class.
            public class Const_RelationalB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalB_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                public unsafe Const_RelationalB(MR.CS.CSharp.Const_RelationalB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_ConstructFromAnother(MR.CS.CSharp.RelationalB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalB_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The happy path, the operator is non-const.
            /// Generated from class `MR::CSharp::RelationalB`.
            /// This is the non-const half of the class.
            public class RelationalB : Const_RelationalB
            {
                internal unsafe RelationalB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                public unsafe RelationalB(MR.CS.CSharp.Const_RelationalB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_ConstructFromAnother(MR.CS.CSharp.RelationalB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalB::operator=`.
                public unsafe MR.CS.CSharp.RelationalB assign(MR.CS.CSharp.Const_RelationalB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalB._Underlying *_other);
                    return new(__MR_CSharp_RelationalB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::RelationalB::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalB", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalB(MR.CS.CSharp.RelationalB._Underlying *_this, MR.CS.CSharp.RelationalB._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalB(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return !(_this < _1);
                }
            }

            /// This is used for optional parameters of class `RelationalB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalB`/`Const_RelationalB` directly.
            public class _InOptMut_RelationalB
            {
                public RelationalB? Opt;

                public _InOptMut_RelationalB() {}
                public _InOptMut_RelationalB(RelationalB value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalB(RelationalB value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalB`/`Const_RelationalB` to pass it to the function.
            public class _InOptConst_RelationalB
            {
                public Const_RelationalB? Opt;

                public _InOptConst_RelationalB() {}
                public _InOptConst_RelationalB(Const_RelationalB value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalB(Const_RelationalB value) {return new(value);}
            }

            // The operators have mixed constness, which causes them to be demoted to functions.
            /// Generated from class `MR::CSharp::RelationalC`.
            /// This is the const half of the class.
            public class Const_RelationalC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalC_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                public unsafe Const_RelationalC(MR.CS.CSharp.Const_RelationalC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_ConstructFromAnother(MR.CS.CSharp.RelationalC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalC::operator<`.
                public unsafe bool less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// Generated from method `MR::CSharp::RelationalC::operator>`.
                public unsafe bool greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                // bool operator<=(RelationalC &) const {return false;} // Skip one operator to observe the function missing.
                /// Generated from method `MR::CSharp::RelationalC::operator>=`.
                public unsafe bool greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_equal_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }
            }

            // The operators have mixed constness, which causes them to be demoted to functions.
            /// Generated from class `MR::CSharp::RelationalC`.
            /// This is the non-const half of the class.
            public class RelationalC : Const_RelationalC
            {
                internal unsafe RelationalC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                public unsafe RelationalC(MR.CS.CSharp.Const_RelationalC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_ConstructFromAnother(MR.CS.CSharp.RelationalC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalC::operator=`.
                public unsafe MR.CS.CSharp.RelationalC assign(MR.CS.CSharp.Const_RelationalC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_other);
                    return new(__MR_CSharp_RelationalC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `RelationalC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalC`/`Const_RelationalC` directly.
            public class _InOptMut_RelationalC
            {
                public RelationalC? Opt;

                public _InOptMut_RelationalC() {}
                public _InOptMut_RelationalC(RelationalC value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalC(RelationalC value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalC`/`Const_RelationalC` to pass it to the function.
            public class _InOptConst_RelationalC
            {
                public Const_RelationalC? Opt;

                public _InOptConst_RelationalC() {}
                public _InOptConst_RelationalC(Const_RelationalC value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalC(Const_RelationalC value) {return new(value);}
            }

            // The operators have operands of different types, causing them to be demoted to functions.
            /// Generated from class `MR::CSharp::RelationalD`.
            /// This is the const half of the class.
            public class Const_RelationalD : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalD_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                public unsafe Const_RelationalD(MR.CS.CSharp.Const_RelationalD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_ConstructFromAnother(MR.CS.CSharp.RelationalD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalD::operator<`.
                public unsafe bool less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// Generated from method `MR::CSharp::RelationalD::operator>`.
                public unsafe bool greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// Generated from method `MR::CSharp::RelationalD::operator<=`.
                public unsafe bool lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// Generated from method `MR::CSharp::RelationalD::operator>=`.
                public unsafe bool greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }
            }

            // The operators have operands of different types, causing them to be demoted to functions.
            /// Generated from class `MR::CSharp::RelationalD`.
            /// This is the non-const half of the class.
            public class RelationalD : Const_RelationalD
            {
                internal unsafe RelationalD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                public unsafe RelationalD(MR.CS.CSharp.Const_RelationalD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_ConstructFromAnother(MR.CS.CSharp.RelationalD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalD::operator=`.
                public unsafe MR.CS.CSharp.RelationalD assign(MR.CS.CSharp.Const_RelationalD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalD._Underlying *_other);
                    return new(__MR_CSharp_RelationalD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `RelationalD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalD`/`Const_RelationalD` directly.
            public class _InOptMut_RelationalD
            {
                public RelationalD? Opt;

                public _InOptMut_RelationalD() {}
                public _InOptMut_RelationalD(RelationalD value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalD(RelationalD value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalD`/`Const_RelationalD` to pass it to the function.
            public class _InOptConst_RelationalD
            {
                public Const_RelationalD? Opt;

                public _InOptConst_RelationalD() {}
                public _InOptConst_RelationalD(Const_RelationalD value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalD(Const_RelationalD value) {return new(value);}
            }

            // The operators have a weird return type.
            /// Generated from class `MR::CSharp::RelationalE`.
            /// This is the const half of the class.
            public class Const_RelationalE : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalE_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                public unsafe Const_RelationalE(MR.CS.CSharp.Const_RelationalE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_ConstructFromAnother(MR.CS.CSharp.RelationalE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalE_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalE::operator<`.
                public unsafe int less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalE::operator>`.
                public unsafe int greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalE::operator<=`.
                public unsafe int lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalE::operator>=`.
                public unsafe int greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // The operators have a weird return type.
            /// Generated from class `MR::CSharp::RelationalE`.
            /// This is the non-const half of the class.
            public class RelationalE : Const_RelationalE
            {
                internal unsafe RelationalE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                public unsafe RelationalE(MR.CS.CSharp.Const_RelationalE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_ConstructFromAnother(MR.CS.CSharp.RelationalE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalE_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalE::operator=`.
                public unsafe MR.CS.CSharp.RelationalE assign(MR.CS.CSharp.Const_RelationalE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalE._Underlying *_other);
                    return new(__MR_CSharp_RelationalE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `RelationalE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalE`/`Const_RelationalE` directly.
            public class _InOptMut_RelationalE
            {
                public RelationalE? Opt;

                public _InOptMut_RelationalE() {}
                public _InOptMut_RelationalE(RelationalE value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalE(RelationalE value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalE`/`Const_RelationalE` to pass it to the function.
            public class _InOptConst_RelationalE
            {
                public Const_RelationalE? Opt;

                public _InOptConst_RelationalE() {}
                public _InOptConst_RelationalE(Const_RelationalE value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalE(Const_RelationalE value) {return new(value);}
            }

            // The operators return void.
            /// Generated from class `MR::CSharp::RelationalF`.
            /// This is the const half of the class.
            public class Const_RelationalF : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_RelationalF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalF_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalF() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_RelationalF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                public unsafe Const_RelationalF(MR.CS.CSharp.Const_RelationalF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_ConstructFromAnother(MR.CS.CSharp.RelationalF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalF::operator<`.
                public unsafe void less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalF::operator>`.
                public unsafe void greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalF::operator<=`.
                public unsafe void lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalF::operator>=`.
                public unsafe void greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // The operators return void.
            /// Generated from class `MR::CSharp::RelationalF`.
            /// This is the non-const half of the class.
            public class RelationalF : Const_RelationalF
            {
                internal unsafe RelationalF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe RelationalF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                public unsafe RelationalF(MR.CS.CSharp.Const_RelationalF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_ConstructFromAnother(MR.CS.CSharp.RelationalF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::RelationalF::operator=`.
                public unsafe MR.CS.CSharp.RelationalF assign(MR.CS.CSharp.Const_RelationalF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalF._Underlying *_other);
                    return new(__MR_CSharp_RelationalF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `RelationalF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalF`/`Const_RelationalF` directly.
            public class _InOptMut_RelationalF
            {
                public RelationalF? Opt;

                public _InOptMut_RelationalF() {}
                public _InOptMut_RelationalF(RelationalF value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalF(RelationalF value) {return new(value);}
            }

            /// This is used for optional parameters of class `RelationalF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalF`/`Const_RelationalF` to pass it to the function.
            public class _InOptConst_RelationalF
            {
                public Const_RelationalF? Opt;

                public _InOptConst_RelationalF() {}
                public _InOptConst_RelationalF(Const_RelationalF value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalF(Const_RelationalF value) {return new(value);}
            }

            // The operator is injected correctly.
            /// Generated from class `MR::CSharp::StaticOpsLhsA`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsA_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                public unsafe Const_StaticOpsLhsA(MR.CS.CSharp.Const_StaticOpsLhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(Const_StaticOpsLhsA _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsA_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsA_int(MR.CS.CSharp.StaticOpsLhsA._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsA_int(_1._UnderlyingPtr, _2);
                }
            }

            // The operator is injected correctly.
            /// Generated from class `MR::CSharp::StaticOpsLhsA`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsA : Const_StaticOpsLhsA
            {
                internal unsafe StaticOpsLhsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                public unsafe StaticOpsLhsA(MR.CS.CSharp.Const_StaticOpsLhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsA::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsA assign(MR.CS.CSharp.Const_StaticOpsLhsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsA`/`Const_StaticOpsLhsA` directly.
            public class _InOptMut_StaticOpsLhsA
            {
                public StaticOpsLhsA? Opt;

                public _InOptMut_StaticOpsLhsA() {}
                public _InOptMut_StaticOpsLhsA(StaticOpsLhsA value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsA(StaticOpsLhsA value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsA`/`Const_StaticOpsLhsA` to pass it to the function.
            public class _InOptConst_StaticOpsLhsA
            {
                public Const_StaticOpsLhsA? Opt;

                public _InOptConst_StaticOpsLhsA() {}
                public _InOptConst_StaticOpsLhsA(Const_StaticOpsLhsA value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsA(Const_StaticOpsLhsA value) {return new(value);}
            }

            // The operator injects but becomes a function, because it returns void.
            /// Generated from class `MR::CSharp::StaticOpsLhsB`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsB_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                public unsafe Const_StaticOpsLhsB(MR.CS.CSharp.Const_StaticOpsLhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public unsafe void add(int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsB_int", ExactSpelling = true)]
                    extern static void __MR_C_add_MR_CSharp_StaticOpsLhsB_int(_Underlying *_1, int _2);
                    __MR_C_add_MR_CSharp_StaticOpsLhsB_int(_UnderlyingPtr, _2);
                }
            }

            // The operator injects but becomes a function, because it returns void.
            /// Generated from class `MR::CSharp::StaticOpsLhsB`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsB : Const_StaticOpsLhsB
            {
                internal unsafe StaticOpsLhsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                public unsafe StaticOpsLhsB(MR.CS.CSharp.Const_StaticOpsLhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsB::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsB assign(MR.CS.CSharp.Const_StaticOpsLhsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsB`/`Const_StaticOpsLhsB` directly.
            public class _InOptMut_StaticOpsLhsB
            {
                public StaticOpsLhsB? Opt;

                public _InOptMut_StaticOpsLhsB() {}
                public _InOptMut_StaticOpsLhsB(StaticOpsLhsB value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsB(StaticOpsLhsB value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsB`/`Const_StaticOpsLhsB` to pass it to the function.
            public class _InOptConst_StaticOpsLhsB
            {
                public Const_StaticOpsLhsB? Opt;

                public _InOptConst_StaticOpsLhsB() {}
                public _InOptConst_StaticOpsLhsB(Const_StaticOpsLhsB value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsB(Const_StaticOpsLhsB value) {return new(value);}
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// Generated from class `MR::CSharp::StaticOpsLhsC`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsC_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsC::StaticOpsLhsC`.
                public unsafe Const_StaticOpsLhsC(MR.CS.CSharp._ByValue_StaticOpsLhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// Generated from class `MR::CSharp::StaticOpsLhsC`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsC : Const_StaticOpsLhsC
            {
                internal unsafe StaticOpsLhsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsC::StaticOpsLhsC`.
                public unsafe StaticOpsLhsC(MR.CS.CSharp._ByValue_StaticOpsLhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// This is used as a function parameter when the underlying function receives `StaticOpsLhsC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_StaticOpsLhsC
            {
                internal readonly Const_StaticOpsLhsC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_StaticOpsLhsC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_StaticOpsLhsC(MR.CS.Misc._Moved<StaticOpsLhsC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_StaticOpsLhsC(MR.CS.Misc._Moved<StaticOpsLhsC> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsC`/`Const_StaticOpsLhsC` directly.
            public class _InOptMut_StaticOpsLhsC
            {
                public StaticOpsLhsC? Opt;

                public _InOptMut_StaticOpsLhsC() {}
                public _InOptMut_StaticOpsLhsC(StaticOpsLhsC value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsC(StaticOpsLhsC value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsC`/`Const_StaticOpsLhsC` to pass it to the function.
            public class _InOptConst_StaticOpsLhsC
            {
                public Const_StaticOpsLhsC? Opt;

                public _InOptConst_StaticOpsLhsC() {}
                public _InOptConst_StaticOpsLhsC(Const_StaticOpsLhsC value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsC(Const_StaticOpsLhsC value) {return new(value);}
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsD`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsD : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsD_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsD::StaticOpsLhsD`.
                public unsafe Const_StaticOpsLhsD(MR.CS.CSharp.Const_StaticOpsLhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(Const_StaticOpsLhsD _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsD_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsD_int(MR.CS.CSharp.StaticOpsLhsD._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsD_int(_1._UnderlyingPtr, _2);
                }
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsD`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsD : Const_StaticOpsLhsD
            {
                internal unsafe StaticOpsLhsD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsD::StaticOpsLhsD`.
                public unsafe StaticOpsLhsD(MR.CS.CSharp.Const_StaticOpsLhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsD`/`Const_StaticOpsLhsD` directly.
            public class _InOptMut_StaticOpsLhsD
            {
                public StaticOpsLhsD? Opt;

                public _InOptMut_StaticOpsLhsD() {}
                public _InOptMut_StaticOpsLhsD(StaticOpsLhsD value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsD(StaticOpsLhsD value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsD`/`Const_StaticOpsLhsD` to pass it to the function.
            public class _InOptConst_StaticOpsLhsD
            {
                public Const_StaticOpsLhsD? Opt;

                public _InOptConst_StaticOpsLhsD() {}
                public _InOptConst_StaticOpsLhsD(Const_StaticOpsLhsD value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsD(Const_StaticOpsLhsD value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsE`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsE : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsE_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsE::StaticOpsLhsE`.
                public unsafe Const_StaticOpsLhsE(MR.CS.CSharp.Const_StaticOpsLhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsE`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsE : Const_StaticOpsLhsE
            {
                internal unsafe StaticOpsLhsE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsE::StaticOpsLhsE`.
                public unsafe StaticOpsLhsE(MR.CS.CSharp.Const_StaticOpsLhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsE::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsE assign(MR.CS.CSharp.Const_StaticOpsLhsE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.StaticOpsLhsE _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsE_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsE_int(MR.CS.CSharp.StaticOpsLhsE._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsE_int(_1._UnderlyingPtr, _2);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsE`/`Const_StaticOpsLhsE` directly.
            public class _InOptMut_StaticOpsLhsE
            {
                public StaticOpsLhsE? Opt;

                public _InOptMut_StaticOpsLhsE() {}
                public _InOptMut_StaticOpsLhsE(StaticOpsLhsE value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsE(StaticOpsLhsE value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsE`/`Const_StaticOpsLhsE` to pass it to the function.
            public class _InOptConst_StaticOpsLhsE
            {
                public Const_StaticOpsLhsE? Opt;

                public _InOptConst_StaticOpsLhsE() {}
                public _InOptConst_StaticOpsLhsE(Const_StaticOpsLhsE value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsE(Const_StaticOpsLhsE value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsF`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsF : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsF_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsF() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsF::StaticOpsLhsF`.
                public unsafe Const_StaticOpsLhsF(MR.CS.CSharp.Const_StaticOpsLhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Const_StaticOpsLhsF _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsF_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsF_int(MR.CS.CSharp.Const_StaticOpsLhsF._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsF_int(_1._UnderlyingPtr, _2);
                }
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsLhsF`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsF : Const_StaticOpsLhsF
            {
                internal unsafe StaticOpsLhsF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsF::StaticOpsLhsF`.
                public unsafe StaticOpsLhsF(MR.CS.CSharp.Const_StaticOpsLhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsF::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsF assign(MR.CS.CSharp.Const_StaticOpsLhsF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsF`/`Const_StaticOpsLhsF` directly.
            public class _InOptMut_StaticOpsLhsF
            {
                public StaticOpsLhsF? Opt;

                public _InOptMut_StaticOpsLhsF() {}
                public _InOptMut_StaticOpsLhsF(StaticOpsLhsF value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsF(StaticOpsLhsF value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsF`/`Const_StaticOpsLhsF` to pass it to the function.
            public class _InOptConst_StaticOpsLhsF
            {
                public Const_StaticOpsLhsF? Opt;

                public _InOptConst_StaticOpsLhsF() {}
                public _InOptConst_StaticOpsLhsF(Const_StaticOpsLhsF value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsF(Const_StaticOpsLhsF value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// Generated from class `MR::CSharp::StaticOpsLhsG`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsG : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsG_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsG() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsG::StaticOpsLhsG`.
                public unsafe Const_StaticOpsLhsG(MR.CS.CSharp.Const_StaticOpsLhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// Generated from class `MR::CSharp::StaticOpsLhsG`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsG : Const_StaticOpsLhsG
            {
                internal unsafe StaticOpsLhsG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsG::StaticOpsLhsG`.
                public unsafe StaticOpsLhsG(MR.CS.CSharp.Const_StaticOpsLhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsG::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsG assign(MR.CS.CSharp.Const_StaticOpsLhsG _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsG_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(StaticOpsLhsG _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsG_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsG_int(MR.CS.CSharp.StaticOpsLhsG._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsG_int(_1._UnderlyingPtr, _2);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsG`/`Const_StaticOpsLhsG` directly.
            public class _InOptMut_StaticOpsLhsG
            {
                public StaticOpsLhsG? Opt;

                public _InOptMut_StaticOpsLhsG() {}
                public _InOptMut_StaticOpsLhsG(StaticOpsLhsG value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsG(StaticOpsLhsG value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsG`/`Const_StaticOpsLhsG` to pass it to the function.
            public class _InOptConst_StaticOpsLhsG
            {
                public Const_StaticOpsLhsG? Opt;

                public _InOptConst_StaticOpsLhsG() {}
                public _InOptConst_StaticOpsLhsG(Const_StaticOpsLhsG value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsG(Const_StaticOpsLhsG value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// Generated from class `MR::CSharp::StaticOpsLhsH`.
            /// This is the const half of the class.
            public class Const_StaticOpsLhsH : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsLhsH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsH_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsH() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsLhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsH::StaticOpsLhsH`.
                public unsafe Const_StaticOpsLhsH(MR.CS.CSharp.Const_StaticOpsLhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Const_StaticOpsLhsH _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsH_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsH_int(MR.CS.CSharp.Const_StaticOpsLhsH._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsH_int(_1._UnderlyingPtr, _2);
                }
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// Generated from class `MR::CSharp::StaticOpsLhsH`.
            /// This is the non-const half of the class.
            public class StaticOpsLhsH : Const_StaticOpsLhsH
            {
                internal unsafe StaticOpsLhsH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsLhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsLhsH::StaticOpsLhsH`.
                public unsafe StaticOpsLhsH(MR.CS.CSharp.Const_StaticOpsLhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsLhsH::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsLhsH assign(MR.CS.CSharp.Const_StaticOpsLhsH _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsLhsH_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsLhsH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsH`/`Const_StaticOpsLhsH` directly.
            public class _InOptMut_StaticOpsLhsH
            {
                public StaticOpsLhsH? Opt;

                public _InOptMut_StaticOpsLhsH() {}
                public _InOptMut_StaticOpsLhsH(StaticOpsLhsH value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsH(StaticOpsLhsH value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsLhsH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsH`/`Const_StaticOpsLhsH` to pass it to the function.
            public class _InOptConst_StaticOpsLhsH
            {
                public Const_StaticOpsLhsH? Opt;

                public _InOptConst_StaticOpsLhsH() {}
                public _InOptConst_StaticOpsLhsH(Const_StaticOpsLhsH value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsH(Const_StaticOpsLhsH value) {return new(value);}
            }

            // The operator is injected correctly.
            /// Generated from class `MR::CSharp::StaticOpsRhsA`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsA_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsA() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                public unsafe Const_StaticOpsRhsA(MR.CS.CSharp.Const_StaticOpsRhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, Const_StaticOpsRhsA _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsA", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsA(int _1, MR.CS.CSharp.StaticOpsRhsA._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsA(_1, _2._UnderlyingPtr);
                }
            }

            // The operator is injected correctly.
            /// Generated from class `MR::CSharp::StaticOpsRhsA`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsA : Const_StaticOpsRhsA
            {
                internal unsafe StaticOpsRhsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                public unsafe StaticOpsRhsA(MR.CS.CSharp.Const_StaticOpsRhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsA::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsA assign(MR.CS.CSharp.Const_StaticOpsRhsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsA`/`Const_StaticOpsRhsA` directly.
            public class _InOptMut_StaticOpsRhsA
            {
                public StaticOpsRhsA? Opt;

                public _InOptMut_StaticOpsRhsA() {}
                public _InOptMut_StaticOpsRhsA(StaticOpsRhsA value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsA(StaticOpsRhsA value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsA`/`Const_StaticOpsRhsA` to pass it to the function.
            public class _InOptConst_StaticOpsRhsA
            {
                public Const_StaticOpsRhsA? Opt;

                public _InOptConst_StaticOpsRhsA() {}
                public _InOptConst_StaticOpsRhsA(Const_StaticOpsRhsA value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsA(Const_StaticOpsRhsA value) {return new(value);}
            }

            // The operator injects but becomes a function, because it returns void.
            /// Generated from class `MR::CSharp::StaticOpsRhsB`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsB_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsB() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                public unsafe Const_StaticOpsRhsB(MR.CS.CSharp.Const_StaticOpsRhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe void add(int _1, MR.CS.CSharp.Const_StaticOpsRhsB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsB", ExactSpelling = true)]
                    extern static void __MR_C_add_int_MR_CSharp_StaticOpsRhsB(int _1, MR.CS.CSharp.StaticOpsRhsB._Underlying *_2);
                    __MR_C_add_int_MR_CSharp_StaticOpsRhsB(_1, _2._UnderlyingPtr);
                }
            }

            // The operator injects but becomes a function, because it returns void.
            /// Generated from class `MR::CSharp::StaticOpsRhsB`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsB : Const_StaticOpsRhsB
            {
                internal unsafe StaticOpsRhsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                public unsafe StaticOpsRhsB(MR.CS.CSharp.Const_StaticOpsRhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsB::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsB assign(MR.CS.CSharp.Const_StaticOpsRhsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsB`/`Const_StaticOpsRhsB` directly.
            public class _InOptMut_StaticOpsRhsB
            {
                public StaticOpsRhsB? Opt;

                public _InOptMut_StaticOpsRhsB() {}
                public _InOptMut_StaticOpsRhsB(StaticOpsRhsB value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsB(StaticOpsRhsB value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsB`/`Const_StaticOpsRhsB` to pass it to the function.
            public class _InOptConst_StaticOpsRhsB
            {
                public Const_StaticOpsRhsB? Opt;

                public _InOptConst_StaticOpsRhsB() {}
                public _InOptConst_StaticOpsRhsB(Const_StaticOpsRhsB value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsB(Const_StaticOpsRhsB value) {return new(value);}
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// Generated from class `MR::CSharp::StaticOpsRhsC`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsC_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsC::StaticOpsRhsC`.
                public unsafe Const_StaticOpsRhsC(MR.CS.CSharp._ByValue_StaticOpsRhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// Generated from class `MR::CSharp::StaticOpsRhsC`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsC : Const_StaticOpsRhsC
            {
                internal unsafe StaticOpsRhsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsC::StaticOpsRhsC`.
                public unsafe StaticOpsRhsC(MR.CS.CSharp._ByValue_StaticOpsRhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// This is used as a function parameter when the underlying function receives `StaticOpsRhsC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_StaticOpsRhsC
            {
                internal readonly Const_StaticOpsRhsC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_StaticOpsRhsC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_StaticOpsRhsC(MR.CS.Misc._Moved<StaticOpsRhsC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_StaticOpsRhsC(MR.CS.Misc._Moved<StaticOpsRhsC> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsC`/`Const_StaticOpsRhsC` directly.
            public class _InOptMut_StaticOpsRhsC
            {
                public StaticOpsRhsC? Opt;

                public _InOptMut_StaticOpsRhsC() {}
                public _InOptMut_StaticOpsRhsC(StaticOpsRhsC value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsC(StaticOpsRhsC value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsC`/`Const_StaticOpsRhsC` to pass it to the function.
            public class _InOptConst_StaticOpsRhsC
            {
                public Const_StaticOpsRhsC? Opt;

                public _InOptConst_StaticOpsRhsC() {}
                public _InOptConst_StaticOpsRhsC(Const_StaticOpsRhsC value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsC(Const_StaticOpsRhsC value) {return new(value);}
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsD`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsD : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsD_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsD() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsD::StaticOpsRhsD`.
                public unsafe Const_StaticOpsRhsD(MR.CS.CSharp.Const_StaticOpsRhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, Const_StaticOpsRhsD _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsD", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsD(int _1, MR.CS.CSharp.StaticOpsRhsD._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsD(_1, _2._UnderlyingPtr);
                }
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsD`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsD : Const_StaticOpsRhsD
            {
                internal unsafe StaticOpsRhsD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsD::StaticOpsRhsD`.
                public unsafe StaticOpsRhsD(MR.CS.CSharp.Const_StaticOpsRhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsD`/`Const_StaticOpsRhsD` directly.
            public class _InOptMut_StaticOpsRhsD
            {
                public StaticOpsRhsD? Opt;

                public _InOptMut_StaticOpsRhsD() {}
                public _InOptMut_StaticOpsRhsD(StaticOpsRhsD value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsD(StaticOpsRhsD value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsD`/`Const_StaticOpsRhsD` to pass it to the function.
            public class _InOptConst_StaticOpsRhsD
            {
                public Const_StaticOpsRhsD? Opt;

                public _InOptConst_StaticOpsRhsD() {}
                public _InOptConst_StaticOpsRhsD(Const_StaticOpsRhsD value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsD(Const_StaticOpsRhsD value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsE`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsE : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsE_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsE() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsE::StaticOpsRhsE`.
                public unsafe Const_StaticOpsRhsE(MR.CS.CSharp.Const_StaticOpsRhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsE`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsE : Const_StaticOpsRhsE
            {
                internal unsafe StaticOpsRhsE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsE::StaticOpsRhsE`.
                public unsafe StaticOpsRhsE(MR.CS.CSharp.Const_StaticOpsRhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsE::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsE assign(MR.CS.CSharp.Const_StaticOpsRhsE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, MR.CS.CSharp.StaticOpsRhsE _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsE", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsE(int _1, MR.CS.CSharp.StaticOpsRhsE._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsE(_1, _2._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsE`/`Const_StaticOpsRhsE` directly.
            public class _InOptMut_StaticOpsRhsE
            {
                public StaticOpsRhsE? Opt;

                public _InOptMut_StaticOpsRhsE() {}
                public _InOptMut_StaticOpsRhsE(StaticOpsRhsE value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsE(StaticOpsRhsE value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsE`/`Const_StaticOpsRhsE` to pass it to the function.
            public class _InOptConst_StaticOpsRhsE
            {
                public Const_StaticOpsRhsE? Opt;

                public _InOptConst_StaticOpsRhsE() {}
                public _InOptConst_StaticOpsRhsE(Const_StaticOpsRhsE value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsE(Const_StaticOpsRhsE value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsF`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsF : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsF_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsF() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsF::StaticOpsRhsF`.
                public unsafe Const_StaticOpsRhsF(MR.CS.CSharp.Const_StaticOpsRhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, MR.CS.CSharp.Const_StaticOpsRhsF _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsF", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsF(int _1, MR.CS.CSharp.Const_StaticOpsRhsF._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsF(_1, _2._UnderlyingPtr);
                }
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// Generated from class `MR::CSharp::StaticOpsRhsF`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsF : Const_StaticOpsRhsF
            {
                internal unsafe StaticOpsRhsF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsF::StaticOpsRhsF`.
                public unsafe StaticOpsRhsF(MR.CS.CSharp.Const_StaticOpsRhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsF::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsF assign(MR.CS.CSharp.Const_StaticOpsRhsF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsF`/`Const_StaticOpsRhsF` directly.
            public class _InOptMut_StaticOpsRhsF
            {
                public StaticOpsRhsF? Opt;

                public _InOptMut_StaticOpsRhsF() {}
                public _InOptMut_StaticOpsRhsF(StaticOpsRhsF value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsF(StaticOpsRhsF value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsF`/`Const_StaticOpsRhsF` to pass it to the function.
            public class _InOptConst_StaticOpsRhsF
            {
                public Const_StaticOpsRhsF? Opt;

                public _InOptConst_StaticOpsRhsF() {}
                public _InOptConst_StaticOpsRhsF(Const_StaticOpsRhsF value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsF(Const_StaticOpsRhsF value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// Generated from class `MR::CSharp::StaticOpsRhsG`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsG : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsG_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsG() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsG::StaticOpsRhsG`.
                public unsafe Const_StaticOpsRhsG(MR.CS.CSharp.Const_StaticOpsRhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// Generated from class `MR::CSharp::StaticOpsRhsG`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsG : Const_StaticOpsRhsG
            {
                internal unsafe StaticOpsRhsG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsG::StaticOpsRhsG`.
                public unsafe StaticOpsRhsG(MR.CS.CSharp.Const_StaticOpsRhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsG::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsG assign(MR.CS.CSharp.Const_StaticOpsRhsG _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsG_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, StaticOpsRhsG _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsG", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsG(int _1, MR.CS.CSharp.StaticOpsRhsG._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsG(_1, _2._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsG`/`Const_StaticOpsRhsG` directly.
            public class _InOptMut_StaticOpsRhsG
            {
                public StaticOpsRhsG? Opt;

                public _InOptMut_StaticOpsRhsG() {}
                public _InOptMut_StaticOpsRhsG(StaticOpsRhsG value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsG(StaticOpsRhsG value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsG`/`Const_StaticOpsRhsG` to pass it to the function.
            public class _InOptConst_StaticOpsRhsG
            {
                public Const_StaticOpsRhsG? Opt;

                public _InOptConst_StaticOpsRhsG() {}
                public _InOptConst_StaticOpsRhsG(Const_StaticOpsRhsG value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsG(Const_StaticOpsRhsG value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// Generated from class `MR::CSharp::StaticOpsRhsH`.
            /// This is the const half of the class.
            public class Const_StaticOpsRhsH : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsRhsH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsH_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsH() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsRhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsH::StaticOpsRhsH`.
                public unsafe Const_StaticOpsRhsH(MR.CS.CSharp.Const_StaticOpsRhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, MR.CS.CSharp.Const_StaticOpsRhsH _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsH", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsH(int _1, MR.CS.CSharp.Const_StaticOpsRhsH._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_StaticOpsRhsH(_1, _2._UnderlyingPtr);
                }
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// Generated from class `MR::CSharp::StaticOpsRhsH`.
            /// This is the non-const half of the class.
            public class StaticOpsRhsH : Const_StaticOpsRhsH
            {
                internal unsafe StaticOpsRhsH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsRhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsRhsH::StaticOpsRhsH`.
                public unsafe StaticOpsRhsH(MR.CS.CSharp.Const_StaticOpsRhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsRhsH::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsRhsH assign(MR.CS.CSharp.Const_StaticOpsRhsH _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsRhsH_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsRhsH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsH`/`Const_StaticOpsRhsH` directly.
            public class _InOptMut_StaticOpsRhsH
            {
                public StaticOpsRhsH? Opt;

                public _InOptMut_StaticOpsRhsH() {}
                public _InOptMut_StaticOpsRhsH(StaticOpsRhsH value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsH(StaticOpsRhsH value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsRhsH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsH`/`Const_StaticOpsRhsH` to pass it to the function.
            public class _InOptConst_StaticOpsRhsH
            {
                public Const_StaticOpsRhsH? Opt;

                public _InOptConst_StaticOpsRhsH() {}
                public _InOptConst_StaticOpsRhsH(Const_StaticOpsRhsH value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsH(Const_StaticOpsRhsH value) {return new(value);}
            }

            // Other injection cases:
            public enum StaticOpsEnum : int
            {
            }

            /// Generated from class `MR::CSharp::StaticOpsMixedLhs`.
            /// This is the const half of the class.
            public class Const_StaticOpsMixedLhs : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsMixedLhs(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsMixedLhs_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsMixedLhs_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsMixedLhs() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsMixedLhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                public unsafe Const_StaticOpsMixedLhs(MR.CS.CSharp.Const_StaticOpsMixedLhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(_other._UnderlyingPtr);
                }

                // Gets injected into the lhs by default.
                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(Const_StaticOpsMixedLhs _1, MR.CS.CSharp.Const_StaticOpsMixedRhs _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_1, MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_2);
                    return __MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs(_1._UnderlyingPtr, _2._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::StaticOpsMixedLhs`.
            /// This is the non-const half of the class.
            public class StaticOpsMixedLhs : Const_StaticOpsMixedLhs
            {
                internal unsafe StaticOpsMixedLhs(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsMixedLhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                public unsafe StaticOpsMixedLhs(MR.CS.CSharp.Const_StaticOpsMixedLhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsMixedLhs::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsMixedLhs assign(MR.CS.CSharp.Const_StaticOpsMixedLhs _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsMixedLhs_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsMixedLhs` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsMixedLhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedLhs`/`Const_StaticOpsMixedLhs` directly.
            public class _InOptMut_StaticOpsMixedLhs
            {
                public StaticOpsMixedLhs? Opt;

                public _InOptMut_StaticOpsMixedLhs() {}
                public _InOptMut_StaticOpsMixedLhs(StaticOpsMixedLhs value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsMixedLhs(StaticOpsMixedLhs value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsMixedLhs` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsMixedLhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedLhs`/`Const_StaticOpsMixedLhs` to pass it to the function.
            public class _InOptConst_StaticOpsMixedLhs
            {
                public Const_StaticOpsMixedLhs? Opt;

                public _InOptConst_StaticOpsMixedLhs() {}
                public _InOptConst_StaticOpsMixedLhs(Const_StaticOpsMixedLhs value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsMixedLhs(Const_StaticOpsMixedLhs value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::StaticOpsMixedRhs`.
            /// This is the const half of the class.
            public class Const_StaticOpsMixedRhs : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StaticOpsMixedRhs(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsMixedRhs_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsMixedRhs_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsMixedRhs() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StaticOpsMixedRhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                public unsafe Const_StaticOpsMixedRhs(MR.CS.CSharp.Const_StaticOpsMixedRhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::StaticOpsMixedRhs`.
            /// This is the non-const half of the class.
            public class StaticOpsMixedRhs : Const_StaticOpsMixedRhs
            {
                internal unsafe StaticOpsMixedRhs(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StaticOpsMixedRhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                public unsafe StaticOpsMixedRhs(MR.CS.CSharp.Const_StaticOpsMixedRhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StaticOpsMixedRhs::operator=`.
                public unsafe MR.CS.CSharp.StaticOpsMixedRhs assign(MR.CS.CSharp.Const_StaticOpsMixedRhs _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    return new(__MR_CSharp_StaticOpsMixedRhs_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StaticOpsMixedRhs` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsMixedRhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedRhs`/`Const_StaticOpsMixedRhs` directly.
            public class _InOptMut_StaticOpsMixedRhs
            {
                public StaticOpsMixedRhs? Opt;

                public _InOptMut_StaticOpsMixedRhs() {}
                public _InOptMut_StaticOpsMixedRhs(StaticOpsMixedRhs value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsMixedRhs(StaticOpsMixedRhs value) {return new(value);}
            }

            /// This is used for optional parameters of class `StaticOpsMixedRhs` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsMixedRhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedRhs`/`Const_StaticOpsMixedRhs` to pass it to the function.
            public class _InOptConst_StaticOpsMixedRhs
            {
                public Const_StaticOpsMixedRhs? Opt;

                public _InOptConst_StaticOpsMixedRhs() {}
                public _InOptConst_StaticOpsMixedRhs(Const_StaticOpsMixedRhs value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsMixedRhs(Const_StaticOpsMixedRhs value) {return new(value);}
            }

            // Check how non-trivial class types are passed by value into operators.
            /// Generated from class `MR::CSharp::NonTrivialClassOps`.
            /// This is the const half of the class.
            public class Const_NonTrivialClassOps : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_NonTrivialClassOps(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivialClassOps_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivialClassOps_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivialClassOps() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_NonTrivialClassOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                public unsafe Const_NonTrivialClassOps(MR.CS.CSharp._ByValue_NonTrivialClassOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(Const_NonTrivialClassOps _1, float _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonTrivialClassOps_float", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonTrivialClassOps_float(MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_1, float _2);
                    return __MR_C_add_MR_CSharp_NonTrivialClassOps_float(MR.CS.Misc._PassBy.copy, _1._UnderlyingPtr, _2);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(float _1, Const_NonTrivialClassOps _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_float_MR_CSharp_NonTrivialClassOps", ExactSpelling = true)]
                    extern static int __MR_C_add_float_MR_CSharp_NonTrivialClassOps(float _1, MR.CS.Misc._PassBy _2_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_2);
                    return __MR_C_add_float_MR_CSharp_NonTrivialClassOps(_1, MR.CS.Misc._PassBy.copy, _2._UnderlyingPtr);
                }
            }

            // Check how non-trivial class types are passed by value into operators.
            /// Generated from class `MR::CSharp::NonTrivialClassOps`.
            /// This is the non-const half of the class.
            public class NonTrivialClassOps : Const_NonTrivialClassOps
            {
                internal unsafe NonTrivialClassOps(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe NonTrivialClassOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                public unsafe NonTrivialClassOps(MR.CS.CSharp._ByValue_NonTrivialClassOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::NonTrivialClassOps::operator=`.
                public unsafe MR.CS.CSharp.NonTrivialClassOps assign(MR.CS.CSharp._ByValue_NonTrivialClassOps _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    return new(__MR_CSharp_NonTrivialClassOps_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// Generated from method `MR::CSharp::NonTrivialClassOps::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.NonTrivialClassOps _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonTrivialClassOps_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonTrivialClassOps_int(MR.CS.CSharp.NonTrivialClassOps._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_NonTrivialClassOps_int(_this._UnderlyingPtr, _1);
                }
            }

            /// This is used as a function parameter when the underlying function receives `NonTrivialClassOps` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_NonTrivialClassOps
            {
                internal readonly Const_NonTrivialClassOps? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivialClassOps() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivialClassOps(Const_NonTrivialClassOps new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivialClassOps(Const_NonTrivialClassOps arg) {return new(arg);}
                public _ByValue_NonTrivialClassOps(MR.CS.Misc._Moved<NonTrivialClassOps> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivialClassOps(MR.CS.Misc._Moved<NonTrivialClassOps> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `NonTrivialClassOps` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivialClassOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` directly.
            public class _InOptMut_NonTrivialClassOps
            {
                public NonTrivialClassOps? Opt;

                public _InOptMut_NonTrivialClassOps() {}
                public _InOptMut_NonTrivialClassOps(NonTrivialClassOps value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivialClassOps(NonTrivialClassOps value) {return new(value);}
            }

            /// This is used for optional parameters of class `NonTrivialClassOps` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivialClassOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` to pass it to the function.
            public class _InOptConst_NonTrivialClassOps
            {
                public Const_NonTrivialClassOps? Opt;

                public _InOptConst_NonTrivialClassOps() {}
                public _InOptConst_NonTrivialClassOps(Const_NonTrivialClassOps value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivialClassOps(Const_NonTrivialClassOps value) {return new(value);}
            }

            // The class is non-copyable, so operators with by-value parameters fail to inject.
            /// Generated from class `MR::CSharp::NonCopyableClassByValueOps`.
            /// This is the const half of the class.
            public class Const_NonCopyableClassByValueOps : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_NonCopyableClassByValueOps(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonCopyableClassByValueOps_Destroy(_Underlying *_this);
                    __MR_CSharp_NonCopyableClassByValueOps_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonCopyableClassByValueOps() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_NonCopyableClassByValueOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonCopyableClassByValueOps::NonCopyableClassByValueOps`.
                public unsafe Const_NonCopyableClassByValueOps(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(Const_NonCopyableClassByValueOps _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int(_1._UnderlyingPtr, _2);
                }

                /// Generated from function `MR::CSharp::operator+`.
                public static unsafe int operator+(int _1, Const_NonCopyableClassByValueOps _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_NonCopyableClassByValueOps", ExactSpelling = true)]
                    extern static int __MR_C_add_int_MR_CSharp_NonCopyableClassByValueOps(int _1, MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_2);
                    return __MR_C_add_int_MR_CSharp_NonCopyableClassByValueOps(_1, _2._UnderlyingPtr);
                }
            }

            // The class is non-copyable, so operators with by-value parameters fail to inject.
            /// Generated from class `MR::CSharp::NonCopyableClassByValueOps`.
            /// This is the non-const half of the class.
            public class NonCopyableClassByValueOps : Const_NonCopyableClassByValueOps
            {
                internal unsafe NonCopyableClassByValueOps(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe NonCopyableClassByValueOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::NonCopyableClassByValueOps::NonCopyableClassByValueOps`.
                public unsafe NonCopyableClassByValueOps(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::NonCopyableClassByValueOps::operator=`.
                public unsafe MR.CS.CSharp.NonCopyableClassByValueOps assign(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    return new(__MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `NonCopyableClassByValueOps` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonCopyableClassByValueOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonCopyableClassByValueOps`/`Const_NonCopyableClassByValueOps` directly.
            public class _InOptMut_NonCopyableClassByValueOps
            {
                public NonCopyableClassByValueOps? Opt;

                public _InOptMut_NonCopyableClassByValueOps() {}
                public _InOptMut_NonCopyableClassByValueOps(NonCopyableClassByValueOps value) {Opt = value;}
                public static implicit operator _InOptMut_NonCopyableClassByValueOps(NonCopyableClassByValueOps value) {return new(value);}
            }

            /// This is used for optional parameters of class `NonCopyableClassByValueOps` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonCopyableClassByValueOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonCopyableClassByValueOps`/`Const_NonCopyableClassByValueOps` to pass it to the function.
            public class _InOptConst_NonCopyableClassByValueOps
            {
                public Const_NonCopyableClassByValueOps? Opt;

                public _InOptConst_NonCopyableClassByValueOps() {}
                public _InOptConst_NonCopyableClassByValueOps(Const_NonCopyableClassByValueOps value) {Opt = value;}
                public static implicit operator _InOptConst_NonCopyableClassByValueOps(Const_NonCopyableClassByValueOps value) {return new(value);}
            }

            // Test the call operator, since it can have an unusual amount of arguments.
            // Not testing `[]` here to be able to run the tests on older C++.
            /// Generated from class `MR::CSharp::CallOp`.
            /// This is the const half of the class.
            public class Const_CallOp : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_CallOp(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_CallOp_Destroy(_Underlying *_this);
                    __MR_CSharp_CallOp_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_CallOp() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_CallOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_CallOp_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                public unsafe Const_CallOp(MR.CS.CSharp.Const_CallOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_ConstructFromAnother(MR.CS.CSharp.CallOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_CallOp_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Test the call operator, since it can have an unusual amount of arguments.
            // Not testing `[]` here to be able to run the tests on older C++.
            /// Generated from class `MR::CSharp::CallOp`.
            /// This is the non-const half of the class.
            public class CallOp : Const_CallOp
            {
                internal unsafe CallOp(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe CallOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_CallOp_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                public unsafe CallOp(MR.CS.CSharp.Const_CallOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_ConstructFromAnother(MR.CS.CSharp.CallOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_CallOp_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::CallOp::operator=`.
                public unsafe MR.CS.CSharp.CallOp assign(MR.CS.CSharp.Const_CallOp _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.CallOp._Underlying *_other);
                    return new(__MR_CSharp_CallOp_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::CallOp::operator()`.
                public unsafe void call()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_call_0", ExactSpelling = true)]
                    extern static void __MR_CSharp_CallOp_call_0(_Underlying *_this);
                    __MR_CSharp_CallOp_call_0(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::CallOp::operator()`.
                public unsafe int call(int _1, int _2, int _3)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_call_3", ExactSpelling = true)]
                    extern static int __MR_CSharp_CallOp_call_3(_Underlying *_this, int _1, int _2, int _3);
                    return __MR_CSharp_CallOp_call_3(_UnderlyingPtr, _1, _2, _3);
                }
            }

            /// This is used for optional parameters of class `CallOp` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_CallOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `CallOp`/`Const_CallOp` directly.
            public class _InOptMut_CallOp
            {
                public CallOp? Opt;

                public _InOptMut_CallOp() {}
                public _InOptMut_CallOp(CallOp value) {Opt = value;}
                public static implicit operator _InOptMut_CallOp(CallOp value) {return new(value);}
            }

            /// This is used for optional parameters of class `CallOp` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_CallOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `CallOp`/`Const_CallOp` to pass it to the function.
            public class _InOptConst_CallOp
            {
                public Const_CallOp? Opt;

                public _InOptConst_CallOp() {}
                public _InOptConst_CallOp(Const_CallOp value) {Opt = value;}
                public static implicit operator _InOptConst_CallOp(Const_CallOp value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TestOpsA`.
            /// This is the const half of the class.
            public class Const_TestOpsA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TestOpsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsA_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsA() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                public unsafe Const_TestOpsA(MR.CS.CSharp.Const_TestOpsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsA._Underlying *__MR_CSharp_TestOpsA_ConstructFromAnother(MR.CS.CSharp.TestOpsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsA_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::TestOpsA`.
            /// This is the non-const half of the class.
            public class TestOpsA : Const_TestOpsA
            {
                internal unsafe TestOpsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                public unsafe TestOpsA(MR.CS.CSharp.Const_TestOpsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsA._Underlying *__MR_CSharp_TestOpsA_ConstructFromAnother(MR.CS.CSharp.TestOpsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator=`.
                public unsafe int assign(MR.CS.CSharp.Const_TestOpsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_AssignFromAnother", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_other);
                    return __MR_CSharp_TestOpsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_add_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_neg_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_sub_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_sub_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator*`.
                public unsafe int deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_deref_MR_CSharp_TestOpsA(_Underlying *_this);
                    return __MR_C_deref_MR_CSharp_TestOpsA(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator*`.
                public static unsafe int operator*(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_mul_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator/`.
                public static unsafe int operator/(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_div_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator%`.
                public static unsafe int operator%(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_mod_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_mod_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator^`.
                public static unsafe int operator^(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_xor_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_xor_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator&`.
                public unsafe int addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_addressof_MR_CSharp_TestOpsA(_Underlying *_this);
                    return __MR_C_addressof_MR_CSharp_TestOpsA(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator&`.
                public static unsafe int operator&(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_bitand_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_bitand_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator|`.
                public static unsafe int operator|(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_bitor_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_bitor_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator~`.
                public static unsafe int operator~(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_compl_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_compl_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator!`.
                public static unsafe int operator!(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_not_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_not_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator+=`.
                public unsafe int addAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_add_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_add_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_add_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator-=`.
                public unsafe int subAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_sub_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_sub_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_sub_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator*=`.
                public unsafe int mulAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_mul_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_mul_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_mul_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator/=`.
                public unsafe int divAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_div_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_div_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_div_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator%=`.
                public unsafe int modAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_mod_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_mod_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_mod_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator^=`.
                public unsafe int xorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_xor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_xor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_xor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator&=`.
                public unsafe int bitandAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_bitand_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_bitand_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_bitand_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator|=`.
                public unsafe int bitorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_bitor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_bitor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_bitor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator<<`.
                public static unsafe int operator<<(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_lshift_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_lshift_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator>>`.
                public static unsafe int operator>>(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_rshift_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_rshift_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator<<=`.
                public unsafe int lshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_lshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_lshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_lshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator>>=`.
                public unsafe int rshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_rshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_rshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_rshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator<=>`.
                public unsafe int compareThreeWay(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_compare_three_way_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_compare_three_way_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator&&`.
                public unsafe int and(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_and_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_and_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator||`.
                public unsafe int or(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_or_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_or_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator,`.
                public unsafe int comma(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_comma_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_comma_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator->*`.
                public unsafe int arrowStar(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_arrow_star", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_arrow_star(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_arrow_star(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator->`.
                public unsafe int arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_arrow", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_arrow(_Underlying *_this);
                    return __MR_CSharp_TestOpsA_arrow(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator()`.
                public unsafe int call(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_call", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_call(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_call(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsA::operator[]`.
                public unsafe int this[MR.CS.CSharp.Const_TestOpsA _1]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_index", ExactSpelling = true)]
                        extern static int __MR_CSharp_TestOpsA_index(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                        return __MR_CSharp_TestOpsA_index(_UnderlyingPtr, _1._UnderlyingPtr);
                    }
                }
            }

            /// This is used for optional parameters of class `TestOpsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsA`/`Const_TestOpsA` directly.
            public class _InOptMut_TestOpsA
            {
                public TestOpsA? Opt;

                public _InOptMut_TestOpsA() {}
                public _InOptMut_TestOpsA(TestOpsA value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsA(TestOpsA value) {return new(value);}
            }

            /// This is used for optional parameters of class `TestOpsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsA`/`Const_TestOpsA` to pass it to the function.
            public class _InOptConst_TestOpsA
            {
                public Const_TestOpsA? Opt;

                public _InOptConst_TestOpsA() {}
                public _InOptConst_TestOpsA(Const_TestOpsA value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsA(Const_TestOpsA value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TestOpsB`.
            /// This is the const half of the class.
            public class Const_TestOpsB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TestOpsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsB_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsB() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                public unsafe Const_TestOpsB(MR.CS.CSharp._ByValue_TestOpsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsB._Underlying *__MR_CSharp_TestOpsB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// Generated from class `MR::CSharp::TestOpsB`.
            /// This is the non-const half of the class.
            public class TestOpsB : Const_TestOpsB
            {
                internal unsafe TestOpsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                public unsafe TestOpsB(MR.CS.CSharp._ByValue_TestOpsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsB._Underlying *__MR_CSharp_TestOpsB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator=`.
                public unsafe int assign(MR.CS.CSharp._ByValue_TestOpsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_AssignFromAnother", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    return __MR_CSharp_TestOpsB_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_add_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_neg_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_sub_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_sub_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator*`.
                public unsafe int deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_deref_MR_CSharp_TestOpsB(_Underlying *_this);
                    return __MR_C_deref_MR_CSharp_TestOpsB(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator*`.
                public static unsafe int operator*(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_mul_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator/`.
                public static unsafe int operator/(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_div_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator%`.
                public static unsafe int operator%(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_mod_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_mod_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator^`.
                public static unsafe int operator^(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_xor_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_xor_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator&`.
                public unsafe int addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_addressof_MR_CSharp_TestOpsB(_Underlying *_this);
                    return __MR_C_addressof_MR_CSharp_TestOpsB(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator&`.
                public static unsafe int operator&(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_bitand_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_bitand_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator|`.
                public static unsafe int operator|(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_bitor_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_bitor_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator~`.
                public static unsafe int operator~(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_compl_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_compl_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator!`.
                public static unsafe int operator!(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_not_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_not_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator+=`.
                public unsafe int addAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_add_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_add_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_add_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator-=`.
                public unsafe int subAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_sub_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_sub_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_sub_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator*=`.
                public unsafe int mulAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_mul_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_mul_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_mul_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator/=`.
                public unsafe int divAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_div_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_div_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_div_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator%=`.
                public unsafe int modAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_mod_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_mod_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_mod_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator^=`.
                public unsafe int xorAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_xor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_xor_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_xor_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator&=`.
                public unsafe int bitandAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_bitand_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_bitand_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_bitand_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator|=`.
                public unsafe int bitorAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_bitor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_bitor_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_bitor_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator<<`.
                public static unsafe int operator<<(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_lshift_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_lshift_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator>>`.
                public static unsafe int operator>>(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_rshift_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_rshift_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator<<=`.
                public unsafe int lshiftAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_lshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_lshift_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_lshift_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator>>=`.
                public unsafe int rshiftAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_rshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_rshift_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_rshift_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator<=>`.
                public unsafe int compareThreeWay(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_compare_three_way_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_compare_three_way_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator&&`.
                public unsafe int and(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_and_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_and_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator||`.
                public unsafe int or(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_or_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_or_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator,`.
                public unsafe int comma(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_comma_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_comma_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator->*`.
                public unsafe int arrowStar(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_arrow_star", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_arrow_star(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_arrow_star(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator->`.
                public unsafe int arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_arrow", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_arrow(_Underlying *_this);
                    return __MR_CSharp_TestOpsB_arrow(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator()`.
                public unsafe int call(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_call", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_call(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_call(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// Generated from method `MR::CSharp::TestOpsB::operator[]`.
                public unsafe int this[MR.CS.CSharp._ByValue_TestOpsB _1]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_index", ExactSpelling = true)]
                        extern static int __MR_CSharp_TestOpsB_index(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                        return __MR_CSharp_TestOpsB_index(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                    }
                }
            }

            /// This is used as a function parameter when the underlying function receives `TestOpsB` by value.
            /// Usage:
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` to copy it into the function.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_TestOpsB
            {
                internal readonly Const_TestOpsB? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_TestOpsB(Const_TestOpsB new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_TestOpsB(Const_TestOpsB arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `TestOpsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` directly.
            public class _InOptMut_TestOpsB
            {
                public TestOpsB? Opt;

                public _InOptMut_TestOpsB() {}
                public _InOptMut_TestOpsB(TestOpsB value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsB(TestOpsB value) {return new(value);}
            }

            /// This is used for optional parameters of class `TestOpsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` to pass it to the function.
            public class _InOptConst_TestOpsB
            {
                public Const_TestOpsB? Opt;

                public _InOptConst_TestOpsB() {}
                public _InOptConst_TestOpsB(Const_TestOpsB value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsB(Const_TestOpsB value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::TestOpsC`.
            /// This is the const half of the class.
            public class Const_TestOpsC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_TestOpsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsC() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                public unsafe Const_TestOpsC(MR.CS.CSharp.Const_TestOpsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_ConstructFromAnother(MR.CS.CSharp.TestOpsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsC_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::TestOpsC`.
            /// This is the non-const half of the class.
            public class TestOpsC : Const_TestOpsC
            {
                internal unsafe TestOpsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                public unsafe TestOpsC(MR.CS.CSharp.Const_TestOpsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_ConstructFromAnother(MR.CS.CSharp.TestOpsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator=`.
                public unsafe MR.CS.CSharp.TestOpsC assign(MR.CS.CSharp.Const_TestOpsC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestOpsC._Underlying *_other);
                    return new(__MR_CSharp_TestOpsC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator+`.
                public unsafe void add()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_pos_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_pos_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator+`.
                public unsafe void add(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator-`.
                public unsafe void sub()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_neg_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_neg_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator-`.
                public unsafe void sub(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator*`.
                public unsafe void deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_deref_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_deref_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator*`.
                public unsafe void mul(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator/`.
                public unsafe void div(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator%`.
                public unsafe void mod(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator^`.
                public unsafe void xor(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator&`.
                public unsafe void addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_addressof_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_addressof_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator&`.
                public unsafe void bitand(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator|`.
                public unsafe void bitor(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator~`.
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_compl_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator!`.
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_not_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator=`.
                public unsafe void assign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator+=`.
                public unsafe void addAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_add_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_add_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_add_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator-=`.
                public unsafe void subAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_sub_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_sub_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_sub_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator*=`.
                public unsafe void mulAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_mul_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_mul_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_mul_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator/=`.
                public unsafe void divAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_div_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_div_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_div_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator%=`.
                public unsafe void modAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_mod_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_mod_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_mod_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator^=`.
                public unsafe void xorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_xor_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_xor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_xor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator&=`.
                public unsafe void bitandAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_bitand_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_bitand_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_bitand_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator|=`.
                public unsafe void bitorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_bitor_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_bitor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_bitor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator<<`.
                public unsafe void lshift(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator>>`.
                public unsafe void rshift(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator<<=`.
                public unsafe void lshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_lshift_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_lshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_lshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator>>=`.
                public unsafe void rshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_rshift_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_rshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_rshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator<=>`.
                public unsafe void compareThreeWay(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator&&`.
                public unsafe void and(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator||`.
                public unsafe void or(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator,`.
                public unsafe void comma(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator->*`.
                public unsafe void arrowStar(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_arrow_star", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_arrow_star(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_arrow_star(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator->`.
                public unsafe void arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_arrow", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_arrow(_Underlying *_this);
                    __MR_CSharp_TestOpsC_arrow(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator()`.
                public unsafe void call(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_call", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_call(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_call(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::TestOpsC::operator[]`.
                public unsafe void index(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_index", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_index(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_index(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `TestOpsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsC`/`Const_TestOpsC` directly.
            public class _InOptMut_TestOpsC
            {
                public TestOpsC? Opt;

                public _InOptMut_TestOpsC() {}
                public _InOptMut_TestOpsC(TestOpsC value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsC(TestOpsC value) {return new(value);}
            }

            /// This is used for optional parameters of class `TestOpsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsC`/`Const_TestOpsC` to pass it to the function.
            public class _InOptConst_TestOpsC
            {
                public Const_TestOpsC? Opt;

                public _InOptConst_TestOpsC() {}
                public _InOptConst_TestOpsC(Const_TestOpsC value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsC(Const_TestOpsC value) {return new(value);}
            }

            // Subscription operator.
            /// Generated from class `MR::CSharp::IndexerA`.
            /// This is the const half of the class.
            public class Const_IndexerA : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IndexerA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerA_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerA() {Dispose(false);}

                public unsafe int x
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_Get_x", ExactSpelling = true)]
                        extern static int *__MR_CSharp_IndexerA_Get_x(_Underlying *_this);
                        return *__MR_CSharp_IndexerA_Get_x(_UnderlyingPtr);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IndexerA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerA_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::IndexerA` elementwise.
                public unsafe Const_IndexerA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFrom(x);
                }

                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                public unsafe Const_IndexerA(MR.CS.CSharp.Const_IndexerA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFromAnother(MR.CS.CSharp.IndexerA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Subscription operator.
            /// Generated from class `MR::CSharp::IndexerA`.
            /// This is the non-const half of the class.
            public class IndexerA : Const_IndexerA
            {
                internal unsafe IndexerA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe ref int x
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_GetMutable_x", ExactSpelling = true)]
                        extern static int *__MR_CSharp_IndexerA_GetMutable_x(_Underlying *_this);
                        return ref *__MR_CSharp_IndexerA_GetMutable_x(_UnderlyingPtr);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe IndexerA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerA_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::IndexerA` elementwise.
                public unsafe IndexerA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFrom(x);
                }

                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                public unsafe IndexerA(MR.CS.CSharp.Const_IndexerA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFromAnother(MR.CS.CSharp.IndexerA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IndexerA::operator=`.
                public unsafe MR.CS.CSharp.IndexerA assign(MR.CS.CSharp.Const_IndexerA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerA._Underlying *_other);
                    return new(__MR_CSharp_IndexerA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IndexerA::operator[]`.
                public unsafe ref int this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_index", ExactSpelling = true)]
                        extern static int *__MR_CSharp_IndexerA_index(_Underlying *_this, int i);
                        return ref *__MR_CSharp_IndexerA_index(_UnderlyingPtr, i);
                    }
                }
            }

            /// This is used for optional parameters of class `IndexerA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerA`/`Const_IndexerA` directly.
            public class _InOptMut_IndexerA
            {
                public IndexerA? Opt;

                public _InOptMut_IndexerA() {}
                public _InOptMut_IndexerA(IndexerA value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerA(IndexerA value) {return new(value);}
            }

            /// This is used for optional parameters of class `IndexerA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerA`/`Const_IndexerA` to pass it to the function.
            public class _InOptConst_IndexerA
            {
                public Const_IndexerA? Opt;

                public _InOptConst_IndexerA() {}
                public _InOptConst_IndexerA(Const_IndexerA value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerA(Const_IndexerA value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::IndexerB`.
            /// This is the const half of the class.
            public class Const_IndexerB : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IndexerB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerB_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerB() {Dispose(false);}

                public unsafe MR.CS.CSharp.Const_IndexerA a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_Get_a(_Underlying *_this);
                        return new(__MR_CSharp_IndexerB_Get_a(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IndexerB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerB_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::IndexerB` elementwise.
                public unsafe Const_IndexerB(MR.CS.CSharp.Const_IndexerA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFrom(MR.CS.CSharp.IndexerA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFrom(a._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                public unsafe Const_IndexerB(MR.CS.CSharp.Const_IndexerB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFromAnother(MR.CS.CSharp.IndexerB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                public unsafe MR.CS.CSharp.Const_IndexerA this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_1", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_1(_Underlying *_this, int i);
                        return new(__MR_CSharp_IndexerB_index_1(_UnderlyingPtr, i), is_owning: false);
                    }
                }

                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                public unsafe MR.CS.CSharp.Const_IndexerA this[int i, int j]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_2", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_2(_Underlying *_this, int i, int j);
                        return new(__MR_CSharp_IndexerB_index_2(_UnderlyingPtr, i, j), is_owning: false);
                    }
                }

                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                public unsafe MR.CS.CSharp.Const_IndexerA index()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_0", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_0(_Underlying *_this);
                    return new(__MR_CSharp_IndexerB_index_0(_UnderlyingPtr), is_owning: false);
                }
            }

            /// Generated from class `MR::CSharp::IndexerB`.
            /// This is the non-const half of the class.
            public class IndexerB : Const_IndexerB
            {
                internal unsafe IndexerB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe MR.CS.CSharp.IndexerA a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerB_GetMutable_a(_Underlying *_this);
                        return new(__MR_CSharp_IndexerB_GetMutable_a(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe IndexerB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerB_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::IndexerB` elementwise.
                public unsafe IndexerB(MR.CS.CSharp.Const_IndexerA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFrom(MR.CS.CSharp.IndexerA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFrom(a._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                public unsafe IndexerB(MR.CS.CSharp.Const_IndexerB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFromAnother(MR.CS.CSharp.IndexerB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IndexerB::operator=`.
                public unsafe MR.CS.CSharp.IndexerB assign(MR.CS.CSharp.Const_IndexerB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerB._Underlying *_other);
                    return new(__MR_CSharp_IndexerB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `IndexerB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerB`/`Const_IndexerB` directly.
            public class _InOptMut_IndexerB
            {
                public IndexerB? Opt;

                public _InOptMut_IndexerB() {}
                public _InOptMut_IndexerB(IndexerB value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerB(IndexerB value) {return new(value);}
            }

            /// This is used for optional parameters of class `IndexerB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerB`/`Const_IndexerB` to pass it to the function.
            public class _InOptConst_IndexerB
            {
                public Const_IndexerB? Opt;

                public _InOptConst_IndexerB() {}
                public _InOptConst_IndexerB(Const_IndexerB value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerB(Const_IndexerB value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::IndexerC`.
            /// This is the const half of the class.
            public class Const_IndexerC : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_IndexerC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerC_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerC() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_IndexerC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                public unsafe Const_IndexerC(MR.CS.CSharp.Const_IndexerC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_ConstructFromAnother(MR.CS.CSharp.IndexerC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IndexerC::operator[]`.
                public unsafe float this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_index_const", ExactSpelling = true)]
                        extern static float __MR_CSharp_IndexerC_index_const(_Underlying *_this, int i);
                        return __MR_CSharp_IndexerC_index_const(_UnderlyingPtr, i);
                    }
                }
            }

            /// Generated from class `MR::CSharp::IndexerC`.
            /// This is the non-const half of the class.
            public class IndexerC : Const_IndexerC
            {
                internal unsafe IndexerC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe IndexerC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerC_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                public unsafe IndexerC(MR.CS.CSharp.Const_IndexerC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_ConstructFromAnother(MR.CS.CSharp.IndexerC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerC_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::IndexerC::operator=`.
                public unsafe MR.CS.CSharp.IndexerC assign(MR.CS.CSharp.Const_IndexerC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerC._Underlying *_other);
                    return new(__MR_CSharp_IndexerC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::IndexerC::operator[]`.
                public unsafe new int this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_index", ExactSpelling = true)]
                        extern static int __MR_CSharp_IndexerC_index(_Underlying *_this, int i);
                        return __MR_CSharp_IndexerC_index(_UnderlyingPtr, i);
                    }
                }
            }

            /// This is used for optional parameters of class `IndexerC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerC`/`Const_IndexerC` directly.
            public class _InOptMut_IndexerC
            {
                public IndexerC? Opt;

                public _InOptMut_IndexerC() {}
                public _InOptMut_IndexerC(IndexerC value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerC(IndexerC value) {return new(value);}
            }

            /// This is used for optional parameters of class `IndexerC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerC`/`Const_IndexerC` to pass it to the function.
            public class _InOptConst_IndexerC
            {
                public Const_IndexerC? Opt;

                public _InOptConst_IndexerC() {}
                public _InOptConst_IndexerC(Const_IndexerC value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerC(Const_IndexerC value) {return new(value);}
            }

            // Conversion operators. We preserve explicit-ness.
            /// Generated from class `MR::CSharp::ConvOp`.
            /// This is the const half of the class.
            public class Const_ConvOp : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvOp(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvOp_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvOp_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvOp() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ConvOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOp_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                public unsafe Const_ConvOp(MR.CS.CSharp.Const_ConvOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_ConstructFromAnother(MR.CS.CSharp.ConvOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOp_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Conversion operators. We preserve explicit-ness.
            /// Generated from class `MR::CSharp::ConvOp`.
            /// This is the non-const half of the class.
            public class ConvOp : Const_ConvOp
            {
                internal unsafe ConvOp(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe ConvOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOp_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                public unsafe ConvOp(MR.CS.CSharp.Const_ConvOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_ConstructFromAnother(MR.CS.CSharp.ConvOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOp_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from conversion operator `MR::CSharp::ConvOp::operator int`.
                public static unsafe implicit operator int(MR.CS.CSharp.ConvOp _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConvertTo_int", ExactSpelling = true)]
                    extern static int __MR_CSharp_ConvOp_ConvertTo_int(MR.CS.CSharp.ConvOp._Underlying *_this);
                    return __MR_CSharp_ConvOp_ConvertTo_int(_this._UnderlyingPtr);
                }

                /// Generated from conversion operator `MR::CSharp::ConvOp::operator float`.
                public static unsafe explicit operator float(MR.CS.CSharp.ConvOp _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConvertTo_float", ExactSpelling = true)]
                    extern static float __MR_CSharp_ConvOp_ConvertTo_float(MR.CS.CSharp.ConvOp._Underlying *_this);
                    return __MR_CSharp_ConvOp_ConvertTo_float(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConvOp::operator=`.
                public unsafe MR.CS.CSharp.ConvOp assign(MR.CS.CSharp.Const_ConvOp _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvOp._Underlying *_other);
                    return new(__MR_CSharp_ConvOp_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `ConvOp` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOp`/`Const_ConvOp` directly.
            public class _InOptMut_ConvOp
            {
                public ConvOp? Opt;

                public _InOptMut_ConvOp() {}
                public _InOptMut_ConvOp(ConvOp value) {Opt = value;}
                public static implicit operator _InOptMut_ConvOp(ConvOp value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvOp` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOp`/`Const_ConvOp` to pass it to the function.
            public class _InOptConst_ConvOp
            {
                public Const_ConvOp? Opt;

                public _InOptConst_ConvOp() {}
                public _InOptConst_ConvOp(Const_ConvOp value) {Opt = value;}
                public static implicit operator _InOptConst_ConvOp(Const_ConvOp value) {return new(value);}
            }

            // Conversion operators to references.
            /// Generated from class `MR::CSharp::ConvOpToRef`.
            /// This is the const half of the class.
            public class Const_ConvOpToRef : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvOpToRef(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvOpToRef_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvOpToRef_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvOpToRef() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ConvOpToRef() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                public unsafe Const_ConvOpToRef(MR.CS.CSharp.Const_ConvOpToRef _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_ConstructFromAnother(MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Conversion operators to references.
            /// Generated from class `MR::CSharp::ConvOpToRef`.
            /// This is the non-const half of the class.
            public class ConvOpToRef : Const_ConvOpToRef
            {
                internal unsafe ConvOpToRef(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe ConvOpToRef() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                public unsafe ConvOpToRef(MR.CS.CSharp.Const_ConvOpToRef _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_ConstructFromAnother(MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_ConstructFromAnother(_other._UnderlyingPtr);
                }

                // Not to a reference.
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator int`.
                public static unsafe implicit operator int(MR.CS.CSharp.ConvOpToRef _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_int", ExactSpelling = true)]
                    extern static int __MR_CSharp_ConvOpToRef_ConvertTo_int(MR.CS.CSharp.ConvOpToRef._Underlying *_this);
                    return __MR_CSharp_ConvOpToRef_ConvertTo_int(_this._UnderlyingPtr);
                }

                // To a reference.
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator float &`.
                public unsafe ref float convertTo_FloatRef()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_float_ref", ExactSpelling = true)]
                    extern static float *__MR_CSharp_ConvOpToRef_ConvertTo_float_ref(_Underlying *_this);
                    return ref *__MR_CSharp_ConvOpToRef_ConvertTo_float_ref(_UnderlyingPtr);
                }

                // To a reference, explicit.
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator unsigned short &`.
                public unsafe ref ushort convertTo_UnsignedShortRef()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_unsigned_short_ref", ExactSpelling = true)]
                    extern static ushort *__MR_CSharp_ConvOpToRef_ConvertTo_unsigned_short_ref(_Underlying *_this);
                    return ref *__MR_CSharp_ConvOpToRef_ConvertTo_unsigned_short_ref(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConvOpToRef::operator=`.
                public unsafe MR.CS.CSharp.ConvOpToRef assign(MR.CS.CSharp.Const_ConvOpToRef _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    return new(__MR_CSharp_ConvOpToRef_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `ConvOpToRef` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvOpToRef`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOpToRef`/`Const_ConvOpToRef` directly.
            public class _InOptMut_ConvOpToRef
            {
                public ConvOpToRef? Opt;

                public _InOptMut_ConvOpToRef() {}
                public _InOptMut_ConvOpToRef(ConvOpToRef value) {Opt = value;}
                public static implicit operator _InOptMut_ConvOpToRef(ConvOpToRef value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvOpToRef` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvOpToRef`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOpToRef`/`Const_ConvOpToRef` to pass it to the function.
            public class _InOptConst_ConvOpToRef
            {
                public Const_ConvOpToRef? Opt;

                public _InOptConst_ConvOpToRef() {}
                public _InOptConst_ConvOpToRef(Const_ConvOpToRef value) {Opt = value;}
                public static implicit operator _InOptConst_ConvOpToRef(Const_ConvOpToRef value) {return new(value);}
            }

            // Conversions to string-like types.
            // Those create the additional `operator string` to convert directly to a C# string, and `override string ToString()` to override the method of the implicit base `object`.
            /// Generated from class `MR::CSharp::StringConvString`.
            /// This is the const half of the class.
            public class Const_StringConvString : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StringConvString(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvString_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvString_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvString() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StringConvString() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvString_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                public unsafe Const_StringConvString(MR.CS.CSharp.Const_StringConvString _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_ConstructFromAnother(MR.CS.CSharp.StringConvString._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvString_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Conversions to string-like types.
            // Those create the additional `operator string` to convert directly to a C# string, and `override string ToString()` to override the method of the implicit base `object`.
            /// Generated from class `MR::CSharp::StringConvString`.
            /// This is the non-const half of the class.
            public class StringConvString : Const_StringConvString
            {
                internal unsafe StringConvString(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StringConvString() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvString_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                public unsafe StringConvString(MR.CS.CSharp.Const_StringConvString _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_ConstructFromAnother(MR.CS.CSharp.StringConvString._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvString_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                public static unsafe implicit operator MR.CS.Std.String(MR.CS.CSharp.StringConvString _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConvertTo_std_string", ExactSpelling = true)]
                    extern static MR.CS.Std.String._Underlying *__MR_CSharp_StringConvString_ConvertTo_std_string(MR.CS.CSharp.StringConvString._Underlying *_this);
                    return new(__MR_CSharp_StringConvString_ConvertTo_std_string(_this._UnderlyingPtr), is_owning: true);
                }

                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                public static implicit operator string(MR.CS.CSharp.StringConvString _this) {return (MR.CS.Std.String)_this;}

                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                public override string ToString() {return (string)this;}

                /// Generated from method `MR::CSharp::StringConvString::operator=`.
                public unsafe MR.CS.CSharp.StringConvString assign(MR.CS.CSharp.Const_StringConvString _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvString._Underlying *_other);
                    return new(__MR_CSharp_StringConvString_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StringConvString` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvString`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvString`/`Const_StringConvString` directly.
            public class _InOptMut_StringConvString
            {
                public StringConvString? Opt;

                public _InOptMut_StringConvString() {}
                public _InOptMut_StringConvString(StringConvString value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvString(StringConvString value) {return new(value);}
            }

            /// This is used for optional parameters of class `StringConvString` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvString`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvString`/`Const_StringConvString` to pass it to the function.
            public class _InOptConst_StringConvString
            {
                public Const_StringConvString? Opt;

                public _InOptConst_StringConvString() {}
                public _InOptConst_StringConvString(Const_StringConvString value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvString(Const_StringConvString value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::StringConvStringView`.
            /// This is the const half of the class.
            public class Const_StringConvStringView : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StringConvStringView(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvStringView_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvStringView_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvStringView() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StringConvStringView() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                public unsafe Const_StringConvStringView(MR.CS.CSharp.Const_StringConvStringView _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_ConstructFromAnother(MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_ConstructFromAnother(_other._UnderlyingPtr);
                }

                // Mark this `explicit` and `const` for a change.
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                public static unsafe explicit operator MR.CS.Std.StringView(MR.CS.CSharp.Const_StringConvStringView _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConvertTo_std_string_view", ExactSpelling = true)]
                    extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_StringConvStringView_ConvertTo_std_string_view(MR.CS.CSharp.Const_StringConvStringView._Underlying *_this);
                    return new(__MR_CSharp_StringConvStringView_ConvertTo_std_string_view(_this._UnderlyingPtr), is_owning: true);
                }

                // Mark this `explicit` and `const` for a change.
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                public static explicit operator string(MR.CS.CSharp.Const_StringConvStringView _this) {return (MR.CS.Std.StringView)_this;}

                // Mark this `explicit` and `const` for a change.
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                public override string ToString() {return (string)this;}
            }

            /// Generated from class `MR::CSharp::StringConvStringView`.
            /// This is the non-const half of the class.
            public class StringConvStringView : Const_StringConvStringView
            {
                internal unsafe StringConvStringView(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StringConvStringView() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                public unsafe StringConvStringView(MR.CS.CSharp.Const_StringConvStringView _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_ConstructFromAnother(MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::StringConvStringView::operator=`.
                public unsafe MR.CS.CSharp.StringConvStringView assign(MR.CS.CSharp.Const_StringConvStringView _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    return new(__MR_CSharp_StringConvStringView_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StringConvStringView` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvStringView`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvStringView`/`Const_StringConvStringView` directly.
            public class _InOptMut_StringConvStringView
            {
                public StringConvStringView? Opt;

                public _InOptMut_StringConvStringView() {}
                public _InOptMut_StringConvStringView(StringConvStringView value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvStringView(StringConvStringView value) {return new(value);}
            }

            /// This is used for optional parameters of class `StringConvStringView` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvStringView`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvStringView`/`Const_StringConvStringView` to pass it to the function.
            public class _InOptConst_StringConvStringView
            {
                public Const_StringConvStringView? Opt;

                public _InOptConst_StringConvStringView() {}
                public _InOptConst_StringConvStringView(Const_StringConvStringView value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvStringView(Const_StringConvStringView value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::StringConvFsPath`.
            /// This is the const half of the class.
            public class Const_StringConvFsPath : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_StringConvFsPath(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvFsPath_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvFsPath_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvFsPath() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_StringConvFsPath() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                public unsafe Const_StringConvFsPath(MR.CS.CSharp.Const_StringConvFsPath _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_ConstructFromAnother(MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::StringConvFsPath`.
            /// This is the non-const half of the class.
            public class StringConvFsPath : Const_StringConvFsPath
            {
                internal unsafe StringConvFsPath(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe StringConvFsPath() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                public unsafe StringConvFsPath(MR.CS.CSharp.Const_StringConvFsPath _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_ConstructFromAnother(MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                public static unsafe implicit operator MR.CS.Std.Filesystem.Path(MR.CS.CSharp.StringConvFsPath _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path", ExactSpelling = true)]
                    extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path(MR.CS.CSharp.StringConvFsPath._Underlying *_this);
                    return new(__MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path(_this._UnderlyingPtr), is_owning: true);
                }

                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                public static implicit operator string(MR.CS.CSharp.StringConvFsPath _this) {return (MR.CS.Std.Filesystem.Path)_this;}

                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                public override string ToString() {return (string)this;}

                /// Generated from method `MR::CSharp::StringConvFsPath::operator=`.
                public unsafe MR.CS.CSharp.StringConvFsPath assign(MR.CS.CSharp.Const_StringConvFsPath _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    return new(__MR_CSharp_StringConvFsPath_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `StringConvFsPath` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvFsPath`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvFsPath`/`Const_StringConvFsPath` directly.
            public class _InOptMut_StringConvFsPath
            {
                public StringConvFsPath? Opt;

                public _InOptMut_StringConvFsPath() {}
                public _InOptMut_StringConvFsPath(StringConvFsPath value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvFsPath(StringConvFsPath value) {return new(value);}
            }

            /// This is used for optional parameters of class `StringConvFsPath` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvFsPath`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvFsPath`/`Const_StringConvFsPath` to pass it to the function.
            public class _InOptConst_StringConvFsPath
            {
                public Const_StringConvFsPath? Opt;

                public _InOptConst_StringConvFsPath() {}
                public _InOptConst_StringConvFsPath(Const_StringConvFsPath value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvFsPath(Const_StringConvFsPath value) {return new(value);}
            }

            // Conversion constructors. Right now we only provide conversion operators for implicit ones,
            //   because I have no idea when the explicit ones could be useful.
            /// Generated from class `MR::CSharp::ConvCtor`.
            /// This is the const half of the class.
            public class Const_ConvCtor : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtor(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtor_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtor_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtor() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ConvCtor() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe Const_ConvCtor(MR.CS.CSharp.Const_ConvCtor _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_ConstructFromAnother(MR.CS.CSharp.ConvCtor._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe Const_ConvCtor(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_int(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_int(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public static unsafe implicit operator Const_ConvCtor(int _1) {return new(_1);}

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe Const_ConvCtor(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int(int _1, int _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int(_1, _2);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe Const_ConvCtor(float _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_float(float _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_float(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe Const_ConvCtor(float _1, float _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_float(float _1, float _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_float(_1, _2);
                }
            }

            // Conversion constructors. Right now we only provide conversion operators for implicit ones,
            //   because I have no idea when the explicit ones could be useful.
            /// Generated from class `MR::CSharp::ConvCtor`.
            /// This is the non-const half of the class.
            public class ConvCtor : Const_ConvCtor
            {
                internal unsafe ConvCtor(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe ConvCtor() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe ConvCtor(MR.CS.CSharp.Const_ConvCtor _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_ConstructFromAnother(MR.CS.CSharp.ConvCtor._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe ConvCtor(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_int(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_int(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public static unsafe implicit operator ConvCtor(int _1) {return new(_1);}

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe ConvCtor(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int(int _1, int _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int(_1, _2);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe ConvCtor(float _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_float(float _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_float(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public unsafe ConvCtor(float _1, float _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_float(float _1, float _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_float(_1, _2);
                }

                /// Generated from method `MR::CSharp::ConvCtor::operator=`.
                public unsafe MR.CS.CSharp.ConvCtor assign(MR.CS.CSharp.Const_ConvCtor _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtor._Underlying *_other);
                    return new(__MR_CSharp_ConvCtor_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `ConvCtor` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtor`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtor`/`Const_ConvCtor` directly.
            public class _InOptMut_ConvCtor
            {
                public ConvCtor? Opt;

                public _InOptMut_ConvCtor() {}
                public _InOptMut_ConvCtor(ConvCtor value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtor(ConvCtor value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtor` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtor`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtor`/`Const_ConvCtor` to pass it to the function.
            public class _InOptConst_ConvCtor
            {
                public Const_ConvCtor? Opt;

                public _InOptConst_ConvCtor() {}
                public _InOptConst_ConvCtor(Const_ConvCtor value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtor(Const_ConvCtor value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                public static unsafe implicit operator _InOptConst_ConvCtor(int _1) {return new Const_ConvCtor(_1);}
            }

            // Test that the default argument of the parameter of a converting constructor is stripped when rewriting it as a conversion operator.
            /// Generated from class `MR::CSharp::ConvCtorWithDefArg`.
            /// This is the const half of the class.
            public class Const_ConvCtorWithDefArg : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtorWithDefArg(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorWithDefArg_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorWithDefArg_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorWithDefArg() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                public unsafe Const_ConvCtorWithDefArg(int? _1 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_Construct(int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_Construct(_1.HasValue ? &__deref__1 : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                public static unsafe implicit operator Const_ConvCtorWithDefArg(int? _1) {return new(_1);}

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                public unsafe Const_ConvCtorWithDefArg(MR.CS.CSharp.Const_ConvCtorWithDefArg _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            // Test that the default argument of the parameter of a converting constructor is stripped when rewriting it as a conversion operator.
            /// Generated from class `MR::CSharp::ConvCtorWithDefArg`.
            /// This is the non-const half of the class.
            public class ConvCtorWithDefArg : Const_ConvCtorWithDefArg
            {
                internal unsafe ConvCtorWithDefArg(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                public unsafe ConvCtorWithDefArg(int? _1 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_Construct(int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_Construct(_1.HasValue ? &__deref__1 : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                public static unsafe implicit operator ConvCtorWithDefArg(int? _1) {return new(_1);}

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                public unsafe ConvCtorWithDefArg(MR.CS.CSharp.Const_ConvCtorWithDefArg _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConvCtorWithDefArg::operator=`.
                public unsafe MR.CS.CSharp.ConvCtorWithDefArg assign(MR.CS.CSharp.Const_ConvCtorWithDefArg _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    return new(__MR_CSharp_ConvCtorWithDefArg_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `ConvCtorWithDefArg` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorWithDefArg`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorWithDefArg`/`Const_ConvCtorWithDefArg` directly.
            public class _InOptMut_ConvCtorWithDefArg
            {
                public ConvCtorWithDefArg? Opt;

                public _InOptMut_ConvCtorWithDefArg() {}
                public _InOptMut_ConvCtorWithDefArg(ConvCtorWithDefArg value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorWithDefArg(ConvCtorWithDefArg value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtorWithDefArg` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorWithDefArg`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorWithDefArg`/`Const_ConvCtorWithDefArg` to pass it to the function.
            public class _InOptConst_ConvCtorWithDefArg
            {
                public Const_ConvCtorWithDefArg? Opt;

                public _InOptConst_ConvCtorWithDefArg() {}
                public _InOptConst_ConvCtorWithDefArg(Const_ConvCtorWithDefArg value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorWithDefArg(Const_ConvCtorWithDefArg value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                public static unsafe implicit operator _InOptConst_ConvCtorWithDefArg(int? _1) {return new Const_ConvCtorWithDefArg(_1);}
            }

            // A non-trivial move-only class with a converting ctor.
            // Here we test that our converting constructors injected into `_ByValue_...` don't attempt to copy the class.
            /// Generated from class `MR::CSharp::ConvCtorNonTrivialRestricted`.
            /// This is the const half of the class.
            public class Const_ConvCtorNonTrivialRestricted : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtorNonTrivialRestricted(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorNonTrivialRestricted_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorNonTrivialRestricted_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorNonTrivialRestricted() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public unsafe Const_ConvCtorNonTrivialRestricted(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public unsafe Const_ConvCtorNonTrivialRestricted(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public static unsafe implicit operator Const_ConvCtorNonTrivialRestricted(int _1) {return new(_1);}
            }

            // A non-trivial move-only class with a converting ctor.
            // Here we test that our converting constructors injected into `_ByValue_...` don't attempt to copy the class.
            /// Generated from class `MR::CSharp::ConvCtorNonTrivialRestricted`.
            /// This is the non-const half of the class.
            public class ConvCtorNonTrivialRestricted : Const_ConvCtorNonTrivialRestricted
            {
                internal unsafe ConvCtorNonTrivialRestricted(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public unsafe ConvCtorNonTrivialRestricted(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public unsafe ConvCtorNonTrivialRestricted(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public static unsafe implicit operator ConvCtorNonTrivialRestricted(int _1) {return new(_1);}

                /// Generated from method `MR::CSharp::ConvCtorNonTrivialRestricted::operator=`.
                public unsafe MR.CS.CSharp.ConvCtorNonTrivialRestricted assign(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    return new(__MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `ConvCtorNonTrivialRestricted` by value.
            /// Usage:
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_ConvCtorNonTrivialRestricted
            {
                internal readonly Const_ConvCtorNonTrivialRestricted? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorNonTrivialRestricted(MR.CS.Misc._Moved<ConvCtorNonTrivialRestricted> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ConvCtorNonTrivialRestricted(MR.CS.Misc._Moved<ConvCtorNonTrivialRestricted> arg) {return new(arg);}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public static unsafe implicit operator _ByValue_ConvCtorNonTrivialRestricted(int _1) {return new MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivialRestricted>(_1);}
            }

            /// This is used for optional parameters of class `ConvCtorNonTrivialRestricted` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorNonTrivialRestricted`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivialRestricted`/`Const_ConvCtorNonTrivialRestricted` directly.
            public class _InOptMut_ConvCtorNonTrivialRestricted
            {
                public ConvCtorNonTrivialRestricted? Opt;

                public _InOptMut_ConvCtorNonTrivialRestricted() {}
                public _InOptMut_ConvCtorNonTrivialRestricted(ConvCtorNonTrivialRestricted value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorNonTrivialRestricted(ConvCtorNonTrivialRestricted value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtorNonTrivialRestricted` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorNonTrivialRestricted`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivialRestricted`/`Const_ConvCtorNonTrivialRestricted` to pass it to the function.
            public class _InOptConst_ConvCtorNonTrivialRestricted
            {
                public Const_ConvCtorNonTrivialRestricted? Opt;

                public _InOptConst_ConvCtorNonTrivialRestricted() {}
                public _InOptConst_ConvCtorNonTrivialRestricted(Const_ConvCtorNonTrivialRestricted value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorNonTrivialRestricted(Const_ConvCtorNonTrivialRestricted value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                public static unsafe implicit operator _InOptConst_ConvCtorNonTrivialRestricted(int _1) {return new Const_ConvCtorNonTrivialRestricted(_1);}
            }

            // A converting ctor in an exposed struct.
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the const reference to the struct.
            public class Const_ConvCtorExposed : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// Get the underlying struct.
                public unsafe ref readonly ConvCtorExposed _Ref => ref *(ConvCtorExposed *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_ConvCtorExposed(ConvCtorExposed other) : this(new Const_ConvCtorExposed((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_ConvCtorExposed` has this conversion, `Mut_ConvCtorExposed` intentionally doesn't.
                public static implicit operator Const_ConvCtorExposed(ConvCtorExposed other) {return new(other);}

                internal unsafe Const_ConvCtorExposed(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorExposed() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// Generated copy constructor.
                public unsafe Const_ConvCtorExposed(Const_ConvCtorExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public unsafe Const_ConvCtorExposed(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    MR.CS.CSharp.ConvCtorExposed _ctor_result = __MR_CSharp_ConvCtorExposed_Construct(_1);
                    System.Runtime.InteropServices.NativeMemory.Copy(&_ctor_result, _UnderlyingPtr, 4);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public static unsafe implicit operator Const_ConvCtorExposed(int _1) {return new(_1);}
            }

            // A converting ctor in an exposed struct.
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the non-const reference to the struct.
            public class Mut_ConvCtorExposed : Const_ConvCtorExposed
            {
                /// Get the underlying struct.
                public unsafe new ref ConvCtorExposed _Ref => ref *(ConvCtorExposed *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_ConvCtorExposed(ConvCtorExposed other) : this(new Const_ConvCtorExposed((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_ConvCtorExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new ref int x => ref _Ref.x;

                /// Generated copy constructor.
                public unsafe Mut_ConvCtorExposed(Const_ConvCtorExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                /// Generated copy assignment.
                public void Assign(Const_ConvCtorExposed _other) {_Ref = _other._Ref;}

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public unsafe Mut_ConvCtorExposed(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    MR.CS.CSharp.ConvCtorExposed _ctor_result = __MR_CSharp_ConvCtorExposed_Construct(_1);
                    System.Runtime.InteropServices.NativeMemory.Copy(&_ctor_result, _UnderlyingPtr, 4);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public static unsafe implicit operator Mut_ConvCtorExposed(int _1) {return new(_1);}
            }

            // A converting ctor in an exposed struct.
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ConvCtorExposed
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator ConvCtorExposed(Const_ConvCtorExposed other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// Generated copy constructor.
                public ConvCtorExposed(ConvCtorExposed _other) {this = _other;}

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public unsafe ConvCtorExposed(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    this = __MR_CSharp_ConvCtorExposed_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public static unsafe implicit operator ConvCtorExposed(int _1) {return new(_1);}
            }

            /// This is used as a function parameter when passing `Mut_ConvCtorExposed` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_ConvCtorExposed`/`Const_ConvCtorExposed` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_ConvCtorExposed
            {
                public readonly bool HasValue;
                internal readonly ConvCtorExposed Object;
                public ConvCtorExposed Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ConvCtorExposed() {HasValue = false;}
                public _InOpt_ConvCtorExposed(ConvCtorExposed new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ConvCtorExposed(ConvCtorExposed new_value) {return new(new_value);}
                public _InOpt_ConvCtorExposed(Const_ConvCtorExposed new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ConvCtorExposed(Const_ConvCtorExposed new_value) {return new(new_value);}

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public static unsafe implicit operator _InOpt_ConvCtorExposed(int _1) {return new Const_ConvCtorExposed(_1);}
            }

            /// This is used for optional parameters of class `Mut_ConvCtorExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ConvCtorExposed`/`Const_ConvCtorExposed` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ConvCtorExposed`.
            public class _InOptMut_ConvCtorExposed
            {
                public Mut_ConvCtorExposed? Opt;

                public _InOptMut_ConvCtorExposed() {}
                public _InOptMut_ConvCtorExposed(Mut_ConvCtorExposed value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorExposed(Mut_ConvCtorExposed value) {return new(value);}
                public unsafe _InOptMut_ConvCtorExposed(ref ConvCtorExposed value)
                {
                    fixed (ConvCtorExposed *value_ptr = &value)
                    {
                        Opt = new((Const_ConvCtorExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_ConvCtorExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ConvCtorExposed`/`Const_ConvCtorExposed` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ConvCtorExposed`.
            public class _InOptConst_ConvCtorExposed
            {
                public Const_ConvCtorExposed? Opt;

                public _InOptConst_ConvCtorExposed() {}
                public _InOptConst_ConvCtorExposed(Const_ConvCtorExposed value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorExposed(Const_ConvCtorExposed value) {return new(value);}
                public unsafe _InOptConst_ConvCtorExposed(ref readonly ConvCtorExposed value)
                {
                    fixed (ConvCtorExposed *value_ptr = &value)
                    {
                        Opt = new((Const_ConvCtorExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }

                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                public static unsafe implicit operator _InOptConst_ConvCtorExposed(int _1) {return new Const_ConvCtorExposed(_1);}
            }

            // A sad class that's copyable but not movable.
            // This can often happen if you have a user-provided destructor.
            /// Generated from class `MR::CSharp::ConvCtorCopyButNoMove`.
            /// This is the const half of the class.
            public class Const_ConvCtorCopyButNoMove : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtorCopyButNoMove(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorCopyButNoMove_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorCopyButNoMove_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorCopyButNoMove() {Dispose(false);}

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public unsafe Const_ConvCtorCopyButNoMove(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public unsafe Const_ConvCtorCopyButNoMove(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public static unsafe implicit operator Const_ConvCtorCopyButNoMove(int _1) {return new(_1);}
            }

            // A sad class that's copyable but not movable.
            // This can often happen if you have a user-provided destructor.
            /// Generated from class `MR::CSharp::ConvCtorCopyButNoMove`.
            /// This is the non-const half of the class.
            public class ConvCtorCopyButNoMove : Const_ConvCtorCopyButNoMove
            {
                internal unsafe ConvCtorCopyButNoMove(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public unsafe ConvCtorCopyButNoMove(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public unsafe ConvCtorCopyButNoMove(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public static unsafe implicit operator ConvCtorCopyButNoMove(int _1) {return new(_1);}

                /// Generated from method `MR::CSharp::ConvCtorCopyButNoMove::operator=`.
                public unsafe MR.CS.CSharp.ConvCtorCopyButNoMove assign(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    return new(__MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `ConvCtorCopyButNoMove` by value.
            /// Usage:
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` to copy it into the function.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_ConvCtorCopyButNoMove
            {
                internal readonly Const_ConvCtorCopyButNoMove? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove arg) {return new(arg);}

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public static unsafe implicit operator _ByValue_ConvCtorCopyButNoMove(int _1) {return new MR.CS.CSharp.ConvCtorCopyButNoMove(_1);}
            }

            /// This is used for optional parameters of class `ConvCtorCopyButNoMove` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorCopyButNoMove`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` directly.
            public class _InOptMut_ConvCtorCopyButNoMove
            {
                public ConvCtorCopyButNoMove? Opt;

                public _InOptMut_ConvCtorCopyButNoMove() {}
                public _InOptMut_ConvCtorCopyButNoMove(ConvCtorCopyButNoMove value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorCopyButNoMove(ConvCtorCopyButNoMove value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtorCopyButNoMove` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorCopyButNoMove`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` to pass it to the function.
            public class _InOptConst_ConvCtorCopyButNoMove
            {
                public Const_ConvCtorCopyButNoMove? Opt;

                public _InOptConst_ConvCtorCopyButNoMove() {}
                public _InOptConst_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                public static unsafe implicit operator _InOptConst_ConvCtorCopyButNoMove(int _1) {return new Const_ConvCtorCopyButNoMove(_1);}
            }

            // Test how a trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// Generated from class `MR::CSharp::ConvCtorTrivial`.
            /// This is the const half of the class.
            public class Const_ConvCtorTrivial : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtorTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorTrivial() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ConvCtorTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public unsafe Const_ConvCtorTrivial(MR.CS.CSharp.Const_ConvCtorTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_ConstructFromAnother(MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public unsafe Const_ConvCtorTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public static unsafe implicit operator Const_ConvCtorTrivial(int _1) {return new(_1);}
            }

            // Test how a trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// Generated from class `MR::CSharp::ConvCtorTrivial`.
            /// This is the non-const half of the class.
            public class ConvCtorTrivial : Const_ConvCtorTrivial
            {
                internal unsafe ConvCtorTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe ConvCtorTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public unsafe ConvCtorTrivial(MR.CS.CSharp.Const_ConvCtorTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_ConstructFromAnother(MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public unsafe ConvCtorTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public static unsafe implicit operator ConvCtorTrivial(int _1) {return new(_1);}

                /// Generated from method `MR::CSharp::ConvCtorTrivial::operator=`.
                public unsafe MR.CS.CSharp.ConvCtorTrivial assign(MR.CS.CSharp.Const_ConvCtorTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    return new(__MR_CSharp_ConvCtorTrivial_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// This is used for optional parameters of class `ConvCtorTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorTrivial`/`Const_ConvCtorTrivial` directly.
            public class _InOptMut_ConvCtorTrivial
            {
                public ConvCtorTrivial? Opt;

                public _InOptMut_ConvCtorTrivial() {}
                public _InOptMut_ConvCtorTrivial(ConvCtorTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorTrivial(ConvCtorTrivial value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtorTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorTrivial`/`Const_ConvCtorTrivial` to pass it to the function.
            public class _InOptConst_ConvCtorTrivial
            {
                public Const_ConvCtorTrivial? Opt;

                public _InOptConst_ConvCtorTrivial() {}
                public _InOptConst_ConvCtorTrivial(Const_ConvCtorTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorTrivial(Const_ConvCtorTrivial value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                public static unsafe implicit operator _InOptConst_ConvCtorTrivial(int _1) {return new Const_ConvCtorTrivial(_1);}
            }

            // Test how a non-trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// Generated from class `MR::CSharp::ConvCtorNonTrivial`.
            /// This is the const half of the class.
            public class Const_ConvCtorNonTrivial : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ConvCtorNonTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorNonTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorNonTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorNonTrivial() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ConvCtorNonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public unsafe Const_ConvCtorNonTrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public unsafe Const_ConvCtorNonTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public static unsafe implicit operator Const_ConvCtorNonTrivial(int _1) {return new(_1);}
            }

            // Test how a non-trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// Generated from class `MR::CSharp::ConvCtorNonTrivial`.
            /// This is the non-const half of the class.
            public class ConvCtorNonTrivial : Const_ConvCtorNonTrivial
            {
                internal unsafe ConvCtorNonTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe ConvCtorNonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public unsafe ConvCtorNonTrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public unsafe ConvCtorNonTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_Construct(_1);
                }

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public static unsafe implicit operator ConvCtorNonTrivial(int _1) {return new(_1);}

                /// Generated from method `MR::CSharp::ConvCtorNonTrivial::operator=`.
                public unsafe MR.CS.CSharp.ConvCtorNonTrivial assign(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    return new(__MR_CSharp_ConvCtorNonTrivial_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// This is used as a function parameter when the underlying function receives `ConvCtorNonTrivial` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_ConvCtorNonTrivial
            {
                internal readonly Const_ConvCtorNonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorNonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_ConvCtorNonTrivial(Const_ConvCtorNonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ConvCtorNonTrivial(Const_ConvCtorNonTrivial arg) {return new(arg);}
                public _ByValue_ConvCtorNonTrivial(MR.CS.Misc._Moved<ConvCtorNonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ConvCtorNonTrivial(MR.CS.Misc._Moved<ConvCtorNonTrivial> arg) {return new(arg);}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public static unsafe implicit operator _ByValue_ConvCtorNonTrivial(int _1) {return new MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivial>(_1);}
            }

            /// This is used for optional parameters of class `ConvCtorNonTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorNonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` directly.
            public class _InOptMut_ConvCtorNonTrivial
            {
                public ConvCtorNonTrivial? Opt;

                public _InOptMut_ConvCtorNonTrivial() {}
                public _InOptMut_ConvCtorNonTrivial(ConvCtorNonTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorNonTrivial(ConvCtorNonTrivial value) {return new(value);}
            }

            /// This is used for optional parameters of class `ConvCtorNonTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorNonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` to pass it to the function.
            public class _InOptConst_ConvCtorNonTrivial
            {
                public Const_ConvCtorNonTrivial? Opt;

                public _InOptConst_ConvCtorNonTrivial() {}
                public _InOptConst_ConvCtorNonTrivial(Const_ConvCtorNonTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorNonTrivial(Const_ConvCtorNonTrivial value) {return new(value);}

                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                public static unsafe implicit operator _InOptConst_ConvCtorNonTrivial(int _1) {return new Const_ConvCtorNonTrivial(_1);}
            }

            // Exposed structs:
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the const reference to the struct.
            public class Const_ExposedLayout : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// Get the underlying struct.
                public unsafe ref readonly ExposedLayout _Ref => ref *(ExposedLayout *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_ExposedLayout(ExposedLayout other) : this(new Const_ExposedLayout((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_ExposedLayout` has this conversion, `Mut_ExposedLayout` intentionally doesn't.
                public static implicit operator Const_ExposedLayout(ExposedLayout other) {return new(other);}

                internal unsafe Const_ExposedLayout(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ExposedLayout() {Dispose(false);}

                public ref readonly ushort x => ref _Ref.x;

                // This is field `y`!
                public ref readonly int y => ref _Ref.y;

                public ref readonly double z => ref _Ref.z;

                public ref readonly MR.CS.ArrayInt3 arr => ref _Ref.arr;

                public bool b => _Ref.b;

                public ref readonly MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// Generated default constructor.
                public unsafe Const_ExposedLayout() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// Generated copy constructor.
                public unsafe Const_ExposedLayout(Const_ExposedLayout _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 56);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::bar`.
                public unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_bar(_Underlying *_this);
                    __MR_CSharp_ExposedLayout_bar(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::blah`.
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_blah();
                    __MR_CSharp_ExposedLayout_blah();
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                public static unsafe Mut_ExposedLayout operator++(MR.CS.CSharp.Const_ExposedLayout _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(MR.CS.CSharp.Const_ExposedLayout._Underlying *_this);
                    Mut_ExposedLayout __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                // Test how returning references to an exposed struct works, since C# overloaded operators can't return `ref`.
                // Note that this operator must be `const` to test this correctly, since we turn non-const operators in exposed structs into functions.
                /// Generated from method `MR::CSharp::ExposedLayout::operator*`.
                public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout> operator*(MR.CS.CSharp.Const_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayout_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_mul_MR_CSharp_ExposedLayout_int(MR.CS.CSharp.Const_ExposedLayout._Underlying *_this, int _1);
                    return new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__MR_C_mul_MR_CSharp_ExposedLayout_int(_this._UnderlyingPtr, _1));
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                public static unsafe MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout> operator+(MR.CS.CSharp.Const_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_const_MR_CSharp_ExposedLayout_ref_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int(MR.CS.CSharp.Const_ExposedLayout._Underlying *_this, int _1);
                    return new(__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int(_this._UnderlyingPtr, _1));
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.Const_ExposedLayout _this, MR.CS.CSharp.Const_ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout(MR.CS.CSharp.Const_ExposedLayout._Underlying *_this, MR.CS.CSharp.Const_ExposedLayout._Underlying *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayout(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.Const_ExposedLayout _this, MR.CS.CSharp.Const_ExposedLayout _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.Const_ExposedLayout _this, MR.CS.CSharp.Const_ExposedLayout _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.Const_ExposedLayout _this, MR.CS.CSharp.Const_ExposedLayout _1)
                {
                    return !(_this < _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static unsafe int operator-(int _1, Const_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_sub_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout _2);
                    return __MR_C_sub_int_MR_CSharp_ExposedLayout(_1, _2._Ref);
                }

                /// Generated from function `MR::CSharp::operator%`.
                public static unsafe int operator%(int _1, MR.CS.CSharp.Const_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_mod_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.Const_ExposedLayout._Underlying *_2);
                    return __MR_C_mod_int_MR_CSharp_ExposedLayout(_1, _2._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(_Underlying *_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public static unsafe Mut_ExposedLayout operator--(MR.CS.CSharp.Const_ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.Const_ExposedLayout._Underlying *_1);
                    Mut_ExposedLayout __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }
            }

            // Exposed structs:
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the non-const reference to the struct.
            public class Mut_ExposedLayout : Const_ExposedLayout, System.IEquatable<float>
            {
                /// Get the underlying struct.
                public unsafe new ref ExposedLayout _Ref => ref *(ExposedLayout *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_ExposedLayout(ExposedLayout other) : this(new Const_ExposedLayout((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_ExposedLayout(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new ref ushort x => ref _Ref.x;

                // This is field `y`!
                public new ref int y => ref _Ref.y;

                public new ref double z => ref _Ref.z;

                public new ref MR.CS.ArrayInt3 arr => ref _Ref.arr;

                public new bool b {get => _Ref.b; set => _Ref.b = value;}

                public new ref MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// Generated default constructor.
                public unsafe Mut_ExposedLayout() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// Generated copy constructor.
                public unsafe Mut_ExposedLayout(Const_ExposedLayout _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 56);
                }

                /// Generated copy assignment.
                public void Assign(Const_ExposedLayout _other) {_Ref = _other._Ref;}

                /// Generated from method `MR::CSharp::ExposedLayout::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_foo(_Underlying *_this);
                    __MR_CSharp_ExposedLayout_foo(_UnderlyingPtr);
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(_Underlying *_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Mut_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayout_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayout_ref_int(MR.CS.CSharp.Mut_ExposedLayout._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_ExposedLayout_ref_int(_this._UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Mut_ExposedLayout _this, float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayout_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayout_float(MR.CS.CSharp.Mut_ExposedLayout._Underlying *_this, float _1);
                    return __MR_C_equal_MR_CSharp_ExposedLayout_float(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Mut_ExposedLayout _this, float _1)
                {
                    return !(_this == _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout_char(_Underlying *_this, byte _1);
                    return __MR_C_less_MR_CSharp_ExposedLayout_char(_UnderlyingPtr, _1) != 0;
                }

                /// Generated from function `MR::CSharp::operator/`.
                public static unsafe int operator/(int _1, MR.CS.CSharp.Mut_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_div_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.Mut_ExposedLayout._Underlying *_2);
                    return __MR_C_div_int_MR_CSharp_ExposedLayout(_1, _2._UnderlyingPtr);
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this == (float)other;
                    return false;
                }
            }

            // Exposed structs:
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 56)]
            public struct ExposedLayout : System.IEquatable<float>
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator ExposedLayout(Const_ExposedLayout other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public ushort x;

                // This is field `y`!
                [System.Runtime.InteropServices.FieldOffset(4)]
                public int y;

                [System.Runtime.InteropServices.FieldOffset(8)]
                public double z;

                [System.Runtime.InteropServices.FieldOffset(16)]
                public MR.CS.ArrayInt3 arr;

                public bool b {get => __storage_b != 0; set => __storage_b = value ? (byte)1 : (byte)0;}
                [System.Runtime.InteropServices.FieldOffset(28)]
                byte __storage_b;

                [System.Runtime.InteropServices.FieldOffset(29)]
                public MR.CS.ArrayBool4_5 ba;

                /// Generated copy constructor.
                public ExposedLayout(ExposedLayout _other) {this = _other;}

                /// Generated from method `MR::CSharp::ExposedLayout::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_foo(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayout_foo(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ExposedLayout::bar`.
                public readonly unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_bar(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayout_bar(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ExposedLayout::blah`.
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_blah();
                    __MR_CSharp_ExposedLayout_blah();
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_C_incr_MR_CSharp_ExposedLayout(__ptr__this);
                    }
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                public unsafe ExposedLayout incr(MR.CS.CSharp.ExposedLayout _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(ExposedLayout *_this);
                    ExposedLayout __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(&__this_copy);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                public unsafe int add(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayout_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayout_ref_int(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_add_MR_CSharp_ExposedLayout_ref_int(__ptr__this, _1);
                    }
                }

                // Test how returning references to an exposed struct works, since C# overloaded operators can't return `ref`.
                // Note that this operator must be `const` to test this correctly, since we turn non-const operators in exposed structs into functions.
                /// Generated from method `MR::CSharp::ExposedLayout::operator*`.
                public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout> operator*(MR.CS.CSharp.ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayout_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_mul_MR_CSharp_ExposedLayout_int(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    return new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__MR_C_mul_MR_CSharp_ExposedLayout_int(&_this, _1));
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                public static unsafe MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout> operator+(MR.CS.CSharp.ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_const_MR_CSharp_ExposedLayout_ref_int", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    return new(__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int(&_this, _1));
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *_this, MR.CS.CSharp.ExposedLayout *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayout(&_this, &_1) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this < _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator==`.
                public unsafe bool equal(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayout_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayout_float(MR.CS.CSharp.ExposedLayout *_this, float _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayout_float(__ptr__this, _1) != 0;
                    }
                }

                public unsafe bool notEqual(float _1)
                {
                    return !this.equal(_1);
                }

                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout_char(MR.CS.CSharp.ExposedLayout *_this, byte _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_less_MR_CSharp_ExposedLayout_char(__ptr__this, _1) != 0;
                    }
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static int operator-(int _1, MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_sub_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout _2);
                    return __MR_C_sub_int_MR_CSharp_ExposedLayout(_1, _2);
                }

                /// Generated from function `MR::CSharp::operator/`.
                public static unsafe int div(int _1, ref MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_div_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout *_2);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__2 = &_2)
                    {
                        return __MR_C_div_int_MR_CSharp_ExposedLayout(_1, __ptr__2);
                    }
                }

                /// Generated from function `MR::CSharp::operator%`.
                public static unsafe int operator%(int _1, MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_mod_int_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout *_2);
                    return __MR_C_mod_int_MR_CSharp_ExposedLayout(_1, &_2);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout _1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(this);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public static ExposedLayout operator--(MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout _1);
                    ExposedLayout __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(__this_copy);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this.equal(_1);
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this.Equals((float)other);
                    return false;
                }
            }

            /// This is used as a function parameter when passing `Mut_ExposedLayout` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_ExposedLayout`/`Const_ExposedLayout` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_ExposedLayout
            {
                public readonly bool HasValue;
                internal readonly ExposedLayout Object;
                public ExposedLayout Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayout() {HasValue = false;}
                public _InOpt_ExposedLayout(ExposedLayout new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayout(ExposedLayout new_value) {return new(new_value);}
                public _InOpt_ExposedLayout(Const_ExposedLayout new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayout(Const_ExposedLayout new_value) {return new(new_value);}
            }

            /// This is used for optional parameters of class `Mut_ExposedLayout` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayout`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayout`/`Const_ExposedLayout` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayout`.
            public class _InOptMut_ExposedLayout
            {
                public Mut_ExposedLayout? Opt;

                public _InOptMut_ExposedLayout() {}
                public _InOptMut_ExposedLayout(Mut_ExposedLayout value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayout(Mut_ExposedLayout value) {return new(value);}
                public unsafe _InOptMut_ExposedLayout(ref ExposedLayout value)
                {
                    fixed (ExposedLayout *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayout._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_ExposedLayout` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayout`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayout`/`Const_ExposedLayout` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayout`.
            public class _InOptConst_ExposedLayout
            {
                public Const_ExposedLayout? Opt;

                public _InOptConst_ExposedLayout() {}
                public _InOptConst_ExposedLayout(Const_ExposedLayout value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayout(Const_ExposedLayout value) {return new(value);}
                public unsafe _InOptConst_ExposedLayout(ref readonly ExposedLayout value)
                {
                    fixed (ExposedLayout *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayout._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            // This one is backed by a shared pointer.
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the const reference to the struct.
            public class Const_ExposedLayoutSh : MR.CS.Misc.SharedObject, System.IDisposable, System.IEquatable<MR.CS.CSharp.ExposedLayout>, System.IEquatable<MR.CS.CSharp.Const_ExposedLayoutSh>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get(_UnderlyingSharedPtr);
                    }
                }

                /// Check if the underlying shared pointer is owning or not.
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_UseCount", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_UseCount(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_UseCount(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Get(_UnderlyingSharedPtr) is not null;
                    }
                }

                /// Get the underlying struct.
                public unsafe ref readonly ExposedLayoutSh _Ref => ref *(ExposedLayoutSh *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_ExposedLayoutSh(ExposedLayoutSh other) : this(new Const_ExposedLayoutSh((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_ExposedLayoutSh` has this conversion, `Mut_ExposedLayoutSh` intentionally doesn't.
                public static implicit operator Const_ExposedLayoutSh(ExposedLayoutSh other) {return new(other);}

                internal unsafe Const_ExposedLayoutSh(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning(ptr);
                }

                internal unsafe Const_ExposedLayoutSh(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe Mut_ExposedLayoutSh _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(ptr);
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ExposedLayoutSh() {Dispose(false);}

                public ref readonly ushort x => ref _Ref.x;

                // This is field `y`!
                public ref readonly int y => ref _Ref.y;

                public ref readonly double z => ref _Ref.z;

                public ref readonly MR.CS.ArrayInt3 arr => ref _Ref.arr;

                public bool b => _Ref.b;

                public ref readonly MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// Generated default constructor.
                public unsafe Const_ExposedLayoutSh() : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// Generated copy constructor.
                public unsafe Const_ExposedLayoutSh(Const_ExposedLayoutSh _other) : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 56);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::bar`.
                public unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_bar(_Underlying *_this);
                    __MR_CSharp_ExposedLayoutSh_bar(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::blah`.
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_blah();
                    __MR_CSharp_ExposedLayoutSh_blah();
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                public static unsafe Mut_ExposedLayoutSh operator++(MR.CS.CSharp.Const_ExposedLayoutSh _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_this);
                    Mut_ExposedLayoutSh __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator*`.
                public static unsafe int operator*(MR.CS.CSharp.Const_ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayoutSh_int", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_ExposedLayoutSh_int(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_this, int _1);
                    return __MR_C_mul_MR_CSharp_ExposedLayoutSh_int(_this._UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    return !(_this < _1);
                }

                // While we're at it, test comparison against another exposed struct, since this is apparently non-trivial.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Const_ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.ExposedLayout *_1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__1 = &_1)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(_this._UnderlyingPtr, __ptr__1) != 0;
                    }
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Const_ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this == _1);
                }

                // And against itself, too.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Const_ExposedLayoutSh _this, MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    return !(_this == _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static unsafe int operator-(int _1, Const_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_sub_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh _2);
                    return __MR_C_sub_int_MR_CSharp_ExposedLayoutSh(_1, _2._Ref);
                }

                /// Generated from function `MR::CSharp::operator%`.
                public static unsafe int operator%(int _1, MR.CS.CSharp.Const_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_mod_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_2);
                    return __MR_C_mod_int_MR_CSharp_ExposedLayoutSh(_1, _2._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(_Underlying *_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public static unsafe Mut_ExposedLayoutSh operator--(MR.CS.CSharp.Const_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.Const_ExposedLayoutSh._Underlying *_1);
                    Mut_ExposedLayoutSh __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.ExposedLayout _1)
                {
                    return this == (MR.CS.CSharp.ExposedLayout)_1;
                }

                public bool Equals(MR.CS.CSharp.Const_ExposedLayoutSh? _1)
                {
                    if (_1 is null)
                        return false;
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.ExposedLayout)
                        return this == (MR.CS.CSharp.ExposedLayout)other;
                    if (other is MR.CS.CSharp.Const_ExposedLayoutSh)
                        return this == (MR.CS.CSharp.Const_ExposedLayoutSh)other;
                    return false;
                }
            }

            // This one is backed by a shared pointer.
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the non-const reference to the struct.
            public class Mut_ExposedLayoutSh : Const_ExposedLayoutSh, System.IEquatable<float>
            {
                /// Get the underlying struct.
                public unsafe new ref ExposedLayoutSh _Ref => ref *(ExposedLayoutSh *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_ExposedLayoutSh(ExposedLayoutSh other) : this(new Const_ExposedLayoutSh((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_ExposedLayoutSh(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe Mut_ExposedLayoutSh(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                public new ref ushort x => ref _Ref.x;

                // This is field `y`!
                public new ref int y => ref _Ref.y;

                public new ref double z => ref _Ref.z;

                public new ref MR.CS.ArrayInt3 arr => ref _Ref.arr;

                public new bool b {get => _Ref.b; set => _Ref.b = value;}

                public new ref MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// Generated default constructor.
                public unsafe Mut_ExposedLayoutSh() : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// Generated copy constructor.
                public unsafe Mut_ExposedLayoutSh(Const_ExposedLayoutSh _other) : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 56);
                }

                /// Generated copy assignment.
                public void Assign(Const_ExposedLayoutSh _other) {_Ref = _other._Ref;}

                /// Generated from method `MR::CSharp::ExposedLayoutSh::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_foo(_Underlying *_this);
                    __MR_CSharp_ExposedLayoutSh_foo(_UnderlyingPtr);
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(_Underlying *_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Mut_ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayoutSh_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayoutSh_int(MR.CS.CSharp.Mut_ExposedLayoutSh._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_ExposedLayoutSh_int(_this._UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Mut_ExposedLayoutSh _this, float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(MR.CS.CSharp.Mut_ExposedLayoutSh._Underlying *_this, float _1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Mut_ExposedLayoutSh _this, float _1)
                {
                    return !(_this == _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh_char(_Underlying *_this, byte _1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh_char(_UnderlyingPtr, _1) != 0;
                }

                /// Generated from function `MR::CSharp::operator/`.
                public static unsafe int operator/(int _1, MR.CS.CSharp.Mut_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_div_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.Mut_ExposedLayoutSh._Underlying *_2);
                    return __MR_C_div_int_MR_CSharp_ExposedLayoutSh(_1, _2._UnderlyingPtr);
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this == (float)other;
                    return base.Equals(other);
                }
            }

            // This one is backed by a shared pointer.
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 56)]
            public struct ExposedLayoutSh : System.IEquatable<float>, System.IEquatable<MR.CS.CSharp.ExposedLayout>, System.IEquatable<MR.CS.CSharp.ExposedLayoutSh>
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator ExposedLayoutSh(Const_ExposedLayoutSh other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public ushort x;

                // This is field `y`!
                [System.Runtime.InteropServices.FieldOffset(4)]
                public int y;

                [System.Runtime.InteropServices.FieldOffset(8)]
                public double z;

                [System.Runtime.InteropServices.FieldOffset(16)]
                public MR.CS.ArrayInt3 arr;

                public bool b {get => __storage_b != 0; set => __storage_b = value ? (byte)1 : (byte)0;}
                [System.Runtime.InteropServices.FieldOffset(28)]
                byte __storage_b;

                [System.Runtime.InteropServices.FieldOffset(29)]
                public MR.CS.ArrayBool4_5 ba;

                /// Generated copy constructor.
                public ExposedLayoutSh(ExposedLayoutSh _other) {this = _other;}

                /// Generated from method `MR::CSharp::ExposedLayoutSh::foo`.
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_foo(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayoutSh_foo(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::bar`.
                public readonly unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_bar(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayoutSh_bar(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::blah`.
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_blah();
                    __MR_CSharp_ExposedLayoutSh_blah();
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_C_incr_MR_CSharp_ExposedLayoutSh(__ptr__this);
                    }
                }

                // Try some jank operators.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                public unsafe ExposedLayoutSh incr(MR.CS.CSharp.ExposedLayoutSh _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(ExposedLayoutSh *_this);
                    ExposedLayoutSh __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(&__this_copy);
                    return __this_copy;
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator+`.
                public unsafe int add(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayoutSh_int", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayoutSh_int(MR.CS.CSharp.ExposedLayoutSh *_this, int _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_add_MR_CSharp_ExposedLayoutSh_int(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator*`.
                public static unsafe int operator*(MR.CS.CSharp.ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayoutSh_int", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_ExposedLayoutSh_int(MR.CS.CSharp.ExposedLayoutSh *_this, int _1);
                    return __MR_C_mul_MR_CSharp_ExposedLayoutSh_int(&_this, _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                public static unsafe bool operator<(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayoutSh *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh(&_this, &_1) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_this < _1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public unsafe bool equal(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(MR.CS.CSharp.ExposedLayoutSh *_this, float _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(__ptr__this, _1) != 0;
                    }
                }

                public unsafe bool notEqual(float _1)
                {
                    return !this.equal(_1);
                }

                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh_char(MR.CS.CSharp.ExposedLayoutSh *_this, byte _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_less_MR_CSharp_ExposedLayoutSh_char(__ptr__this, _1) != 0;
                    }
                }

                // While we're at it, test comparison against another exposed struct, since this is apparently non-trivial.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayout *_1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__1 = &_1)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(&_this, __ptr__1) != 0;
                    }
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this == _1);
                }

                // And against itself, too.
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayoutSh *_1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh(&_this, &_1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_this == _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static int operator-(int _1, MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_sub_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh _2);
                    return __MR_C_sub_int_MR_CSharp_ExposedLayoutSh(_1, _2);
                }

                /// Generated from function `MR::CSharp::operator/`.
                public static unsafe int div(int _1, ref MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_div_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh *_2);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__2 = &_2)
                    {
                        return __MR_C_div_int_MR_CSharp_ExposedLayoutSh(_1, __ptr__2);
                    }
                }

                /// Generated from function `MR::CSharp::operator%`.
                public static unsafe int operator%(int _1, MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_mod_int_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh *_2);
                    return __MR_C_mod_int_MR_CSharp_ExposedLayoutSh(_1, &_2);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh _1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(this);
                }

                /// Generated from function `MR::CSharp::operator--`.
                public static ExposedLayoutSh operator--(MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh _1);
                    ExposedLayoutSh __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(__this_copy);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this.equal(_1);
                }

                public bool Equals(MR.CS.CSharp.ExposedLayout _1)
                {
                    return this == (MR.CS.CSharp.ExposedLayout)_1;
                }

                public bool Equals(MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this.Equals((float)other);
                    if (other is MR.CS.CSharp.ExposedLayout)
                        return this == (MR.CS.CSharp.ExposedLayout)other;
                    if (other is MR.CS.CSharp.ExposedLayoutSh)
                        return this == (MR.CS.CSharp.ExposedLayoutSh)other;
                    return false;
                }
            }

            /// This is used as a function parameter when the underlying function receives `Mut_ExposedLayoutSh` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `Mut_ExposedLayoutSh`/`Const_ExposedLayoutSh` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValueShared_ExposedLayoutSh
            {
                internal readonly Const_ExposedLayoutSh? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_ExposedLayoutSh() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_ExposedLayoutSh(Const_ExposedLayoutSh new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_ExposedLayoutSh(Const_ExposedLayoutSh arg) {return new(arg);}
                public _ByValueShared_ExposedLayoutSh(MR.CS.Misc._Moved<Mut_ExposedLayoutSh> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_ExposedLayoutSh(MR.CS.Misc._Moved<Mut_ExposedLayoutSh> arg) {return new(arg);}
            }

            /// This is used as a function parameter when passing `Mut_ExposedLayoutSh` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_ExposedLayoutSh`/`Const_ExposedLayoutSh` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_ExposedLayoutSh
            {
                public readonly bool HasValue;
                internal readonly ExposedLayoutSh Object;
                public ExposedLayoutSh Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayoutSh() {HasValue = false;}
                public _InOpt_ExposedLayoutSh(ExposedLayoutSh new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayoutSh(ExposedLayoutSh new_value) {return new(new_value);}
                public _InOpt_ExposedLayoutSh(Const_ExposedLayoutSh new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayoutSh(Const_ExposedLayoutSh new_value) {return new(new_value);}
            }

            /// This is used for optional parameters of class `Mut_ExposedLayoutSh` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayoutSh`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayoutSh`/`Const_ExposedLayoutSh` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutSh`.
            public class _InOptMut_ExposedLayoutSh
            {
                public Mut_ExposedLayoutSh? Opt;

                public _InOptMut_ExposedLayoutSh() {}
                public _InOptMut_ExposedLayoutSh(Mut_ExposedLayoutSh value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayoutSh(Mut_ExposedLayoutSh value) {return new(value);}
                public unsafe _InOptMut_ExposedLayoutSh(ref ExposedLayoutSh value)
                {
                    fixed (ExposedLayoutSh *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayoutSh._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_ExposedLayoutSh` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayoutSh`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayoutSh`/`Const_ExposedLayoutSh` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutSh`.
            public class _InOptConst_ExposedLayoutSh
            {
                public Const_ExposedLayoutSh? Opt;

                public _InOptConst_ExposedLayoutSh() {}
                public _InOptConst_ExposedLayoutSh(Const_ExposedLayoutSh value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayoutSh(Const_ExposedLayoutSh value) {return new(value);}
                public unsafe _InOptConst_ExposedLayoutSh(ref readonly ExposedLayoutSh value)
                {
                    fixed (ExposedLayoutSh *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayoutSh._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the const reference to the struct.
            public class Const_ExposedLayoutB : MR.CS.Misc.Object, System.IDisposable, System.IEquatable<MR.CS.CSharp.Const_ExposedLayoutB>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// Get the underlying struct.
                public unsafe ref readonly ExposedLayoutB _Ref => ref *(ExposedLayoutB *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_ExposedLayoutB(ExposedLayoutB other) : this(new Const_ExposedLayoutB((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_ExposedLayoutB` has this conversion, `Mut_ExposedLayoutB` intentionally doesn't.
                public static implicit operator Const_ExposedLayoutB(ExposedLayoutB other) {return new(other);}

                internal unsafe Const_ExposedLayoutB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ExposedLayoutB() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// Generated copy constructor.
                public unsafe Const_ExposedLayoutB(Const_ExposedLayoutB _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                // Some random ctor.
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                public unsafe Const_ExposedLayoutB(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct(int _1, int _2);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    MR.CS.CSharp.ExposedLayoutB _ctor_result = __MR_CSharp_ExposedLayoutB_Construct(_1, _2);
                    System.Runtime.InteropServices.NativeMemory.Copy(&_ctor_result, _UnderlyingPtr, 4);
                }

                // And try an equality comparison!
                /// Generated from function `MR::CSharp::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.Const_ExposedLayoutB _1, MR.CS.CSharp.Const_ExposedLayoutB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutB", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutB(MR.CS.CSharp.Const_ExposedLayoutB._Underlying *_1, MR.CS.CSharp.Const_ExposedLayoutB._Underlying *_2);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutB(_1._UnderlyingPtr, _2._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Const_ExposedLayoutB _1, MR.CS.CSharp.Const_ExposedLayoutB _2)
                {
                    return !(_1 == _2);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.Const_ExposedLayoutB? _2)
                {
                    if (_2 is null)
                        return false;
                    return this == _2;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.Const_ExposedLayoutB)
                        return this == (MR.CS.CSharp.Const_ExposedLayoutB)other;
                    return false;
                }
            }

            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the non-const reference to the struct.
            public class Mut_ExposedLayoutB : Const_ExposedLayoutB
            {
                /// Get the underlying struct.
                public unsafe new ref ExposedLayoutB _Ref => ref *(ExposedLayoutB *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_ExposedLayoutB(ExposedLayoutB other) : this(new Const_ExposedLayoutB((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_ExposedLayoutB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new ref int x => ref _Ref.x;

                /// Generated copy constructor.
                public unsafe Mut_ExposedLayoutB(Const_ExposedLayoutB _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                /// Generated copy assignment.
                public void Assign(Const_ExposedLayoutB _other) {_Ref = _other._Ref;}

                // Some random ctor.
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                public unsafe Mut_ExposedLayoutB(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct(int _1, int _2);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    MR.CS.CSharp.ExposedLayoutB _ctor_result = __MR_CSharp_ExposedLayoutB_Construct(_1, _2);
                    System.Runtime.InteropServices.NativeMemory.Copy(&_ctor_result, _UnderlyingPtr, 4);
                }
            }

            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ExposedLayoutB : System.IEquatable<MR.CS.CSharp.ExposedLayoutB>
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator ExposedLayoutB(Const_ExposedLayoutB other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// Generated copy constructor.
                public ExposedLayoutB(ExposedLayoutB _other) {this = _other;}

                // Some random ctor.
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                public unsafe ExposedLayoutB(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct(int _1, int _2);
                    this = __MR_CSharp_ExposedLayoutB_Construct(_1, _2);
                }

                // And try an equality comparison!
                /// Generated from function `MR::CSharp::operator==`.
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutB _1, MR.CS.CSharp.ExposedLayoutB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutB", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutB(MR.CS.CSharp.ExposedLayoutB *_1, MR.CS.CSharp.ExposedLayoutB *_2);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutB(&_1, &_2) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutB _1, MR.CS.CSharp.ExposedLayoutB _2)
                {
                    return !(_1 == _2);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.ExposedLayoutB _2)
                {
                    return this == _2;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.ExposedLayoutB)
                        return this == (MR.CS.CSharp.ExposedLayoutB)other;
                    return false;
                }
            }

            /// This is used as a function parameter when passing `Mut_ExposedLayoutB` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_ExposedLayoutB`/`Const_ExposedLayoutB` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_ExposedLayoutB
            {
                public readonly bool HasValue;
                internal readonly ExposedLayoutB Object;
                public ExposedLayoutB Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayoutB() {HasValue = false;}
                public _InOpt_ExposedLayoutB(ExposedLayoutB new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayoutB(ExposedLayoutB new_value) {return new(new_value);}
                public _InOpt_ExposedLayoutB(Const_ExposedLayoutB new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayoutB(Const_ExposedLayoutB new_value) {return new(new_value);}
            }

            /// This is used for optional parameters of class `Mut_ExposedLayoutB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayoutB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayoutB`/`Const_ExposedLayoutB` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutB`.
            public class _InOptMut_ExposedLayoutB
            {
                public Mut_ExposedLayoutB? Opt;

                public _InOptMut_ExposedLayoutB() {}
                public _InOptMut_ExposedLayoutB(Mut_ExposedLayoutB value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayoutB(Mut_ExposedLayoutB value) {return new(value);}
                public unsafe _InOptMut_ExposedLayoutB(ref ExposedLayoutB value)
                {
                    fixed (ExposedLayoutB *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayoutB._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_ExposedLayoutB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayoutB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ExposedLayoutB`/`Const_ExposedLayoutB` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutB`.
            public class _InOptConst_ExposedLayoutB
            {
                public Const_ExposedLayoutB? Opt;

                public _InOptConst_ExposedLayoutB() {}
                public _InOptConst_ExposedLayoutB(Const_ExposedLayoutB value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayoutB(Const_ExposedLayoutB value) {return new(value);}
                public unsafe _InOptConst_ExposedLayoutB(ref readonly ExposedLayoutB value)
                {
                    fixed (ExposedLayoutB *value_ptr = &value)
                    {
                        Opt = new((Const_ExposedLayoutB._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            // Test various array members.
            /// Generated from class `MR::CSharp::ArrayMembers`.
            /// This is the const half of the class.
            public class Const_ArrayMembers : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ArrayMembers(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ArrayMembers_Destroy(_Underlying *_this);
                    __MR_CSharp_ArrayMembers_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ArrayMembers() {Dispose(false);}

                public unsafe int i
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_ArrayMembers_Get_i(_Underlying *_this);
                        return *__MR_CSharp_ArrayMembers_Get_i(_UnderlyingPtr);
                    }
                }

                public unsafe ref MR.CS.ArrayInt2 ia
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ia", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt2 *__MR_CSharp_ArrayMembers_Get_ia(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_Get_ia(_UnderlyingPtr));
                    }
                }

                public unsafe ref MR.CS.ArrayInt3_4 iaa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_iaa", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt3_4 *__MR_CSharp_ArrayMembers_Get_iaa(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_Get_iaa(_UnderlyingPtr));
                    }
                }

                public unsafe int ci
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ci", ExactSpelling = true)]
                        extern static int *__MR_CSharp_ArrayMembers_Get_ci(_Underlying *_this);
                        return *__MR_CSharp_ArrayMembers_Get_ci(_UnderlyingPtr);
                    }
                }

                public unsafe ref readonly MR.CS.ConstArrayInt2 cia
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_cia", ExactSpelling = true)]
                        extern static MR.CS.ConstArrayInt2 *__MR_CSharp_ArrayMembers_Get_cia(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_Get_cia(_UnderlyingPtr));
                    }
                }

                public unsafe ref readonly MR.CS.ConstArrayInt3_4 ciaa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ciaa", ExactSpelling = true)]
                        extern static MR.CS.ConstArrayInt3_4 *__MR_CSharp_ArrayMembers_Get_ciaa(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_Get_ciaa(_UnderlyingPtr));
                    }
                }

                public unsafe MR.CS.Std.Const_String s
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_s(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_Get_s(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.Std.ArrayString2 sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_Get_sa(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_Get_sa(_UnderlyingPtr));
                    }
                }

                // std::string saa[3][4]; // The C generator doesn't support those yet. We'd need to expose them as flat arrays, with N size getters, I think?
                public unsafe MR.CS.Std.Const_String cs
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_cs", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_cs(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_Get_cs(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.Std.ConstArrayString2 csa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_csa", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_csa(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_Get_csa(_UnderlyingPtr));
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_ArrayMembers() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                public unsafe Const_ArrayMembers(MR.CS.CSharp._ByValue_ArrayMembers _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ArrayMembers._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            // Test various array members.
            /// Generated from class `MR::CSharp::ArrayMembers`.
            /// This is the non-const half of the class.
            public class ArrayMembers : Const_ArrayMembers
            {
                internal unsafe ArrayMembers(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe ref int i
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_ArrayMembers_GetMutable_i(_Underlying *_this);
                        return ref *__MR_CSharp_ArrayMembers_GetMutable_i(_UnderlyingPtr);
                    }
                }

                new public unsafe ref MR.CS.ArrayInt2 ia
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_ia", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt2 *__MR_CSharp_ArrayMembers_GetMutable_ia(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_GetMutable_ia(_UnderlyingPtr));
                    }
                }

                new public unsafe ref MR.CS.ArrayInt3_4 iaa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_iaa", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt3_4 *__MR_CSharp_ArrayMembers_GetMutable_iaa(_Underlying *_this);
                        return ref *(__MR_CSharp_ArrayMembers_GetMutable_iaa(_UnderlyingPtr));
                    }
                }

                public new unsafe MR.CS.Std.String s
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_GetMutable_s(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_GetMutable_s(_UnderlyingPtr), is_owning: false);
                    }
                }

                new public unsafe MR.CS.Std.ArrayString2 sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_sa", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_GetMutable_sa(_Underlying *_this);
                        return new(__MR_CSharp_ArrayMembers_GetMutable_sa(_UnderlyingPtr));
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe ArrayMembers() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                public unsafe ArrayMembers(MR.CS.CSharp._ByValue_ArrayMembers _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ArrayMembers._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }
            }

            /// This is used as a function parameter when the underlying function receives `ArrayMembers` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            public class _ByValue_ArrayMembers
            {
                internal readonly Const_ArrayMembers? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ArrayMembers() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_ArrayMembers(Const_ArrayMembers new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ArrayMembers(Const_ArrayMembers arg) {return new(arg);}
                public _ByValue_ArrayMembers(MR.CS.Misc._Moved<ArrayMembers> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ArrayMembers(MR.CS.Misc._Moved<ArrayMembers> arg) {return new(arg);}
            }

            /// This is used for optional parameters of class `ArrayMembers` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ArrayMembers`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` directly.
            public class _InOptMut_ArrayMembers
            {
                public ArrayMembers? Opt;

                public _InOptMut_ArrayMembers() {}
                public _InOptMut_ArrayMembers(ArrayMembers value) {Opt = value;}
                public static implicit operator _InOptMut_ArrayMembers(ArrayMembers value) {return new(value);}
            }

            /// This is used for optional parameters of class `ArrayMembers` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ArrayMembers`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` to pass it to the function.
            public class _InOptConst_ArrayMembers
            {
                public Const_ArrayMembers? Opt;

                public _InOptConst_ArrayMembers() {}
                public _InOptConst_ArrayMembers(Const_ArrayMembers value) {Opt = value;}
                public static implicit operator _InOptConst_ArrayMembers(Const_ArrayMembers value) {return new(value);}
            }

            // Members having the same name as the exposed class, after rewriting.
            /// Generated from class `MR::CSharp::NameConflicts`.
            /// This is the const half of the class.
            public class Const_NameConflicts : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_NameConflicts(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflicts_Destroy(_Underlying *_this);
                    __MR_CSharp_NameConflicts_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NameConflicts() {Dispose(false);}

                public unsafe int nameConflicts
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Get_name_conflicts", ExactSpelling = true)]
                        extern static int *__MR_CSharp_NameConflicts_Get_name_conflicts(_Underlying *_this);
                        return *__MR_CSharp_NameConflicts_Get_name_conflicts(_UnderlyingPtr);
                    }
                }

                public unsafe MR.CS.CSharp.NameConflicts.Const_A a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.Const_A._Underlying *__MR_CSharp_NameConflicts_Get_a(_Underlying *_this);
                        return new(__MR_CSharp_NameConflicts_Get_a(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_NameConflicts() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::NameConflicts` elementwise.
                public unsafe Const_NameConflicts(int name_conflicts, MR.CS.CSharp.NameConflicts.Const_A a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFrom(int name_conflicts, MR.CS.CSharp.NameConflicts.A._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFrom(name_conflicts, a._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                public unsafe Const_NameConflicts(MR.CS.CSharp.Const_NameConflicts _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFromAnother(MR.CS.CSharp.NameConflicts._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from class `MR::CSharp::NameConflicts::A`.
                /// This is the const half of the class.
                public class Const_A : MR.CS.Misc.Object, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    internal unsafe Const_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_NameConflicts_A_Destroy(_Underlying *_this);
                        __MR_CSharp_NameConflicts_A_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_A() {Dispose(false);}

                    /// Constructs an empty (default-constructed) instance.
                    public unsafe Const_A() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_DefaultConstruct();
                    }

                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    public unsafe Const_A(MR.CS.CSharp.NameConflicts.Const_A _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_ConstructFromAnother(MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_ConstructFromAnother(_other._UnderlyingPtr);
                    }
                }

                /// Generated from class `MR::CSharp::NameConflicts::A`.
                /// This is the non-const half of the class.
                public class A : Const_A
                {
                    internal unsafe A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    /// Constructs an empty (default-constructed) instance.
                    public unsafe A() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_DefaultConstruct();
                    }

                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    public unsafe A(MR.CS.CSharp.NameConflicts.Const_A _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_ConstructFromAnother(MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_ConstructFromAnother(_other._UnderlyingPtr);
                    }

                    /// Generated from method `MR::CSharp::NameConflicts::A::operator=`.
                    public unsafe MR.CS.CSharp.NameConflicts.A assign(MR.CS.CSharp.NameConflicts.Const_A _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        return new(__MR_CSharp_NameConflicts_A_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }
                }

                /// This is used for optional parameters of class `A` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `A`/`Const_A` directly.
                public class _InOptMut_A
                {
                    public A? Opt;

                    public _InOptMut_A() {}
                    public _InOptMut_A(A value) {Opt = value;}
                    public static implicit operator _InOptMut_A(A value) {return new(value);}
                }

                /// This is used for optional parameters of class `A` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `A`/`Const_A` to pass it to the function.
                public class _InOptConst_A
                {
                    public Const_A? Opt;

                    public _InOptConst_A() {}
                    public _InOptConst_A(Const_A value) {Opt = value;}
                    public static implicit operator _InOptConst_A(Const_A value) {return new(value);}
                }
            }

            // Members having the same name as the exposed class, after rewriting.
            /// Generated from class `MR::CSharp::NameConflicts`.
            /// This is the non-const half of the class.
            public class NameConflicts : Const_NameConflicts
            {
                internal unsafe NameConflicts(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe ref int nameConflicts
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_GetMutable_name_conflicts", ExactSpelling = true)]
                        extern static int *__MR_CSharp_NameConflicts_GetMutable_name_conflicts(_Underlying *_this);
                        return ref *__MR_CSharp_NameConflicts_GetMutable_name_conflicts(_UnderlyingPtr);
                    }
                }

                public new unsafe MR.CS.CSharp.NameConflicts.A a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_GetMutable_a(_Underlying *_this);
                        return new(__MR_CSharp_NameConflicts_GetMutable_a(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Constructs an empty (default-constructed) instance.
                public unsafe NameConflicts() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_DefaultConstruct();
                }

                /// Constructs `MR::CSharp::NameConflicts` elementwise.
                public unsafe NameConflicts(int name_conflicts, MR.CS.CSharp.NameConflicts.Const_A a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFrom(int name_conflicts, MR.CS.CSharp.NameConflicts.A._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFrom(name_conflicts, a._UnderlyingPtr);
                }

                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                public unsafe NameConflicts(MR.CS.CSharp.Const_NameConflicts _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFromAnother(MR.CS.CSharp.NameConflicts._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::NameConflicts::operator=`.
                public unsafe MR.CS.CSharp.NameConflicts assign(MR.CS.CSharp.Const_NameConflicts _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NameConflicts._Underlying *_other);
                    return new(__MR_CSharp_NameConflicts_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::NameConflicts::name_Conflicts`.
                public unsafe void nameConflicts_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_name_Conflicts", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflicts_name_Conflicts(_Underlying *_this);
                    __MR_CSharp_NameConflicts_name_Conflicts(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `NameConflicts` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NameConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NameConflicts`/`Const_NameConflicts` directly.
            public class _InOptMut_NameConflicts
            {
                public NameConflicts? Opt;

                public _InOptMut_NameConflicts() {}
                public _InOptMut_NameConflicts(NameConflicts value) {Opt = value;}
                public static implicit operator _InOptMut_NameConflicts(NameConflicts value) {return new(value);}
            }

            /// This is used for optional parameters of class `NameConflicts` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NameConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NameConflicts`/`Const_NameConflicts` to pass it to the function.
            public class _InOptConst_NameConflicts
            {
                public Const_NameConflicts? Opt;

                public _InOptConst_NameConflicts() {}
                public _InOptConst_NameConflicts(Const_NameConflicts value) {Opt = value;}
                public static implicit operator _InOptConst_NameConflicts(Const_NameConflicts value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the const reference to the struct.
            public class Const_NameConflictsExposed : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// Get the underlying struct.
                public unsafe ref readonly NameConflictsExposed _Ref => ref *(NameConflictsExposed *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_NameConflictsExposed(NameConflictsExposed other) : this(new Const_NameConflictsExposed((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_NameConflictsExposed` has this conversion, `Mut_NameConflictsExposed` intentionally doesn't.
                public static implicit operator Const_NameConflictsExposed(NameConflictsExposed other) {return new(other);}

                internal unsafe Const_NameConflictsExposed(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NameConflictsExposed() {Dispose(false);}

                public ref readonly int nameConflictsExposed => ref _Ref.nameConflictsExposed;

                public ref readonly MR.CS.CSharp.NameConflictsExposed.A a => ref _Ref.a;

                /// Generated default constructor.
                public unsafe Const_NameConflictsExposed() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 8, 0);
                }

                /// Generated copy constructor.
                public unsafe Const_NameConflictsExposed(Const_NameConflictsExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 8);
                }
            }

            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the non-const reference to the struct.
            public class Mut_NameConflictsExposed : Const_NameConflictsExposed
            {
                /// Get the underlying struct.
                public unsafe new ref NameConflictsExposed _Ref => ref *(NameConflictsExposed *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_NameConflictsExposed(NameConflictsExposed other) : this(new Const_NameConflictsExposed((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_NameConflictsExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new ref int nameConflictsExposed => ref _Ref.nameConflictsExposed;

                public new ref MR.CS.CSharp.NameConflictsExposed.A a => ref _Ref.a;

                /// Generated default constructor.
                public unsafe Mut_NameConflictsExposed() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 8, 0);
                }

                /// Generated copy constructor.
                public unsafe Mut_NameConflictsExposed(Const_NameConflictsExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 8);
                }

                /// Generated copy assignment.
                public void Assign(Const_NameConflictsExposed _other) {_Ref = _other._Ref;}

                /// Generated from method `MR::CSharp::NameConflictsExposed::name_Conflicts_exposed`.
                public unsafe void nameConflictsExposed_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflictsExposed_name_Conflicts_exposed", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(_Underlying *_this);
                    __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(_UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 8)]
            public struct NameConflictsExposed
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator NameConflictsExposed(Const_NameConflictsExposed other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public int nameConflictsExposed;

                [System.Runtime.InteropServices.FieldOffset(4)]
                public MR.CS.CSharp.NameConflictsExposed.A a;

                /// Generated copy constructor.
                public NameConflictsExposed(NameConflictsExposed _other) {this = _other;}

                /// Generated from method `MR::CSharp::NameConflictsExposed::name_Conflicts_exposed`.
                public unsafe void nameConflictsExposed_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflictsExposed_name_Conflicts_exposed", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(MR.CS.CSharp.NameConflictsExposed *_this);
                    fixed (MR.CS.CSharp.NameConflictsExposed *__ptr__this = &this)
                    {
                        __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(__ptr__this);
                    }
                }

                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the const reference to the struct.
                public class Const_A : MR.CS.Misc.Object, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    /// Get the underlying struct.
                    public unsafe ref readonly A _Ref => ref *(A *)_UnderlyingPtr;
                    /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                    public unsafe Const_A(A other) : this(new Const_A((_Underlying *)&other, is_owning: false)) {}
                    /// Convert from a struct by copying it. Note that only `Const_A` has this conversion, `Mut_A` intentionally doesn't.
                    public static implicit operator Const_A(A other) {return new(other);}

                    internal unsafe Const_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        MR.CS.Misc._Free((void *)_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_A() {Dispose(false);}

                    public ref readonly int x => ref _Ref.x;

                    /// Generated default constructor.
                    public unsafe Const_A() : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                    }

                    /// Generated copy constructor.
                    public unsafe Const_A(Const_A _other) : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                    }
                }

                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the non-const reference to the struct.
                public class Mut_A : Const_A
                {
                    /// Get the underlying struct.
                    public unsafe new ref A _Ref => ref *(A *)_UnderlyingPtr;
                    /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                    public unsafe Mut_A(A other) : this(new Const_A((_Underlying *)&other, is_owning: false)) {}

                    internal unsafe Mut_A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    public new ref int x => ref _Ref.x;

                    /// Generated default constructor.
                    public unsafe Mut_A() : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                    }

                    /// Generated copy constructor.
                    public unsafe Mut_A(Const_A _other) : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                    }

                    /// Generated copy assignment.
                    public void Assign(Const_A _other) {_Ref = _other._Ref;}
                }

                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the by-value version of the struct.
                [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
                public struct A
                {
                    /// Copy contents from a wrapper class to this struct.
                    public static implicit operator A(Const_A other) => other._Ref;

                    [System.Runtime.InteropServices.FieldOffset(0)]
                    public int x;

                    /// Generated copy constructor.
                    public A(A _other) {this = _other;}
                }

                /// This is used as a function parameter when passing `Mut_A` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
                /// Usage:
                /// * Pass an instance of `Mut_A`/`Const_A` to copy it into the function.
                /// * Pass `null` to use the default argument
                public readonly ref struct _InOpt_A
                {
                    public readonly bool HasValue;
                    internal readonly A Object;
                    public A Value{
                        get
                        {
                            System.Diagnostics.Trace.Assert(HasValue);
                            return Object;
                        }
                    }

                    public _InOpt_A() {HasValue = false;}
                    public _InOpt_A(A new_value) {HasValue = true; Object = new_value;}
                    public static implicit operator _InOpt_A(A new_value) {return new(new_value);}
                    public _InOpt_A(Const_A new_value) {HasValue = true; Object = new_value._Ref;}
                    public static implicit operator _InOpt_A(Const_A new_value) {return new(new_value);}
                }

                /// This is used for optional parameters of class `Mut_A` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Mut_A`/`Const_A` directly.
                /// * Pass `new(ref ...)` to pass a reference to `A`.
                public class _InOptMut_A
                {
                    public Mut_A? Opt;

                    public _InOptMut_A() {}
                    public _InOptMut_A(Mut_A value) {Opt = value;}
                    public static implicit operator _InOptMut_A(Mut_A value) {return new(value);}
                    public unsafe _InOptMut_A(ref A value)
                    {
                        fixed (A *value_ptr = &value)
                        {
                            Opt = new((Const_A._Underlying *)value_ptr, is_owning: false);
                        }
                    }
                }

                /// This is used for optional parameters of class `Mut_A` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Mut_A`/`Const_A` to pass it to the function.
                /// * Pass `new(ref ...)` to pass a reference to `A`.
                public class _InOptConst_A
                {
                    public Const_A? Opt;

                    public _InOptConst_A() {}
                    public _InOptConst_A(Const_A value) {Opt = value;}
                    public static implicit operator _InOptConst_A(Const_A value) {return new(value);}
                    public unsafe _InOptConst_A(ref readonly A value)
                    {
                        fixed (A *value_ptr = &value)
                        {
                            Opt = new((Const_A._Underlying *)value_ptr, is_owning: false);
                        }
                    }
                }
            }

            /// This is used as a function parameter when passing `Mut_NameConflictsExposed` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_NameConflictsExposed`/`Const_NameConflictsExposed` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_NameConflictsExposed
            {
                public readonly bool HasValue;
                internal readonly NameConflictsExposed Object;
                public NameConflictsExposed Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_NameConflictsExposed() {HasValue = false;}
                public _InOpt_NameConflictsExposed(NameConflictsExposed new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_NameConflictsExposed(NameConflictsExposed new_value) {return new(new_value);}
                public _InOpt_NameConflictsExposed(Const_NameConflictsExposed new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_NameConflictsExposed(Const_NameConflictsExposed new_value) {return new(new_value);}
            }

            /// This is used for optional parameters of class `Mut_NameConflictsExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NameConflictsExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_NameConflictsExposed`/`Const_NameConflictsExposed` directly.
            /// * Pass `new(ref ...)` to pass a reference to `NameConflictsExposed`.
            public class _InOptMut_NameConflictsExposed
            {
                public Mut_NameConflictsExposed? Opt;

                public _InOptMut_NameConflictsExposed() {}
                public _InOptMut_NameConflictsExposed(Mut_NameConflictsExposed value) {Opt = value;}
                public static implicit operator _InOptMut_NameConflictsExposed(Mut_NameConflictsExposed value) {return new(value);}
                public unsafe _InOptMut_NameConflictsExposed(ref NameConflictsExposed value)
                {
                    fixed (NameConflictsExposed *value_ptr = &value)
                    {
                        Opt = new((Const_NameConflictsExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_NameConflictsExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NameConflictsExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_NameConflictsExposed`/`Const_NameConflictsExposed` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `NameConflictsExposed`.
            public class _InOptConst_NameConflictsExposed
            {
                public Const_NameConflictsExposed? Opt;

                public _InOptConst_NameConflictsExposed() {}
                public _InOptConst_NameConflictsExposed(Const_NameConflictsExposed value) {Opt = value;}
                public static implicit operator _InOptConst_NameConflictsExposed(Const_NameConflictsExposed value) {return new(value);}
                public unsafe _InOptConst_NameConflictsExposed(ref readonly NameConflictsExposed value)
                {
                    fixed (NameConflictsExposed *value_ptr = &value)
                    {
                        Opt = new((Const_NameConflictsExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// Generated from class `MR::CSharp::AmbiguousTemplates`.
            /// This is the const half of the class.
            public class Const_AmbiguousTemplates : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_AmbiguousTemplates(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_Destroy(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_AmbiguousTemplates() {Dispose(false);}

                /// Constructs an empty (default-constructed) instance.
                public unsafe Const_AmbiguousTemplates() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                public unsafe Const_AmbiguousTemplates(MR.CS.CSharp.Const_AmbiguousTemplates _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_ConstructFromAnother(MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_ConstructFromAnother(_other._UnderlyingPtr);
                }
            }

            /// Generated from class `MR::CSharp::AmbiguousTemplates`.
            /// This is the non-const half of the class.
            public class AmbiguousTemplates : Const_AmbiguousTemplates
            {
                internal unsafe AmbiguousTemplates(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// Constructs an empty (default-constructed) instance.
                public unsafe AmbiguousTemplates() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                }

                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                public unsafe AmbiguousTemplates(MR.CS.CSharp.Const_AmbiguousTemplates _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_ConstructFromAnother(MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::operator=`.
                public unsafe MR.CS.CSharp.AmbiguousTemplates assign(MR.CS.CSharp.Const_AmbiguousTemplates _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    return new(__MR_CSharp_AmbiguousTemplates_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_a<int>`.
                public unsafe void templateA(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_a_int", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_a_int(_Underlying *_this, int _1);
                    __MR_CSharp_AmbiguousTemplates_template_a_int(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_a<float>`.
                public unsafe void templateA(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_a_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_a_float(_Underlying *_this, float _1);
                    __MR_CSharp_AmbiguousTemplates_template_a_float(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_b<int>`.
                public unsafe int templateB_Int()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_b_int", ExactSpelling = true)]
                    extern static int __MR_CSharp_AmbiguousTemplates_template_b_int(_Underlying *_this);
                    return __MR_CSharp_AmbiguousTemplates_template_b_int(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_b<float>`.
                public unsafe float templateB_Float()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_b_float", ExactSpelling = true)]
                    extern static float __MR_CSharp_AmbiguousTemplates_template_b_float(_Underlying *_this);
                    return __MR_CSharp_AmbiguousTemplates_template_b_float(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_c<int>`.
                public unsafe void templateC_Int()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_c_int", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_c_int(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_template_c_int(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_c<float>`.
                public unsafe void templateC_Float()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_c_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_c_float(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_template_c_float(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::AmbiguousTemplates::instantiate`.
                public unsafe void instantiate()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_instantiate", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_instantiate(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_instantiate(_UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `AmbiguousTemplates` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_AmbiguousTemplates`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `AmbiguousTemplates`/`Const_AmbiguousTemplates` directly.
            public class _InOptMut_AmbiguousTemplates
            {
                public AmbiguousTemplates? Opt;

                public _InOptMut_AmbiguousTemplates() {}
                public _InOptMut_AmbiguousTemplates(AmbiguousTemplates value) {Opt = value;}
                public static implicit operator _InOptMut_AmbiguousTemplates(AmbiguousTemplates value) {return new(value);}
            }

            /// This is used for optional parameters of class `AmbiguousTemplates` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_AmbiguousTemplates`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `AmbiguousTemplates`/`Const_AmbiguousTemplates` to pass it to the function.
            public class _InOptConst_AmbiguousTemplates
            {
                public Const_AmbiguousTemplates? Opt;

                public _InOptConst_AmbiguousTemplates() {}
                public _InOptConst_AmbiguousTemplates(Const_AmbiguousTemplates value) {Opt = value;}
                public static implicit operator _InOptConst_AmbiguousTemplates(Const_AmbiguousTemplates value) {return new(value);}
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the const reference to the struct.
            public class Const_ConstNonconstConflicts : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// Get the underlying struct.
                public unsafe ref readonly ConstNonconstConflicts _Ref => ref *(ConstNonconstConflicts *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Const_ConstNonconstConflicts(ConstNonconstConflicts other) : this(new Const_ConstNonconstConflicts((_Underlying *)&other, is_owning: false)) {}
                /// Convert from a struct by copying it. Note that only `Const_ConstNonconstConflicts` has this conversion, `Mut_ConstNonconstConflicts` intentionally doesn't.
                public static implicit operator Const_ConstNonconstConflicts(ConstNonconstConflicts other) {return new(other);}

                internal unsafe Const_ConstNonconstConflicts(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConstNonconstConflicts() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// Generated default constructor.
                public unsafe Const_ConstNonconstConflicts() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                }

                /// Generated copy constructor.
                public unsafe Const_ConstNonconstConflicts(Const_ConstNonconstConflicts _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe void foo(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_const_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_const_float(_Underlying *_this, float _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_const_float(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_const_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_const_char(_Underlying *_this, byte _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_const_char(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Const_ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Const_ConstNonconstConflicts._Underlying *_this);
                    return __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(_this._UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_this);
                    __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                public static unsafe int operator/(MR.CS.CSharp.Const_ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int(MR.CS.CSharp.Const_ConstNonconstConflicts._Underlying *_this, int _1);
                    return __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int(_this._UnderlyingPtr, _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.Const_ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Const_ConstNonconstConflicts._Underlying *_1);
                    return __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(_1._UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator!`.
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_1);
                    __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator&`.
                public static unsafe int operator&(int _1, MR.CS.CSharp.Const_ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.Const_ConstNonconstConflicts._Underlying *_2);
                    return __MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref(_1, _2._UnderlyingPtr);
                }
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the non-const reference to the struct.
            public class Mut_ConstNonconstConflicts : Const_ConstNonconstConflicts
            {
                /// Get the underlying struct.
                public unsafe new ref ConstNonconstConflicts _Ref => ref *(ConstNonconstConflicts *)_UnderlyingPtr;
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                public unsafe Mut_ConstNonconstConflicts(ConstNonconstConflicts other) : this(new Const_ConstNonconstConflicts((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Mut_ConstNonconstConflicts(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new ref int x => ref _Ref.x;

                /// Generated default constructor.
                public unsafe Mut_ConstNonconstConflicts() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                }

                /// Generated copy constructor.
                public unsafe Mut_ConstNonconstConflicts(Const_ConstNonconstConflicts _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Copy(_other._UnderlyingPtr, _UnderlyingPtr, 4);
                }

                /// Generated copy assignment.
                public void Assign(Const_ConstNonconstConflicts _other) {_Ref = _other._Ref;}

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe void foo(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_int", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_int(_Underlying *_this, int _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_int(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe new void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_char(_Underlying *_this, byte _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_char(_UnderlyingPtr, _1);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.Mut_ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Mut_ConstNonconstConflicts._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(_this._UnderlyingPtr);
                }

                // Since this returns void, it gets rewritten into a method.
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                public unsafe new void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_this);
                    __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                public static unsafe int operator/(MR.CS.CSharp.Mut_ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int(MR.CS.CSharp.Mut_ConstNonconstConflicts._Underlying *_this, int _1);
                    return __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int(_this._UnderlyingPtr, _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.Mut_ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Mut_ConstNonconstConflicts._Underlying *_1);
                    return __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(_1._UnderlyingPtr);
                }

                // Since this returns void, it gets rewritten into a method.
                /// Generated from function `MR::CSharp::operator!`.
                public unsafe new void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_1);
                    __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// Generated from function `MR::CSharp::operator&`.
                public static unsafe int operator&(int _1, MR.CS.CSharp.Mut_ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.Mut_ConstNonconstConflicts._Underlying *_2);
                    return __MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref(_1, _2._UnderlyingPtr);
                }
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the by-value version of the struct.
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ConstNonconstConflicts
            {
                /// Copy contents from a wrapper class to this struct.
                public static implicit operator ConstNonconstConflicts(Const_ConstNonconstConflicts other) => other._Ref;

                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// Generated copy constructor.
                public ConstNonconstConflicts(ConstNonconstConflicts _other) {this = _other;}

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe void foo(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_int", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_int(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_int(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public readonly unsafe void foo(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_const_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_const_float(MR.CS.CSharp.ConstNonconstConflicts *_this, float _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_const_float(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public unsafe void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_char(MR.CS.CSharp.ConstNonconstConflicts *_this, byte _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_char(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                public readonly unsafe void foo_Const(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_const_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_const_char(MR.CS.CSharp.ConstNonconstConflicts *_this, byte _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_const_char(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                public unsafe int add()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        return __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                public static unsafe int operator+(MR.CS.CSharp.ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    return __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(&_this);
                }

                // Since this returns void, it gets rewritten into a method.
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                public readonly unsafe void compl_Const()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                public unsafe int div(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        return __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int(__ptr__this, _1);
                    }
                }

                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                public static unsafe int operator/(MR.CS.CSharp.ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int", ExactSpelling = true)]
                    extern static int __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    return __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int(&_this, _1);
                }

                /// Generated from function `MR::CSharp::operator-`.
                public unsafe int sub()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        return __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// Generated from function `MR::CSharp::operator-`.
                public static unsafe int operator-(MR.CS.CSharp.ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    return __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(&_1);
                }

                // Since this returns void, it gets rewritten into a method.
                /// Generated from function `MR::CSharp::operator!`.
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// Generated from function `MR::CSharp::operator!`.
                public readonly unsafe void not_Const()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// Generated from function `MR::CSharp::operator&`.
                public static unsafe int bitand(int _1, ref MR.CS.CSharp.ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.ConstNonconstConflicts *_2);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__2 = &_2)
                    {
                        return __MR_C_bitand_int_MR_CSharp_ConstNonconstConflicts_ref(_1, __ptr__2);
                    }
                }

                /// Generated from function `MR::CSharp::operator&`.
                public static unsafe int operator&(int _1, MR.CS.CSharp.ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.ConstNonconstConflicts *_2);
                    return __MR_C_bitand_int_const_MR_CSharp_ConstNonconstConflicts_ref(_1, &_2);
                }
            }

            /// This is used as a function parameter when passing `Mut_ConstNonconstConflicts` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Mut_ConstNonconstConflicts`/`Const_ConstNonconstConflicts` to copy it into the function.
            /// * Pass `null` to use the default argument
            public readonly ref struct _InOpt_ConstNonconstConflicts
            {
                public readonly bool HasValue;
                internal readonly ConstNonconstConflicts Object;
                public ConstNonconstConflicts Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ConstNonconstConflicts() {HasValue = false;}
                public _InOpt_ConstNonconstConflicts(ConstNonconstConflicts new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ConstNonconstConflicts(ConstNonconstConflicts new_value) {return new(new_value);}
                public _InOpt_ConstNonconstConflicts(Const_ConstNonconstConflicts new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ConstNonconstConflicts(Const_ConstNonconstConflicts new_value) {return new(new_value);}
            }

            /// This is used for optional parameters of class `Mut_ConstNonconstConflicts` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConstNonconstConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ConstNonconstConflicts`/`Const_ConstNonconstConflicts` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ConstNonconstConflicts`.
            public class _InOptMut_ConstNonconstConflicts
            {
                public Mut_ConstNonconstConflicts? Opt;

                public _InOptMut_ConstNonconstConflicts() {}
                public _InOptMut_ConstNonconstConflicts(Mut_ConstNonconstConflicts value) {Opt = value;}
                public static implicit operator _InOptMut_ConstNonconstConflicts(Mut_ConstNonconstConflicts value) {return new(value);}
                public unsafe _InOptMut_ConstNonconstConflicts(ref ConstNonconstConflicts value)
                {
                    fixed (ConstNonconstConflicts *value_ptr = &value)
                    {
                        Opt = new((Const_ConstNonconstConflicts._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// This is used for optional parameters of class `Mut_ConstNonconstConflicts` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConstNonconstConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Mut_ConstNonconstConflicts`/`Const_ConstNonconstConflicts` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ConstNonconstConflicts`.
            public class _InOptConst_ConstNonconstConflicts
            {
                public Const_ConstNonconstConflicts? Opt;

                public _InOptConst_ConstNonconstConflicts() {}
                public _InOptConst_ConstNonconstConflicts(Const_ConstNonconstConflicts value) {Opt = value;}
                public static implicit operator _InOptConst_ConstNonconstConflicts(Const_ConstNonconstConflicts value) {return new(value);}
                public unsafe _InOptConst_ConstNonconstConflicts(ref readonly ConstNonconstConflicts value)
                {
                    fixed (ConstNonconstConflicts *value_ptr = &value)
                    {
                        Opt = new((Const_ConstNonconstConflicts._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            // Class fields of pointer types:
            /// Generated from class `MR::CSharp::ClassMemberPointersClass`.
            /// This is the const half of the class.
            public class Const_ClassMemberPointersClass : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ClassMemberPointersClass(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersClass_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersClass_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersClass() {Dispose(false);}

                public static unsafe MR.CS.CSharp.A? Sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_sa();
                        var ptr = __MR_CSharp_ClassMemberPointersClass_Get_sa();
                        return *ptr is not null ? new MR.CS.CSharp.A(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sa`, to keep the target object alive.
                public static MR.CS.CSharp.A? _Storage_Sa = null;

                public static unsafe MR.CS.CSharp.Const_A? Sb
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sb", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_sb();
                        var ptr = __MR_CSharp_ClassMemberPointersClass_Get_sb();
                        return *ptr is not null ? new MR.CS.CSharp.Const_A(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sb`, to keep the target object alive.
                public static MR.CS.CSharp.Const_A? _Storage_Sb = null;

                public static unsafe MR.CS.CSharp.A Sc
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sc", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_sc();
                        return new(__MR_CSharp_ClassMemberPointersClass_Get_sc(), is_owning: false);
                    }
                }

                public static unsafe MR.CS.CSharp.Const_A Sd
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sd", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_sd();
                        return new(__MR_CSharp_ClassMemberPointersClass_Get_sd(), is_owning: false);
                    }
                }

                public unsafe MR.CS.CSharp.A? a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_a(Const_ClassMemberPointersClass._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersClass_Get_a(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.CSharp.A(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `a`, to keep the target object alive.
                public MR.CS.CSharp.A? _Storage_a = null;

                public unsafe MR.CS.CSharp.Const_A? b
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_b(Const_ClassMemberPointersClass._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersClass_Get_b(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.CSharp.Const_A(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `b`, to keep the target object alive.
                public MR.CS.CSharp.Const_A? _Storage_b = null;

                public unsafe MR.CS.CSharp.A c
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_c", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_c(_Underlying *_this);
                        return new(__MR_CSharp_ClassMemberPointersClass_Get_c(_UnderlyingPtr), is_owning: false);
                    }
                }

                public unsafe MR.CS.CSharp.Const_A d
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_d", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_d(_Underlying *_this);
                        return new(__MR_CSharp_ClassMemberPointersClass_Get_d(_UnderlyingPtr), is_owning: false);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                public unsafe Const_ClassMemberPointersClass(MR.CS.CSharp.Const_ClassMemberPointersClass _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersClass._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersClass` elementwise.
                public unsafe Const_ClassMemberPointersClass(MR.CS.CSharp.A? a, MR.CS.CSharp.Const_A? b, MR.CS.CSharp.A c, MR.CS.CSharp.Const_A d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFrom(MR.CS.CSharp.A._Underlying *a, MR.CS.CSharp.Const_A._Underlying *b, MR.CS.CSharp.A._Underlying *c, MR.CS.CSharp.Const_A._Underlying *d);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFrom(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c._UnderlyingPtr, d._UnderlyingPtr);
                }
            }

            // Class fields of pointer types:
            /// Generated from class `MR::CSharp::ClassMemberPointersClass`.
            /// This is the non-const half of the class.
            public class ClassMemberPointersClass : Const_ClassMemberPointersClass
            {
                internal unsafe ClassMemberPointersClass(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe MR.CS.CSharp.A? a
                {
                    get => base.a;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying **__MR_CSharp_ClassMemberPointersClass_GetMutable_a(ClassMemberPointersClass._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersClass_GetMutable_a(_UnderlyingPtr);
                        _Storage_a = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.CSharp.Const_A? b
                {
                    get => base.b;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_GetMutable_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying **__MR_CSharp_ClassMemberPointersClass_GetMutable_b(ClassMemberPointersClass._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersClass_GetMutable_b(_UnderlyingPtr);
                        _Storage_b = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                public unsafe ClassMemberPointersClass(MR.CS.CSharp.Const_ClassMemberPointersClass _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersClass._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersClass` elementwise.
                public unsafe ClassMemberPointersClass(MR.CS.CSharp.A? a, MR.CS.CSharp.Const_A? b, MR.CS.CSharp.A c, MR.CS.CSharp.Const_A d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFrom(MR.CS.CSharp.A._Underlying *a, MR.CS.CSharp.Const_A._Underlying *b, MR.CS.CSharp.A._Underlying *c, MR.CS.CSharp.Const_A._Underlying *d);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFrom(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c._UnderlyingPtr, d._UnderlyingPtr);
                }
            }

            /// This is used for optional parameters of class `ClassMemberPointersClass` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersClass`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersClass`/`Const_ClassMemberPointersClass` directly.
            public class _InOptMut_ClassMemberPointersClass
            {
                public ClassMemberPointersClass? Opt;

                public _InOptMut_ClassMemberPointersClass() {}
                public _InOptMut_ClassMemberPointersClass(ClassMemberPointersClass value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersClass(ClassMemberPointersClass value) {return new(value);}
            }

            /// This is used for optional parameters of class `ClassMemberPointersClass` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersClass`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersClass`/`Const_ClassMemberPointersClass` to pass it to the function.
            public class _InOptConst_ClassMemberPointersClass
            {
                public Const_ClassMemberPointersClass? Opt;

                public _InOptConst_ClassMemberPointersClass() {}
                public _InOptConst_ClassMemberPointersClass(Const_ClassMemberPointersClass value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersClass(Const_ClassMemberPointersClass value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersExposed`.
            /// This is the const half of the class.
            public class Const_ClassMemberPointersExposed : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ClassMemberPointersExposed(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersExposed_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersExposed_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersExposed() {Dispose(false);}

                public static unsafe MR.CS.CSharp.Mut_ExposedLayout? Sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Mut_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_sa();
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_Get_sa();
                        return *ptr is not null ? new MR.CS.CSharp.Mut_ExposedLayout(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sa`, to keep the target object alive.
                public static MR.CS.CSharp.Mut_ExposedLayout? _Storage_Sa = null;

                public static unsafe MR.CS.CSharp.Const_ExposedLayout? Sb
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sb", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_sb();
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_Get_sb();
                        return *ptr is not null ? new MR.CS.CSharp.Const_ExposedLayout(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sb`, to keep the target object alive.
                public static MR.CS.CSharp.Const_ExposedLayout? _Storage_Sb = null;

                public static unsafe ref MR.CS.CSharp.ExposedLayout Sc
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sc", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_sc();
                        return ref *__MR_CSharp_ClassMemberPointersExposed_Get_sc();
                    }
                }

                public static unsafe ref readonly MR.CS.CSharp.ExposedLayout Sd
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sd", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_sd();
                        return ref *__MR_CSharp_ClassMemberPointersExposed_Get_sd();
                    }
                }

                public unsafe MR.CS.CSharp.Mut_ExposedLayout? a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Mut_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_a(Const_ClassMemberPointersExposed._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_Get_a(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.CSharp.Mut_ExposedLayout(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `a`, to keep the target object alive.
                public MR.CS.CSharp.Mut_ExposedLayout? _Storage_a = null;

                public unsafe MR.CS.CSharp.Const_ExposedLayout? b
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_b(Const_ClassMemberPointersExposed._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_Get_b(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.CSharp.Const_ExposedLayout(*ptr, is_owning: false) : null;
                    }
                }
                /// This holds the last value manually assigned to property `b`, to keep the target object alive.
                public MR.CS.CSharp.Const_ExposedLayout? _Storage_b = null;

                public unsafe ref MR.CS.CSharp.ExposedLayout c
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_c", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_c(_Underlying *_this);
                        return ref *__MR_CSharp_ClassMemberPointersExposed_Get_c(_UnderlyingPtr);
                    }
                }

                public unsafe ref readonly MR.CS.CSharp.ExposedLayout d
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_d", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_d(_Underlying *_this);
                        return ref *__MR_CSharp_ClassMemberPointersExposed_Get_d(_UnderlyingPtr);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                public unsafe Const_ClassMemberPointersExposed(MR.CS.CSharp.Const_ClassMemberPointersExposed _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersExposed._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersExposed` elementwise.
                public unsafe Const_ClassMemberPointersExposed(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.CSharp.ExposedLayout? b, ref MR.CS.CSharp.ExposedLayout c, in MR.CS.CSharp.ExposedLayout d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFrom(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout *c, MR.CS.CSharp.ExposedLayout *d);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr_c = &c)
                    {
                        fixed (MR.CS.CSharp.ExposedLayout *__ptr_d = &d)
                        {
                            MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                            MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                            _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, __ptr_d);
                            if (a is not null) a.Value = __value_a;
                        }
                    }
                }
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersExposed`.
            /// This is the non-const half of the class.
            public class ClassMemberPointersExposed : Const_ClassMemberPointersExposed
            {
                internal unsafe ClassMemberPointersExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe MR.CS.CSharp.Mut_ExposedLayout? a
                {
                    get => base.a;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Mut_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_GetMutable_a(ClassMemberPointersExposed._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_GetMutable_a(_UnderlyingPtr);
                        _Storage_a = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.CSharp.Const_ExposedLayout? b
                {
                    get => base.b;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_GetMutable_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_GetMutable_b(ClassMemberPointersExposed._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersExposed_GetMutable_b(_UnderlyingPtr);
                        _Storage_b = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                public unsafe ClassMemberPointersExposed(MR.CS.CSharp.Const_ClassMemberPointersExposed _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersExposed._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersExposed` elementwise.
                public unsafe ClassMemberPointersExposed(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.CSharp.ExposedLayout? b, ref MR.CS.CSharp.ExposedLayout c, in MR.CS.CSharp.ExposedLayout d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFrom(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout *c, MR.CS.CSharp.ExposedLayout *d);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr_c = &c)
                    {
                        fixed (MR.CS.CSharp.ExposedLayout *__ptr_d = &d)
                        {
                            MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                            MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                            _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, __ptr_d);
                            if (a is not null) a.Value = __value_a;
                        }
                    }
                }
            }

            /// This is used for optional parameters of class `ClassMemberPointersExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersExposed`/`Const_ClassMemberPointersExposed` directly.
            public class _InOptMut_ClassMemberPointersExposed
            {
                public ClassMemberPointersExposed? Opt;

                public _InOptMut_ClassMemberPointersExposed() {}
                public _InOptMut_ClassMemberPointersExposed(ClassMemberPointersExposed value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersExposed(ClassMemberPointersExposed value) {return new(value);}
            }

            /// This is used for optional parameters of class `ClassMemberPointersExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersExposed`/`Const_ClassMemberPointersExposed` to pass it to the function.
            public class _InOptConst_ClassMemberPointersExposed
            {
                public Const_ClassMemberPointersExposed? Opt;

                public _InOptConst_ClassMemberPointersExposed() {}
                public _InOptConst_ClassMemberPointersExposed(Const_ClassMemberPointersExposed value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersExposed(Const_ClassMemberPointersExposed value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersUshort`.
            /// This is the const half of the class.
            public class Const_ClassMemberPointersUshort : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ClassMemberPointersUshort(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersUshort_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersUshort_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersUshort() {Dispose(false);}

                public static unsafe MR.CS.Misc.Box<ushort>? Sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sa", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_sa();
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_Get_sa();
                        return *ptr is not null ? new MR.CS.Misc.Box<ushort>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sa`, to keep the target object alive.
                public static MR.CS.Misc.Box<ushort>? _Storage_Sa = null;

                public static unsafe MR.CS.Misc.Const_Box<ushort>? Sb
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sb", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_sb();
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_Get_sb();
                        return *ptr is not null ? new MR.CS.Misc.Const_Box<ushort>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sb`, to keep the target object alive.
                public static MR.CS.Misc.Const_Box<ushort>? _Storage_Sb = null;

                public static unsafe ref ushort Sc
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sc", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_sc();
                        return ref *__MR_CSharp_ClassMemberPointersUshort_Get_sc();
                    }
                }

                public static unsafe ushort Sd
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sd", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_sd();
                        return *__MR_CSharp_ClassMemberPointersUshort_Get_sd();
                    }
                }

                public unsafe MR.CS.Misc.Box<ushort>? a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_a", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_a(Const_ClassMemberPointersUshort._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_Get_a(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.Misc.Box<ushort>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `a`, to keep the target object alive.
                public MR.CS.Misc.Box<ushort>? _Storage_a = null;

                public unsafe MR.CS.Misc.Const_Box<ushort>? b
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_b", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_b(Const_ClassMemberPointersUshort._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_Get_b(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.Misc.Const_Box<ushort>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `b`, to keep the target object alive.
                public MR.CS.Misc.Const_Box<ushort>? _Storage_b = null;

                public unsafe ref ushort c
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_c", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_c(_Underlying *_this);
                        return ref *__MR_CSharp_ClassMemberPointersUshort_Get_c(_UnderlyingPtr);
                    }
                }

                public unsafe ushort d
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_d", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_d(_Underlying *_this);
                        return *__MR_CSharp_ClassMemberPointersUshort_Get_d(_UnderlyingPtr);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                public unsafe Const_ClassMemberPointersUshort(MR.CS.CSharp.Const_ClassMemberPointersUshort _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersUshort._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersUshort` elementwise.
                public unsafe Const_ClassMemberPointersUshort(MR.CS.Misc.InOut<ushort>? a, ushort? b, ref ushort c, ushort d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFrom(ushort *a, ushort *b, ushort *c, ushort *d);
                    fixed (ushort *__ptr_c = &c)
                    {
                        ushort __value_a = a is not null ? a.Value : default(ushort);
                        ushort __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                    }
                }
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersUshort`.
            /// This is the non-const half of the class.
            public class ClassMemberPointersUshort : Const_ClassMemberPointersUshort
            {
                internal unsafe ClassMemberPointersUshort(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe MR.CS.Misc.Box<ushort>? a
                {
                    get => base.a;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_GetMutable_a", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_GetMutable_a(ClassMemberPointersUshort._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_GetMutable_a(_UnderlyingPtr);
                        _Storage_a = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.Misc.Const_Box<ushort>? b
                {
                    get => base.b;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_GetMutable_b", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_GetMutable_b(ClassMemberPointersUshort._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersUshort_GetMutable_b(_UnderlyingPtr);
                        _Storage_b = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                public unsafe ClassMemberPointersUshort(MR.CS.CSharp.Const_ClassMemberPointersUshort _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersUshort._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersUshort` elementwise.
                public unsafe ClassMemberPointersUshort(MR.CS.Misc.InOut<ushort>? a, ushort? b, ref ushort c, ushort d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFrom(ushort *a, ushort *b, ushort *c, ushort *d);
                    fixed (ushort *__ptr_c = &c)
                    {
                        ushort __value_a = a is not null ? a.Value : default(ushort);
                        ushort __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                    }
                }
            }

            /// This is used for optional parameters of class `ClassMemberPointersUshort` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersUshort`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersUshort`/`Const_ClassMemberPointersUshort` directly.
            public class _InOptMut_ClassMemberPointersUshort
            {
                public ClassMemberPointersUshort? Opt;

                public _InOptMut_ClassMemberPointersUshort() {}
                public _InOptMut_ClassMemberPointersUshort(ClassMemberPointersUshort value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersUshort(ClassMemberPointersUshort value) {return new(value);}
            }

            /// This is used for optional parameters of class `ClassMemberPointersUshort` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersUshort`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersUshort`/`Const_ClassMemberPointersUshort` to pass it to the function.
            public class _InOptConst_ClassMemberPointersUshort
            {
                public Const_ClassMemberPointersUshort? Opt;

                public _InOptConst_ClassMemberPointersUshort() {}
                public _InOptConst_ClassMemberPointersUshort(Const_ClassMemberPointersUshort value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersUshort(Const_ClassMemberPointersUshort value) {return new(value);}
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersBool`.
            /// This is the const half of the class.
            public class Const_ClassMemberPointersBool : MR.CS.Misc.Object, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                internal unsafe Const_ClassMemberPointersBool(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersBool_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersBool_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersBool() {Dispose(false);}

                public static unsafe MR.CS.Misc.Box<byte>? Sa
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sa", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_sa();
                        var ptr = __MR_CSharp_ClassMemberPointersBool_Get_sa();
                        return *ptr is not null ? new MR.CS.Misc.Box<byte>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sa`, to keep the target object alive.
                public static MR.CS.Misc.Box<byte>? _Storage_Sa = null;

                public static unsafe MR.CS.Misc.Const_Box<byte>? Sb
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sb", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_sb();
                        var ptr = __MR_CSharp_ClassMemberPointersBool_Get_sb();
                        return *ptr is not null ? new MR.CS.Misc.Const_Box<byte>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `Sb`, to keep the target object alive.
                public static MR.CS.Misc.Const_Box<byte>? _Storage_Sb = null;

                public static unsafe ref bool Sc
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sc", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_sc();
                        return ref *__MR_CSharp_ClassMemberPointersBool_Get_sc();
                    }
                }

                public static unsafe bool Sd
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sd", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_sd();
                        return *__MR_CSharp_ClassMemberPointersBool_Get_sd();
                    }
                }

                public unsafe MR.CS.Misc.Box<byte>? a
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_a", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_a(Const_ClassMemberPointersBool._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersBool_Get_a(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.Misc.Box<byte>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `a`, to keep the target object alive.
                public MR.CS.Misc.Box<byte>? _Storage_a = null;

                public unsafe MR.CS.Misc.Const_Box<byte>? b
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_b", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_b(Const_ClassMemberPointersBool._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersBool_Get_b(_UnderlyingPtr);
                        return *ptr is not null ? new MR.CS.Misc.Const_Box<byte>(*ptr) : null;
                    }
                }
                /// This holds the last value manually assigned to property `b`, to keep the target object alive.
                public MR.CS.Misc.Const_Box<byte>? _Storage_b = null;

                public unsafe ref bool c
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_c", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_c(_Underlying *_this);
                        return ref *__MR_CSharp_ClassMemberPointersBool_Get_c(_UnderlyingPtr);
                    }
                }

                public unsafe bool d
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_d", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_d(_Underlying *_this);
                        return *__MR_CSharp_ClassMemberPointersBool_Get_d(_UnderlyingPtr);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                public unsafe Const_ClassMemberPointersBool(MR.CS.CSharp.Const_ClassMemberPointersBool _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersBool._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersBool` elementwise.
                public unsafe Const_ClassMemberPointersBool(MR.CS.Misc.InOut<bool>? a, bool? b, ref bool c, bool d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFrom(bool *a, bool *b, bool *c, bool *d);
                    fixed (bool *__ptr_c = &c)
                    {
                        bool __value_a = a is not null ? a.Value : default(bool);
                        bool __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                    }
                }
            }

            /// Generated from class `MR::CSharp::ClassMemberPointersBool`.
            /// This is the non-const half of the class.
            public class ClassMemberPointersBool : Const_ClassMemberPointersBool
            {
                internal unsafe ClassMemberPointersBool(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                public new unsafe MR.CS.Misc.Box<byte>? a
                {
                    get => base.a;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_GetMutable_a", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_GetMutable_a(ClassMemberPointersBool._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersBool_GetMutable_a(_UnderlyingPtr);
                        _Storage_a = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.Misc.Const_Box<byte>? b
                {
                    get => base.b;
                    set
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_GetMutable_b", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_GetMutable_b(ClassMemberPointersBool._Underlying *_this);
                        var ptr = __MR_CSharp_ClassMemberPointersBool_GetMutable_b(_UnderlyingPtr);
                        _Storage_b = value;
                        *ptr = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                public unsafe ClassMemberPointersBool(MR.CS.CSharp.Const_ClassMemberPointersBool _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersBool._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(_other._UnderlyingPtr);
                }

                /// Constructs `MR::CSharp::ClassMemberPointersBool` elementwise.
                public unsafe ClassMemberPointersBool(MR.CS.Misc.InOut<bool>? a, bool? b, ref bool c, bool d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFrom(bool *a, bool *b, bool *c, bool *d);
                    fixed (bool *__ptr_c = &c)
                    {
                        bool __value_a = a is not null ? a.Value : default(bool);
                        bool __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                    }
                }
            }

            /// This is used for optional parameters of class `ClassMemberPointersBool` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersBool`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersBool`/`Const_ClassMemberPointersBool` directly.
            public class _InOptMut_ClassMemberPointersBool
            {
                public ClassMemberPointersBool? Opt;

                public _InOptMut_ClassMemberPointersBool() {}
                public _InOptMut_ClassMemberPointersBool(ClassMemberPointersBool value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersBool(ClassMemberPointersBool value) {return new(value);}
            }

            /// This is used for optional parameters of class `ClassMemberPointersBool` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersBool`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersBool`/`Const_ClassMemberPointersBool` to pass it to the function.
            public class _InOptConst_ClassMemberPointersBool
            {
                public Const_ClassMemberPointersBool? Opt;

                public _InOptConst_ClassMemberPointersBool() {}
                public _InOptConst_ClassMemberPointersBool(Const_ClassMemberPointersBool value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersBool(Const_ClassMemberPointersBool value) {return new(value);}
            }

            /// Generated from function `MR::CSharp::foo`.
            public static void foo()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_foo", ExactSpelling = true)]
                extern static void __MR_CSharp_foo();
                __MR_CSharp_foo();
            }

            /// Generated from function `MR::CSharp::test_int`.
            /// Parameter `b` defaults to `42`.
            public static unsafe int testInt(int a, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int", ExactSpelling = true)]
                extern static int __MR_CSharp_test_int(int a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_int(a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_bool`.
            /// Parameter `b` defaults to `true`.
            public static unsafe bool testBool(bool a, bool? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool", ExactSpelling = true)]
                extern static byte __MR_CSharp_test_bool(byte a, byte *b);
                byte __deref_b = b.GetValueOrDefault() ? (byte)1 : (byte)0;
                return __MR_CSharp_test_bool(a ? (byte)1 : (byte)0, b.HasValue ? &__deref_b : null) != 0;
            }

            /// Generated from function `MR::CSharp::test_bool_ref`.
            /// Parameter `b` defaults to `default_bool`.
            public static unsafe void testBoolRef(ref bool a, MR.CS.Misc.InOut<bool>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_ref", ExactSpelling = true)]
                extern static void __MR_CSharp_test_bool_ref(bool *a, bool *b);
                fixed (bool *__ptr_a = &a)
                {
                    bool __value_b = b is not null ? b.Value : default(bool);
                    __MR_CSharp_test_bool_ref(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                }
            }

            /// Generated from function `MR::CSharp::test_bool_ref2`.
            /// Parameter `b` defaults to `default_bool`.
            public static unsafe int testBoolRef2(ref bool a, MR.CS.Misc.InOut<bool>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_ref2", ExactSpelling = true)]
                extern static int __MR_CSharp_test_bool_ref2(bool *a, bool *b);
                fixed (bool *__ptr_a = &a)
                {
                    bool __value_b = b is not null ? b.Value : default(bool);
                    var __ret = __MR_CSharp_test_bool_ref2(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return __ret;
                }
            }

            /// Generated from function `MR::CSharp::get_bool_ref`.
            public static unsafe ref bool getBoolRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_bool_ref", ExactSpelling = true)]
                extern static bool *__MR_CSharp_get_bool_ref();
                return ref *__MR_CSharp_get_bool_ref();
            }

            /// Generated from function `MR::CSharp::print_bool_ref`.
            public static void printBoolRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_print_bool_ref", ExactSpelling = true)]
                extern static void __MR_CSharp_print_bool_ref();
                __MR_CSharp_print_bool_ref();
            }

            /// Generated from function `MR::CSharp::test_bool_cref`.
            /// Parameter `_2` defaults to `default_bool`.
            public static unsafe bool testBoolCref(bool _1, bool? _2 = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_cref", ExactSpelling = true)]
                extern static bool *__MR_CSharp_test_bool_cref(bool *_1, bool *_2);
                bool __deref__2 = _2.GetValueOrDefault();
                return *__MR_CSharp_test_bool_cref(&_1, _2.HasValue ? &__deref__2 : null);
            }

            /// Generated from function `MR::CSharp::test_int_ref`.
            /// Parameter `b` defaults to `default_int`.
            public static unsafe ref int testIntRef(ref int a, MR.CS.Misc.InOut<int>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_ref(int *a, int *b);
                fixed (int *__ptr_a = &a)
                {
                    int __value_b = b is not null ? b.Value : default(int);
                    var __ret = __MR_CSharp_test_int_ref(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_int_cref`.
            /// Parameter `b` defaults to `default_int`.
            public static unsafe int testIntCref(int a, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_cref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_cref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_cref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_int_rref`.
            /// Parameter `b` defaults to `42`.
            public static unsafe int testIntRref(MR.CS.Misc._MoveRef _move_a, int a, MR.CS.Misc._MoveRef _move_b = default, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_rref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_rref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_rref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_int_crref`.
            /// Parameter `b` defaults to `42`.
            public static unsafe int testIntCrref(MR.CS.Misc._MoveRef _move_a, int a, MR.CS.Misc._MoveRef _move_b = default, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_crref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_crref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_crref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_int_ptr`.
            /// Parameter `c` defaults to `&default_int`.
            public static unsafe MR.CS.Misc.Ref<int>? testIntPtr(MR.CS.Misc.InOut<int>? a, MR.CS.Misc.InOut<int>? b = null, MR.CS.Misc._InOutOpt<int>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_ptr", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_ptr(int *a, int *b, int **c);
                int __value_a = a is not null ? a.Value : default(int);
                int __value_b = b is not null ? b.Value : default(int);
                int __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(int);
                int *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_int_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<int>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_int_cptr`.
            /// Parameter `c` defaults to `&default_int`.
            public static unsafe int? testIntCptr(int? a, int? b = null, MR.CS.Misc._InOpt<int>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_cptr", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_cptr(int *a, int *b, int **c);
                int __deref_a = a.GetValueOrDefault();
                int __deref_b = b.GetValueOrDefault();
                int __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(int);
                int *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_int_cptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __ret is not null ? *__ret : null;
            }

            /// Generated from function `MR::CSharp::test_ushort`.
            /// Parameter `b` defaults to `42`.
            public static unsafe ushort testUshort(ushort a, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort", ExactSpelling = true)]
                extern static ushort __MR_CSharp_test_ushort(ushort a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_ushort(a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_ushort_ref`.
            /// Parameter `b` defaults to `default_ushort`.
            public static unsafe ref ushort testUshortRef(ref ushort a, MR.CS.Misc.InOut<ushort>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_ref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_ref(ushort *a, ushort *b);
                fixed (ushort *__ptr_a = &a)
                {
                    ushort __value_b = b is not null ? b.Value : default(ushort);
                    var __ret = __MR_CSharp_test_ushort_ref(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_ushort_cref`.
            /// Parameter `b` defaults to `default_ushort`.
            public static unsafe ushort testUshortCref(ushort a, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_cref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_cref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_cref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_ushort_rref`.
            /// Parameter `b` defaults to `(unsigned short&&)default_ushort`.
            public static unsafe ushort testUshortRref(MR.CS.Misc._MoveRef _move_a, ushort a, MR.CS.Misc._MoveRef _move_b = default, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_rref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_rref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_rref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_ushort_crref`.
            /// Parameter `b` defaults to `(unsigned short&&)default_ushort`.
            public static unsafe ushort testUshortCrref(MR.CS.Misc._MoveRef _move_a, ushort a, MR.CS.Misc._MoveRef _move_b = default, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_crref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_crref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_crref(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_ushort_ptr`.
            /// Parameter `c` defaults to `&default_ushort`.
            public static unsafe MR.CS.Misc.Ref<ushort>? testUshortPtr(MR.CS.Misc.InOut<ushort>? a, MR.CS.Misc.InOut<ushort>? b = null, MR.CS.Misc._InOutOpt<ushort>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_ptr", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_ptr(ushort *a, ushort *b, ushort **c);
                ushort __value_a = a is not null ? a.Value : default(ushort);
                ushort __value_b = b is not null ? b.Value : default(ushort);
                ushort __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(ushort);
                ushort *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_ushort_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<ushort>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_ushort_cptr`.
            /// Parameter `c` defaults to `&default_ushort`.
            public static unsafe ushort? testUshortCptr(ushort? a, ushort? b = null, MR.CS.Misc._InOpt<ushort>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_cptr", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_cptr(ushort *a, ushort *b, ushort **c);
                ushort __deref_a = a.GetValueOrDefault();
                ushort __deref_b = b.GetValueOrDefault();
                ushort __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(ushort);
                ushort *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_ushort_cptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __ret is not null ? *__ret : null;
            }

            /// Generated from function `MR::CSharp::test_enum`.
            /// Parameter `b` defaults to `E1::b`.
            public static unsafe MR.CS.CSharp.E1 testEnum(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 __MR_CSharp_test_enum_MR_CSharp_E1(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_enum_MR_CSharp_E1(a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_ref`.
            /// Parameter `b` defaults to `default_e1`.
            public static unsafe ref MR.CS.CSharp.E1 testEnumRef(ref MR.CS.CSharp.E1 a, MR.CS.Misc.InOut<MR.CS.CSharp.E1>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_ref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                fixed (MR.CS.CSharp.E1 *__ptr_a = &a)
                {
                    MR.CS.CSharp.E1 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E1);
                    var __ret = __MR_CSharp_test_enum_ref_MR_CSharp_E1(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_enum_cref`.
            /// Parameter `b` defaults to `default_e1`.
            public static unsafe MR.CS.CSharp.E1 testEnumCref(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_cref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_cref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::E1&&)default_e1`.
            public static unsafe MR.CS.CSharp.E1 testEnumRref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E1 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_rref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_rref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_rref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::E1&&)default_e1`.
            public static unsafe MR.CS.CSharp.E1 testEnumCrref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E1 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_crref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_crref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_crref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_ptr`.
            /// Parameter `c` defaults to `&default_e1`.
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.E1>? testEnumPtr(MR.CS.Misc.InOut<MR.CS.CSharp.E1>? a, MR.CS.Misc.InOut<MR.CS.CSharp.E1>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.E1>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b, MR.CS.CSharp.E1 **c);
                MR.CS.CSharp.E1 __value_a = a is not null ? a.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.E1>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_enum_cptr`.
            /// Parameter `c` defaults to `&default_e1`.
            public static unsafe MR.CS.CSharp.E1? testEnumCptr(MR.CS.CSharp.E1? a, MR.CS.CSharp.E1? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.E1>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b, MR.CS.CSharp.E1 **c);
                MR.CS.CSharp.E1 __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.E1 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __ret is not null ? *__ret : null;
            }

            /// Generated from function `MR::CSharp::test_enum`.
            /// Parameter `b` defaults to `E2::b`.
            public static unsafe MR.CS.CSharp.E2 testEnum(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 __MR_CSharp_test_enum_MR_CSharp_E2(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return __MR_CSharp_test_enum_MR_CSharp_E2(a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_ref`.
            /// Parameter `b` defaults to `default_e2`.
            public static unsafe ref MR.CS.CSharp.E2 testEnumRef(ref MR.CS.CSharp.E2 a, MR.CS.Misc.InOut<MR.CS.CSharp.E2>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_ref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                fixed (MR.CS.CSharp.E2 *__ptr_a = &a)
                {
                    if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                    MR.CS.CSharp.E2 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E2);
                    if ((byte)__value_b > 1) __value_b = (MR.CS.CSharp.E2)1;
                    var __ret = __MR_CSharp_test_enum_ref_MR_CSharp_E2(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_enum_cref`.
            /// Parameter `b` defaults to `default_e2`.
            public static unsafe MR.CS.CSharp.E2 testEnumCref(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_cref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_cref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::E2&&)default_e2`.
            public static unsafe MR.CS.CSharp.E2 testEnumRref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E2 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_rref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_rref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_rref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::E2&&)default_e2`.
            public static unsafe MR.CS.CSharp.E2 testEnumCrref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E2 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_crref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_crref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_crref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// Generated from function `MR::CSharp::test_enum_ptr`.
            /// Parameter `c` defaults to `&default_e2`.
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.E2>? testEnumPtr(MR.CS.Misc.InOut<MR.CS.CSharp.E2>? a, MR.CS.Misc.InOut<MR.CS.CSharp.E2>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.E2>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b, MR.CS.CSharp.E2 **c);
                MR.CS.CSharp.E2 __value_a = a is not null ? a.Value : default(MR.CS.CSharp.E2);
                if ((byte)__value_a > 1) __value_a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E2);
                if ((byte)__value_b > 1) __value_b = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E2);
                MR.CS.CSharp.E2 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                if ((byte)__value_c > 1) __value_c = (MR.CS.CSharp.E2)1;
                var __ret = __MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.E2>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_enum_cptr`.
            /// Parameter `c` defaults to `&default_e2`.
            public static unsafe MR.CS.CSharp.E2? testEnumCptr(MR.CS.CSharp.E2? a, MR.CS.CSharp.E2? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.E2>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b, MR.CS.CSharp.E2 **c);
                MR.CS.CSharp.E2 __deref_a = a.GetValueOrDefault();
                if ((byte)__deref_a > 1) __deref_a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E2);
                MR.CS.CSharp.E2 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                if ((byte)__value_c > 1) __value_c = (MR.CS.CSharp.E2)1;
                var __ret = __MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __ret is not null ? *__ret : null;
            }

            /// Generated from function `MR::CSharp::test_class_trivial`.
            /// Parameter `b` defaults to `{}`.
            public static unsafe MR.CS.CSharp.Trivial testClassTrivial(MR.CS.CSharp.Const_Trivial a, MR.CS.CSharp.Const_Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_class_trivial_ref`.
            /// Parameter `b` defaults to `default_trivial`.
            public static unsafe MR.CS.CSharp.Trivial testClassTrivialRef(MR.CS.CSharp.Trivial a, MR.CS.CSharp.Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_ref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_trivial_cref`.
            /// Parameter `b` defaults to `default_trivial`.
            public static unsafe MR.CS.CSharp.Const_Trivial testClassTrivialCref(MR.CS.CSharp.Const_Trivial a, MR.CS.CSharp.Const_Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_cref(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_trivial_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::Trivial&&)default_trivial`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Trivial> testClassTrivialRref(MR.CS.Misc._Moved<MR.CS.CSharp.Trivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Trivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_rref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Trivial(__MR_CSharp_test_class_trivial_rref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_class_trivial_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::Trivial&&)default_trivial`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial> testClassTrivialCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_crref(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_Trivial(__MR_CSharp_test_class_trivial_crref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_class_trivial_ptr`.
            /// Parameter `c` defaults to `&default_trivial`.
            public static unsafe MR.CS.CSharp.Trivial? testClassTrivialPtr(MR.CS.CSharp.Trivial? a, MR.CS.CSharp.Trivial? b = null, MR.CS.CSharp._InOptMut_Trivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_ptr(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b, MR.CS.CSharp.Trivial._Underlying **c);
                MR.CS.CSharp.Trivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_trivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.Trivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_trivial_cptr`.
            /// Parameter `c` defaults to `&default_trivial`.
            public static unsafe MR.CS.CSharp.Const_Trivial? testClassTrivialCptr(MR.CS.CSharp.Const_Trivial? a, MR.CS.CSharp.Const_Trivial? b = null, MR.CS.CSharp._InOptConst_Trivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_cptr(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b, MR.CS.CSharp.Const_Trivial._Underlying **c);
                MR.CS.CSharp.Const_Trivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_trivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.Const_Trivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial`.
            /// Parameter `b` defaults to `{}`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> testClassNontrivial(MR.CS.CSharp._ByValue_NonTrivial a, MR.CS.CSharp._ByValue_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.NonTrivial(__MR_CSharp_test_class_nontrivial(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_ref`.
            /// Parameter `b` defaults to `default_nontrivial`.
            public static unsafe MR.CS.CSharp.NonTrivial testClassNontrivialRef(MR.CS.CSharp.NonTrivial a, MR.CS.CSharp.NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_ref(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_nontrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_cref`.
            /// Parameter `b` defaults to `default_nontrivial`.
            public static unsafe MR.CS.CSharp.Const_NonTrivial testClassNontrivialCref(MR.CS.CSharp.Const_NonTrivial a, MR.CS.CSharp.Const_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_cref(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_nontrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::NonTrivial&&)default_nontrivial`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> testClassNontrivialRref(MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_rref(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.NonTrivial(__MR_CSharp_test_class_nontrivial_rref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::NonTrivial&&)default_nontrivial`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial> testClassNontrivialCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_crref(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_NonTrivial(__MR_CSharp_test_class_nontrivial_crref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_ptr`.
            /// Parameter `c` defaults to `&default_nontrivial`.
            public static unsafe MR.CS.CSharp.NonTrivial? testClassNontrivialPtr(MR.CS.CSharp.NonTrivial? a, MR.CS.CSharp.NonTrivial? b = null, MR.CS.CSharp._InOptMut_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_ptr(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b, MR.CS.CSharp.NonTrivial._Underlying **c);
                MR.CS.CSharp.NonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_nontrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.NonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_nontrivial_cptr`.
            /// Parameter `c` defaults to `&default_nontrivial`.
            public static unsafe MR.CS.CSharp.Const_NonTrivial? testClassNontrivialCptr(MR.CS.CSharp.Const_NonTrivial? a, MR.CS.CSharp.Const_NonTrivial? b = null, MR.CS.CSharp._InOptConst_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_cptr(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b, MR.CS.CSharp.Const_NonTrivial._Underlying **c);
                MR.CS.CSharp.Const_NonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_nontrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.Const_NonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_void_ptr`.
            /// Parameter `a` is a mutable pointer.
            /// Parameter `b` is a mutable pointer.
            /// Parameter `c` defaults to `(void*)42`.
            /// Parameter `c` is a mutable pointer.
            /// Returns a mutable pointer.
            public static unsafe void *testVoidPtr(void *a, void *b = null, void **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_void_ptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_void_ptr(void *a, void *b, void **c);
                return __MR_CSharp_test_void_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_void_cptr`.
            /// Parameter `a` is a read-only pointer.
            /// Parameter `b` is a read-only pointer.
            /// Parameter `c` defaults to `(const void*)42`.
            /// Parameter `c` is a read-only pointer.
            /// Returns a read-only pointer.
            public static unsafe void *testVoidCptr(void *a, void *b = null, void **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_void_cptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_void_cptr(void *a, void *b, void **c);
                return __MR_CSharp_test_void_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::mark_se_as_shared`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SE> markSeAsShared()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_mark_se_as_shared", ExactSpelling = true)]
                extern static MR.CS.CSharp.SE._UnderlyingShared *__MR_CSharp_mark_se_as_shared();
                return MR.CS.Misc.Move(new MR.CS.CSharp.SE(__MR_CSharp_mark_se_as_shared(), is_owning: true));
            }

            // Poking a shared pointer type for a single class causes `std::shared_ptr` to be instantiated for the entire hierarchy (when `--bind-shared-ptr-virally`, which is required for `C#`).
            /// Generated from function `MR::CSharp::test_shptr`.
            /// Parameter `b` defaults to `default_shptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShptr(MR.CS.CSharp._ByValueShared_SA a, MR.CS.CSharp._ByValueShared_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shptr(a.PassByMode, a.Value is not null ? a.Value._UnderlyingSharedPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingSharedPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_shptr_ref`.
            /// Parameter `b` defaults to `default_shptr`.
            public static unsafe MR.CS.CSharp.SA testShptrRef(MR.CS.CSharp.SA a, MR.CS.CSharp.SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_ref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shptr_ref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_shptr_cref`.
            /// Parameter `b` defaults to `default_shptr`.
            public static unsafe MR.CS.CSharp.Const_SA testShptrCref(MR.CS.CSharp.Const_SA a, MR.CS.CSharp.Const_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_cref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shptr_cref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_shptr_rref`.
            /// Parameter `b` defaults to `(std::shared_ptr<MR::CSharp::SA>&&)default_shptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShptrRref(MR.CS.Misc._Moved<MR.CS.CSharp.SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_rref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shptr_rref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_shptr_crref`.
            /// Parameter `b` defaults to `(std::shared_ptr<MR::CSharp::SA>&&)default_shptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> testShptrCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_crref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_SA(__MR_CSharp_test_shptr_crref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_shptr_ptr`.
            /// Parameter `b` defaults to `&default_shptr`.
            public static unsafe MR.CS.CSharp.SA? testShptrPtr(MR.CS.CSharp.SA? a, MR.CS.CSharp._InOptMut_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_ptr(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared **b);
                MR.CS.CSharp.SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __ret = __MR_CSharp_test_shptr_ptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.CSharp.SA(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_shptr_cptr`.
            /// Parameter `b` defaults to `&default_shptr`.
            public static unsafe MR.CS.CSharp.Const_SA? testShptrCptr(MR.CS.CSharp.Const_SA? a, MR.CS.CSharp._InOptConst_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_cptr(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared **b);
                MR.CS.CSharp.Const_SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __ret = __MR_CSharp_test_shptr_cptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.CSharp.Const_SA(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_shcptr`.
            /// Parameter `b` defaults to `default_shcptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShcptr(MR.CS.CSharp._ByValueShared_SA a, MR.CS.CSharp._ByValueShared_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shcptr(a.PassByMode, a.Value is not null ? a.Value._UnderlyingSharedPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingSharedPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_shcptr_ref`.
            /// Parameter `b` defaults to `default_shcptr`.
            public static unsafe MR.CS.CSharp.SA testShcptrRef(MR.CS.CSharp.SA a, MR.CS.CSharp.SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_ref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shcptr_ref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_shcptr_cref`.
            /// Parameter `b` defaults to `default_shcptr`.
            public static unsafe MR.CS.CSharp.Const_SA testShcptrCref(MR.CS.CSharp.Const_SA a, MR.CS.CSharp.Const_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_cref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shcptr_cref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_shcptr_rref`.
            /// Parameter `b` defaults to `(std::shared_ptr<const MR::CSharp::SA>&&)default_shcptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShcptrRref(MR.CS.Misc._Moved<MR.CS.CSharp.SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_rref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shcptr_rref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_shcptr_crref`.
            /// Parameter `b` defaults to `(std::shared_ptr<const MR::CSharp::SA>&&)default_shcptr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> testShcptrCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_crref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_SA(__MR_CSharp_test_shcptr_crref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// Generated from function `MR::CSharp::test_shcptr_ptr`.
            /// Parameter `b` defaults to `&default_shcptr`.
            public static unsafe MR.CS.CSharp.SA? testShcptrPtr(MR.CS.CSharp.SA? a, MR.CS.CSharp._InOptMut_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_ptr(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared **b);
                MR.CS.CSharp.SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __ret = __MR_CSharp_test_shcptr_ptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.CSharp.SA(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_shcptr_cptr`.
            /// Parameter `b` defaults to `&default_shcptr`.
            public static unsafe MR.CS.CSharp.Const_SA? testShcptrCptr(MR.CS.CSharp.Const_SA? a, MR.CS.CSharp._InOptConst_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_cptr(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared **b);
                MR.CS.CSharp.Const_SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __ret = __MR_CSharp_test_shcptr_cptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.CSharp.Const_SA(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_string`.
            /// Parameter `b` defaults to `default_string`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.String> testString(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.String(__MR_CSharp_test_string(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_string_ref`.
            /// Parameter `b` defaults to `default_string`.
            public static unsafe MR.CS.Std.String testStringRef(MR.CS.Std.String a, MR.CS.Std.String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_ref", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_ref(MR.CS.Std.String._Underlying *a, MR.CS.Std.String._Underlying *b);
                return new(__MR_CSharp_test_string_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_string_cref`.
            /// Parameter `b` defaults to `default_string`.
            public static unsafe MR.CS.Std.Const_String testStringCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_string_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_string_rref`.
            /// Parameter `b` defaults to `(std::string&&)default_string`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.String> testStringRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_rref", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.String(__MR_CSharp_test_string_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_string_crref`.
            /// Parameter `b` defaults to `(std::string&&)default_string`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Const_String> testStringCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Const_String(__MR_CSharp_test_string_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_string_ptr`.
            /// Parameter `b` defaults to `&default_string`.
            public static unsafe MR.CS.Std.String? testStringPtr(MR.CS.Std.String? a, MR.CS.Std._InOptMut_String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_ptr(MR.CS.Std.String._Underlying *a, MR.CS.Std.String._Underlying **b);
                MR.CS.Std.String._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_string_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.String(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_string_cptr`.
            /// Parameter `b` defaults to `&default_string`.
            public static unsafe MR.CS.Std.Const_String? testStringCptr(MR.CS.Std.Const_String? a, MR.CS.Std._InOptConst_String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_cptr(MR.CS.Std.Const_String._Underlying *a, MR.CS.Std.Const_String._Underlying **b);
                MR.CS.Std.Const_String._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_string_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Const_String(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_stringview`.
            /// Parameter `b` defaults to `default_stringview`.
            public static unsafe MR.CS.Std.StringView testStringview(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_stringview(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true);
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_stringview_ref`.
            /// Parameter `b` defaults to `default_stringview`.
            public static unsafe MR.CS.Std.StringView testStringviewRef(MR.CS.Std.StringView a, MR.CS.Std.StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_ref", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_ref(MR.CS.Std.StringView._Underlying *a, MR.CS.Std.StringView._Underlying *b);
                return new(__MR_CSharp_test_stringview_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_stringview_cref`.
            /// Parameter `b` defaults to `default_stringview`.
            public static unsafe MR.CS.Std.Const_StringView testStringviewCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_stringview_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_stringview_rref`.
            /// Parameter `b` defaults to `(std::string_view&&)default_stringview`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.StringView> testStringviewRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_rref", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.StringView(__MR_CSharp_test_stringview_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_stringview_crref`.
            /// Parameter `b` defaults to `(std::string_view&&)default_stringview`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Const_StringView> testStringviewCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Const_StringView(__MR_CSharp_test_stringview_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_stringview_ptr`.
            /// Parameter `b` defaults to `&default_stringview`.
            public static unsafe MR.CS.Std.StringView? testStringviewPtr(MR.CS.Std.StringView? a, MR.CS.Std._InOptMut_StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_ptr(MR.CS.Std.StringView._Underlying *a, MR.CS.Std.StringView._Underlying **b);
                MR.CS.Std.StringView._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_stringview_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.StringView(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_stringview_cptr`.
            /// Parameter `b` defaults to `&default_stringview`.
            public static unsafe MR.CS.Std.Const_StringView? testStringviewCptr(MR.CS.Std.Const_StringView? a, MR.CS.Std._InOptConst_StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_cptr(MR.CS.Std.Const_StringView._Underlying *a, MR.CS.Std.Const_StringView._Underlying **b);
                MR.CS.Std.Const_StringView._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_stringview_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Const_StringView(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_fspath`.
            /// Parameter `b` defaults to `default_fspath`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Path> testFspath(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Path(__MR_CSharp_test_fspath(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_fspath_ref`.
            /// Parameter `b` defaults to `default_fspath`.
            public static unsafe MR.CS.Std.Filesystem.Path testFspathRef(MR.CS.Std.Filesystem.Path a, MR.CS.Std.Filesystem.Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_ref(MR.CS.Std.Filesystem.Path._Underlying *a, MR.CS.Std.Filesystem.Path._Underlying *b);
                return new(__MR_CSharp_test_fspath_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_fspath_cref`.
            /// Parameter `b` defaults to `default_fspath`.
            public static unsafe MR.CS.Std.Filesystem.Const_Path testFspathCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_fspath_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_fspath_rref`.
            /// Parameter `b` defaults to `(std::filesystem::path&&)default_fspath`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Path> testFspathRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_rref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Path(__MR_CSharp_test_fspath_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_fspath_crref`.
            /// Parameter `b` defaults to `(std::filesystem::path&&)default_fspath`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Const_Path> testFspathCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Const_Path(__MR_CSharp_test_fspath_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// Generated from function `MR::CSharp::test_fspath_ptr`.
            /// Parameter `b` defaults to `&default_fspath`.
            public static unsafe MR.CS.Std.Filesystem.Path? testFspathPtr(MR.CS.Std.Filesystem.Path? a, MR.CS.Std.Filesystem._InOptMut_Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_ptr(MR.CS.Std.Filesystem.Path._Underlying *a, MR.CS.Std.Filesystem.Path._Underlying **b);
                MR.CS.Std.Filesystem.Path._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_fspath_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Filesystem.Path(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_fspath_cptr`.
            /// Parameter `b` defaults to `&default_fspath`.
            public static unsafe MR.CS.Std.Filesystem.Const_Path? testFspathCptr(MR.CS.Std.Filesystem.Const_Path? a, MR.CS.Std.Filesystem._InOptConst_Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_cptr(MR.CS.Std.Filesystem.Const_Path._Underlying *a, MR.CS.Std.Filesystem.Const_Path._Underlying **b);
                MR.CS.Std.Filesystem.Const_Path._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_fspath_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Filesystem.Const_Path(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::operator+`.
            public static unsafe int add(MR.CS.CSharp._ByValue_StaticOpsLhsC _1, int _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsC_int", ExactSpelling = true)]
                extern static int __MR_C_add_MR_CSharp_StaticOpsLhsC_int(MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_1, int _2);
                return __MR_C_add_MR_CSharp_StaticOpsLhsC_int(_1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null, _2);
            }

            /// Generated from function `MR::CSharp::operator+`.
            public static unsafe int add(int _1, MR.CS.CSharp._ByValue_StaticOpsRhsC _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int_MR_CSharp_StaticOpsRhsC", ExactSpelling = true)]
                extern static int __MR_C_add_int_MR_CSharp_StaticOpsRhsC(int _1, MR.CS.Misc._PassBy _2_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_2);
                return __MR_C_add_int_MR_CSharp_StaticOpsRhsC(_1, _2.PassByMode, _2.Value is not null ? _2.Value._UnderlyingPtr : null);
            }

            // Fails to inject, becomes a free function.
            /// Generated from function `MR::CSharp::operator+`.
            public static int add(MR.CS.CSharp.StaticOpsEnum _1, int _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsEnum_int", ExactSpelling = true)]
                extern static int __MR_C_add_MR_CSharp_StaticOpsEnum_int(MR.CS.CSharp.StaticOpsEnum _1, int _2);
                return __MR_C_add_MR_CSharp_StaticOpsEnum_int(_1, _2);
            }

            /// Generated from function `MR::CSharp::test_class_convtrivial`.
            /// Parameter `b` defaults to `{}`.
            public static unsafe MR.CS.CSharp.ConvCtorTrivial testClassConvtrivial(MR.CS.CSharp.Const_ConvCtorTrivial a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_class_convtrivial_ref`.
            /// Parameter `b` defaults to `default_convtrivial`.
            public static unsafe MR.CS.CSharp.ConvCtorTrivial testClassConvtrivialRef(MR.CS.CSharp.ConvCtorTrivial a, MR.CS.CSharp.ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_ref(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_convtrivial_cref`.
            /// Parameter `b` defaults to `default_convtrivial`.
            public static unsafe MR.CS.CSharp.Const_ConvCtorTrivial testClassConvtrivialCref(MR.CS.CSharp.Const_ConvCtorTrivial a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_cref(MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_convtrivial_ptr`.
            /// Parameter `c` defaults to `&default_convtrivial`.
            public static unsafe MR.CS.CSharp.ConvCtorTrivial? testClassConvtrivialPtr(MR.CS.CSharp.ConvCtorTrivial? a, MR.CS.CSharp.ConvCtorTrivial? b = null, MR.CS.CSharp._InOptMut_ConvCtorTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_ptr(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b, MR.CS.CSharp.ConvCtorTrivial._Underlying **c);
                MR.CS.CSharp.ConvCtorTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_convtrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.ConvCtorTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_convtrivial_cptr`.
            /// Parameter `c` defaults to `&default_convtrivial`.
            public static unsafe MR.CS.CSharp.Const_ConvCtorTrivial? testClassConvtrivialCptr(MR.CS.CSharp.Const_ConvCtorTrivial? a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null, MR.CS.CSharp._InOptConst_ConvCtorTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_cptr(MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *b, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying **c);
                MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_convtrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.Const_ConvCtorTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_convnontrivial`.
            /// Parameter `b` defaults to `{}`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivial> testClassConvnontrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial a, MR.CS.CSharp._ByValue_ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.ConvCtorNonTrivial(__MR_CSharp_test_class_convnontrivial(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_class_convnontrivial_ref`.
            /// Parameter `b` defaults to `default_convnontrivial`.
            public static unsafe MR.CS.CSharp.ConvCtorNonTrivial testClassConvnontrivialRef(MR.CS.CSharp.ConvCtorNonTrivial a, MR.CS.CSharp.ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_ref(MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convnontrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_convnontrivial_cref`.
            /// Parameter `b` defaults to `default_convnontrivial`.
            public static unsafe MR.CS.CSharp.Const_ConvCtorNonTrivial testClassConvnontrivialCref(MR.CS.CSharp.Const_ConvCtorNonTrivial a, MR.CS.CSharp.Const_ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_cref(MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convnontrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_class_convnontrivial_ptr`.
            /// Parameter `c` defaults to `&default_convnontrivial`.
            public static unsafe MR.CS.CSharp.ConvCtorNonTrivial? testClassConvnontrivialPtr(MR.CS.CSharp.ConvCtorNonTrivial? a, MR.CS.CSharp.ConvCtorNonTrivial? b = null, MR.CS.CSharp._InOptMut_ConvCtorNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_ptr(MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b, MR.CS.CSharp.ConvCtorNonTrivial._Underlying **c);
                MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_convnontrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.ConvCtorNonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_class_convnontrivial_cptr`.
            /// Parameter `c` defaults to `&default_convnontrivial`.
            public static unsafe MR.CS.CSharp.Const_ConvCtorNonTrivial? testClassConvnontrivialCptr(MR.CS.CSharp.Const_ConvCtorNonTrivial? a, MR.CS.CSharp.Const_ConvCtorNonTrivial? b = null, MR.CS.CSharp._InOptConst_ConvCtorNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_cptr(MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *b, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying **c);
                MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_class_convnontrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.CSharp.Const_ConvCtorNonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_exposed`.
            /// Parameter `b` defaults to `default_exposed`.
            public static unsafe MR.CS.CSharp.ExposedLayout testExposed(MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp._InOpt_ExposedLayout b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout __MR_CSharp_test_exposed_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp.ExposedLayout *b);
                return __MR_CSharp_test_exposed_MR_CSharp_ExposedLayout(a, b.HasValue ? &b.Object : null);
            }

            /// Generated from function `MR::CSharp::test_exposed_ref`.
            /// Parameter `b` defaults to `default_exposed`.
            public static unsafe ref MR.CS.CSharp.ExposedLayout testExposedRef(ref MR.CS.CSharp.ExposedLayout a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayout);
                    var __ret = __MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_cref`.
            /// Parameter `b` defaults to `default_exposed`.
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedCref(in MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::ExposedLayout&&)default_exposed`.
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedRref(MR.CS.Misc._MoveRef _move_a, in MR.CS.CSharp.ExposedLayout a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_rref(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_rref(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::ExposedLayout&&)default_exposed`.
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedCrref(MR.CS.Misc._MoveRef _move_a, in MR.CS.CSharp.ExposedLayout a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_crref(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_crref(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_ptr`.
            /// Parameter `c` defaults to `&default_exposed`.
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>? testExposedPtr(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.ExposedLayout>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout **c);
                MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_exposed_cptr`.
            /// Parameter `c` defaults to `&default_exposed`.
            public static unsafe MR.CS.CSharp.ExposedLayout? testExposedCptr(MR.CS.CSharp.ExposedLayout? a, MR.CS.CSharp.ExposedLayout? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.ExposedLayout>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout **c);
                MR.CS.CSharp.ExposedLayout __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayout __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                if (__ret is not null) return *__ret; else return null;
            }

            // This broke at one point, so testing it too.
            /// Generated from function `MR::CSharp::test_exposed_vec`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Vector_MRCSharpExposedLayout> testExposedVec()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_vec", ExactSpelling = true)]
                extern static MR.CS.Std.Vector_MRCSharpExposedLayout._Underlying *__MR_CSharp_test_exposed_vec();
                return MR.CS.Misc.Move(new MR.CS.Std.Vector_MRCSharpExposedLayout(__MR_CSharp_test_exposed_vec(), is_owning: true));
            }

            /// Generated from function `MR::CSharp::make_exposed_sh`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Mut_ExposedLayoutSh> makeExposedSh()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_make_exposed_sh", ExactSpelling = true)]
                extern static MR.CS.CSharp.Mut_ExposedLayoutSh._UnderlyingShared *__MR_CSharp_make_exposed_sh();
                return MR.CS.Misc.Move(new MR.CS.CSharp.Mut_ExposedLayoutSh(__MR_CSharp_make_exposed_sh(), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_exposed`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            public static unsafe MR.CS.CSharp.ExposedLayoutSh testExposed(MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp._InOpt_ExposedLayoutSh b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh __MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp.ExposedLayoutSh *b);
                return __MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh(a, b.HasValue ? &b.Object : null);
            }

            /// Generated from function `MR::CSharp::test_exposed_ref`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            public static unsafe ref MR.CS.CSharp.ExposedLayoutSh testExposedRef(ref MR.CS.CSharp.ExposedLayoutSh a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b);
                fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayoutSh __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                    var __ret = __MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__ret;
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_cref`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayoutSh testExposedCref(in MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp.ExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b);
                fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayoutSh __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// Generated from function `MR::CSharp::test_exposed_ptr`.
            /// Parameter `c` defaults to `&default_exposed_sh`.
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayoutSh>? testExposedPtr(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.ExposedLayoutSh>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b, MR.CS.CSharp.ExposedLayoutSh **c);
                MR.CS.CSharp.ExposedLayoutSh __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayoutSh>(__ret) : null;
            }

            /// Generated from function `MR::CSharp::test_exposed_cptr`.
            /// Parameter `c` defaults to `&default_exposed_sh`.
            public static unsafe MR.CS.CSharp.ExposedLayoutSh? testExposedCptr(MR.CS.CSharp.ExposedLayoutSh? a, MR.CS.CSharp.ExposedLayoutSh? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.ExposedLayoutSh>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b, MR.CS.CSharp.ExposedLayoutSh **c);
                MR.CS.CSharp.ExposedLayoutSh __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayoutSh __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayoutSh __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __ret = __MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                if (__ret is not null) return *__ret; else return null;
            }

            /// Generated from function `MR::CSharp::test_optint`.
            /// Parameter `b` defaults to `default_optint`.
            /// Parameter `c` defaults to `default_optint`.
            public static unsafe MR.CS.Std.Optional_Int testOptint(int? a, MR.CS.Std.Const_Optional_Int? b = null, MR.CS.Std.Const_Optional_Int? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int._Underlying *__MR_CSharp_test_optint(int *a, MR.CS.Std.Optional_Int._Underlying *b, MR.CS.Std.Optional_Int._Underlying *c);
                int __deref_a = a.GetValueOrDefault();
                return new(__MR_CSharp_test_optint(a.HasValue ? &__deref_a : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_optint_ref`.
            /// Parameter `b` defaults to `default_optint`.
            public static unsafe MR.CS.Std.Optional_Int testOptintRef(MR.CS.Std.Optional_Int a, MR.CS.Std.Optional_Int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int._Underlying *__MR_CSharp_test_optint_ref(MR.CS.Std.Optional_Int._Underlying *a, MR.CS.Std.Optional_Int._Underlying *b);
                return new(__MR_CSharp_test_optint_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optint_cref`.
            /// Parameter `b` defaults to `default_optint`.
            public static unsafe MR.CS.Std.Const_Optional_Int testOptintCref(int? a, MR.CS.Std.Const_Optional_Int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_Int._Underlying *__MR_CSharp_test_optint_cref(int *a, MR.CS.Std.Const_Optional_Int._Underlying *b);
                int __deref_a = a.GetValueOrDefault();
                return new(__MR_CSharp_test_optint_cref(a.HasValue ? &__deref_a : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optint_ptr`.
            /// Parameter `c` defaults to `&default_optint`.
            public static unsafe MR.CS.Std.Optional_Int? testOptintPtr(MR.CS.Std.Optional_Int? a, MR.CS.Std.Optional_Int? b = null, MR.CS.Std._InOptMut_Optional_Int? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int._Underlying *__MR_CSharp_test_optint_ptr(MR.CS.Std.Optional_Int._Underlying *a, MR.CS.Std.Optional_Int._Underlying *b, MR.CS.Std.Optional_Int._Underlying **c);
                MR.CS.Std.Optional_Int._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optint_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_Int(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optint_cptr`.
            /// Parameter `c` defaults to `&default_optint`.
            public static unsafe MR.CS.Std.Const_Optional_Int? testOptintCptr(MR.CS.Std.Const_Optional_Int? a, MR.CS.Std.Const_Optional_Int? b = null, MR.CS.Std._InOptConst_Optional_Int? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_Int._Underlying *__MR_CSharp_test_optint_cptr(MR.CS.Std.Const_Optional_Int._Underlying *a, MR.CS.Std.Const_Optional_Int._Underlying *b, MR.CS.Std.Const_Optional_Int._Underlying **c);
                MR.CS.Std.Const_Optional_Int._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optint_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_Int(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optstr`.
            /// Parameter `b` defaults to `default_optstr`.
            /// Parameter `c` defaults to `default_optstr`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Optional_StdString> testOptstr(MR.CS.Misc.ReadOnlyCharSpanOpt a, MR.CS.Std._ByValue_Optional_StdString? b = null, MR.CS.Std._ByValue_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr(byte *a, byte *a_end, MR.CS.Misc._PassBy b_pass_by, MR.CS.Std.Optional_StdString._Underlying *b, MR.CS.Misc._PassBy c_pass_by, MR.CS.Std.Optional_StdString._Underlying *c);
                byte[] __bytes_a;
                int __len_a = 0;
                if (a.HasValue)
                {
                    __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Value.Length)];
                    __len_a = System.Text.Encoding.UTF8.GetBytes(a.Value, __bytes_a);
                }
                fixed (byte *__ptr_a = __bytes_a)
                {
                    return MR.CS.Misc.Move(new MR.CS.Std.Optional_StdString(__MR_CSharp_test_optstr(a.HasValue ? __ptr_a : null, a.HasValue ? __ptr_a + __len_a : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null, c is not null ? c.PassByMode : MR.CS.Misc._PassBy.default_arg, c is not null && c.Value is not null ? c.Value._UnderlyingPtr : null), is_owning: true));
                }
            }

            /// Generated from function `MR::CSharp::test_optstr_ref`.
            /// Parameter `b` defaults to `default_optstr`.
            public static unsafe MR.CS.Std.Optional_StdString testOptstrRef(MR.CS.Std.Optional_StdString a, MR.CS.Std.Optional_StdString? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr_ref(MR.CS.Std.Optional_StdString._Underlying *a, MR.CS.Std.Optional_StdString._Underlying *b);
                return new(__MR_CSharp_test_optstr_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optstr_cref`.
            /// Parameter `b` defaults to `default_optstr`.
            public static unsafe MR.CS.Std.Const_Optional_StdString testOptstrCref(MR.CS.Misc.ReadOnlyCharSpanOpt a, MR.CS.Std.Const_Optional_StdString? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_StdString._Underlying *__MR_CSharp_test_optstr_cref(byte *a, byte *a_end, MR.CS.Std.Const_Optional_StdString._Underlying *b);
                byte[] __bytes_a;
                int __len_a = 0;
                if (a.HasValue)
                {
                    __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Value.Length)];
                    __len_a = System.Text.Encoding.UTF8.GetBytes(a.Value, __bytes_a);
                }
                fixed (byte *__ptr_a = __bytes_a)
                {
                    return new(__MR_CSharp_test_optstr_cref(a.HasValue ? __ptr_a : null, a.HasValue ? __ptr_a + __len_a : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// Generated from function `MR::CSharp::test_optstr_ptr`.
            /// Parameter `c` defaults to `&default_optstr`.
            public static unsafe MR.CS.Std.Optional_StdString? testOptstrPtr(MR.CS.Std.Optional_StdString? a, MR.CS.Std.Optional_StdString? b = null, MR.CS.Std._InOptMut_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr_ptr(MR.CS.Std.Optional_StdString._Underlying *a, MR.CS.Std.Optional_StdString._Underlying *b, MR.CS.Std.Optional_StdString._Underlying **c);
                MR.CS.Std.Optional_StdString._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optstr_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_StdString(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optstr_cptr`.
            /// Parameter `c` defaults to `&default_optstr`.
            public static unsafe MR.CS.Std.Const_Optional_StdString? testOptstrCptr(MR.CS.Std.Const_Optional_StdString? a, MR.CS.Std.Const_Optional_StdString? b = null, MR.CS.Std._InOptConst_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_StdString._Underlying *__MR_CSharp_test_optstr_cptr(MR.CS.Std.Const_Optional_StdString._Underlying *a, MR.CS.Std.Const_Optional_StdString._Underlying *b, MR.CS.Std.Const_Optional_StdString._Underlying **c);
                MR.CS.Std.Const_Optional_StdString._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optstr_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_StdString(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_opttriv`.
            /// Parameter `b` defaults to `default_opttriv`.
            /// Parameter `c` defaults to `default_opttriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial testOpttriv(MR.CS.CSharp.Const_Trivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null, MR.CS.Std.Const_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *c);
                return new(__MR_CSharp_test_opttriv(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_opttriv_ref`.
            /// Parameter `b` defaults to `default_opttriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial testOpttrivRef(MR.CS.Std.Optional_MRCSharpTrivial a, MR.CS.Std.Optional_MRCSharpTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_ref(MR.CS.Std.Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b);
                return new(__MR_CSharp_test_opttriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_opttriv_cref`.
            /// Parameter `b` defaults to `default_opttriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpTrivial testOpttrivCref(MR.CS.CSharp.Const_Trivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_cref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *b);
                return new(__MR_CSharp_test_opttriv_cref(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_opttriv_ptr`.
            /// Parameter `c` defaults to `&default_opttriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial? testOpttrivPtr(MR.CS.Std.Optional_MRCSharpTrivial? a, MR.CS.Std.Optional_MRCSharpTrivial? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_ptr(MR.CS.Std.Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpTrivial._Underlying **c);
                MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_opttriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_MRCSharpTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_opttriv_cptr`.
            /// Parameter `c` defaults to `&default_opttriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpTrivial? testOpttrivCptr(MR.CS.Std.Const_Optional_MRCSharpTrivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_cptr(MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_opttriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optnontriv`.
            /// Parameter `b` defaults to `default_optnontriv`.
            /// Parameter `c` defaults to `default_optnontriv`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Optional_MRCSharpNonTrivial> testOptnontriv(MR.CS.CSharp._ByValue_NonTrivial? a, MR.CS.CSharp._ByValueOptOpt_NonTrivial? b = null, MR.CS.CSharp._ByValueOptOpt_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b, MR.CS.Misc._PassBy c_pass_by, MR.CS.CSharp.NonTrivial._Underlying *c);
                return MR.CS.Misc.Move(new MR.CS.Std.Optional_MRCSharpNonTrivial(__MR_CSharp_test_optnontriv(a is not null ? a.PassByMode : MR.CS.Misc._PassBy.no_object, a is not null && a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null, c is not null ? c.PassByMode : MR.CS.Misc._PassBy.default_arg, c is not null && c.Value is not null ? c.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_optnontriv_ref`.
            /// Parameter `b` defaults to `default_optnontriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpNonTrivial testOptnontrivRef(MR.CS.Std.Optional_MRCSharpNonTrivial a, MR.CS.Std.Optional_MRCSharpNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_ref(MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_optnontriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optnontriv_cref`.
            /// Parameter `b` defaults to `default_optnontriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpNonTrivial testOptnontrivCref(MR.CS.CSharp._ByValue_NonTrivial? a, MR.CS.CSharp._ByValueOptOpt_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_cref(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_optnontriv_cref(a is not null ? a.PassByMode : MR.CS.Misc._PassBy.no_object, a is not null && a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optnontriv_ptr`.
            /// Parameter `c` defaults to `&default_optnontriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpNonTrivial? testOptnontrivPtr(MR.CS.Std.Optional_MRCSharpNonTrivial? a, MR.CS.Std.Optional_MRCSharpNonTrivial? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_ptr(MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying **c);
                MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optnontriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_MRCSharpNonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optnontriv_cptr`.
            /// Parameter `c` defaults to `&default_optnontriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpNonTrivial? testOptnontrivCptr(MR.CS.Std.Const_Optional_MRCSharpNonTrivial? a, MR.CS.Std.Const_Optional_MRCSharpNonTrivial? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_cptr(MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optnontriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpNonTrivial(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optshexp`.
            /// Parameter `b` defaults to `default_optshexp`.
            /// Parameter `c` defaults to `default_optshexp`.
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh testOptshexp(MR.CS.CSharp._InOpt_ExposedLayoutSh a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *c);
                return new(__MR_CSharp_test_optshexp(a.HasValue ? &a.Object : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_optshexp_ref`.
            /// Parameter `b` defaults to `default_optshexp`.
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh testOptshexpRef(MR.CS.Std.Optional_MRCSharpExposedLayoutSh a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_ref(MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b);
                return new(__MR_CSharp_test_optshexp_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optshexp_cref`.
            /// Parameter `b` defaults to `default_optshexp`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh testOptshexpCref(MR.CS.CSharp._InOpt_ExposedLayoutSh a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_cref(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *b);
                return new(__MR_CSharp_test_optshexp_cref(a.HasValue ? &a.Object : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optshexp_ptr`.
            /// Parameter `c` defaults to `&default_optshexp`.
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh? testOptshexpPtr(MR.CS.Std.Optional_MRCSharpExposedLayoutSh? a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_ptr(MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying **c);
                MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optshexp_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_MRCSharpExposedLayoutSh(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optshexp_cptr`.
            /// Parameter `c` defaults to `&default_optshexp`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? testOptshexpCptr(MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_cptr(MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optshexp_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optshtriv`.
            /// Parameter `b` defaults to `default_optshtriv`.
            /// Parameter `c` defaults to `default_optshtriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpSA testOptshtriv(MR.CS.CSharp.Const_SA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null, MR.CS.Std.Const_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv(MR.CS.CSharp.SA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Optional_MRCSharpSA._Underlying *c);
                return new(__MR_CSharp_test_optshtriv(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_optshtriv_ref`.
            /// Parameter `b` defaults to `default_optshtriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpSA testOptshtrivRef(MR.CS.Std.Optional_MRCSharpSA a, MR.CS.Std.Optional_MRCSharpSA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_ref(MR.CS.Std.Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b);
                return new(__MR_CSharp_test_optshtriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optshtriv_cref`.
            /// Parameter `b` defaults to `default_optshtriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpSA testOptshtrivCref(MR.CS.CSharp.Const_SA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_cref(MR.CS.CSharp.SA._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *b);
                return new(__MR_CSharp_test_optshtriv_cref(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_optshtriv_ptr`.
            /// Parameter `c` defaults to `&default_optshtriv`.
            public static unsafe MR.CS.Std.Optional_MRCSharpSA? testOptshtrivPtr(MR.CS.Std.Optional_MRCSharpSA? a, MR.CS.Std.Optional_MRCSharpSA? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_ptr(MR.CS.Std.Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Optional_MRCSharpSA._Underlying **c);
                MR.CS.Std.Optional_MRCSharpSA._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optshtriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Optional_MRCSharpSA(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_optshtriv_cptr`.
            /// Parameter `c` defaults to `&default_optshtriv`.
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpSA? testOptshtrivCptr(MR.CS.Std.Const_Optional_MRCSharpSA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_cptr(MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_optshtriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpSA(__ret, is_owning: false) : null;
            }

            // Tag types:
            /// Generated from function `MR::CSharp::test_tag`.
            public static MR.CS.Std.Greater_Int testTag(MR.CS.Std.Greater_Int a, MR.CS.Std.Greater_Int b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag", ExactSpelling = true)]
                extern static void __MR_CSharp_test_tag();
                __MR_CSharp_test_tag();
                return new();
            }

            /// Generated from function `MR::CSharp::test_tag_cref`.
            public static void testTagCref(MR.CS.Std.Greater_Int a, MR.CS.Std.Greater_Int b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_cref", ExactSpelling = true)]
                extern static void __MR_CSharp_test_tag_cref();
                __MR_CSharp_test_tag_cref();
            }

            /// Generated from function `MR::CSharp::test_tag_ptr`.
            public static MR.CS.Std.Greater_Int? testTagPtr()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_ptr", ExactSpelling = true)]
                extern static bool __MR_CSharp_test_tag_ptr();
                return __MR_CSharp_test_tag_ptr() ? new MR.CS.Std.Greater_Int() : null;
            }

            /// Generated from function `MR::CSharp::test_tag_cptr`.
            public static MR.CS.Std.Greater_Int? testTagCptr()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_cptr", ExactSpelling = true)]
                extern static bool __MR_CSharp_test_tag_cptr();
                return __MR_CSharp_test_tag_cptr() ? new MR.CS.Std.Greater_Int() : null;
            }

            /// Generated from function `MR::CSharp::test_variant`.
            /// Parameter `b` defaults to `default_variant`.
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int_Float testVariant(MR.CS.Std.Const_Variant_StdMonostate_Int_Float a, MR.CS.Std.Const_Variant_StdMonostate_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *__MR_CSharp_test_variant(MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_variant(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_variant_ref`.
            /// Parameter `b` defaults to `default_variant`.
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int_Float testVariantRef(MR.CS.Std.Variant_StdMonostate_Int_Float a, MR.CS.Std.Variant_StdMonostate_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *__MR_CSharp_test_variant_ref(MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_variant_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_variant_cref`.
            /// Parameter `b` defaults to `default_variant`.
            public static unsafe MR.CS.Std.Const_Variant_StdMonostate_Int_Float testVariantCref(MR.CS.Std.Const_Variant_StdMonostate_Int_Float a, MR.CS.Std.Const_Variant_StdMonostate_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *__MR_CSharp_test_variant_cref(MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *a, MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_variant_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_variant_ptr`.
            /// Parameter `b` defaults to `&default_variant`.
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int_Float? testVariantPtr(MR.CS.Std.Variant_StdMonostate_Int_Float? a, MR.CS.Std._InOptMut_Variant_StdMonostate_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *__MR_CSharp_test_variant_ptr(MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying **b);
                MR.CS.Std.Variant_StdMonostate_Int_Float._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_variant_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Variant_StdMonostate_Int_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_variant_cptr`.
            /// Parameter `b` defaults to `&default_variant`.
            public static unsafe MR.CS.Std.Const_Variant_StdMonostate_Int_Float? testVariantCptr(MR.CS.Std.Const_Variant_StdMonostate_Int_Float? a, MR.CS.Std._InOptConst_Variant_StdMonostate_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *__MR_CSharp_test_variant_cptr(MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *a, MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying **b);
                MR.CS.Std.Const_Variant_StdMonostate_Int_Float._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_variant_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __ret is not null ? new MR.CS.Std.Const_Variant_StdMonostate_Int_Float(__ret, is_owning: false) : null;
            }

            // Test a variant that has duplicate element types.
            /// Generated from function `MR::CSharp::test_variant_with_repeated_types`.
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int_Float_Float testVariantWithRepeatedTypes()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_with_repeated_types", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int_Float_Float._Underlying *__MR_CSharp_test_variant_with_repeated_types();
                return new(__MR_CSharp_test_variant_with_repeated_types(), is_owning: true);
            }

            // Input and output streams:
            /// Generated from function `MR::CSharp::test_iostreams_ref`.
            public static unsafe MR.CS.Std.Ostream testIostreamsRef(MR.CS.Std.Istream _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Ostream._Underlying *__MR_CSharp_test_iostreams_ref(MR.CS.Std.Istream._Underlying *_1);
                return new(__MR_CSharp_test_iostreams_ref(_1._UnderlyingPtr), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_iostreams_ptr`.
            public static unsafe MR.CS.Std.Ostream? testIostreamsPtr(MR.CS.Std.Istream? _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Ostream._Underlying *__MR_CSharp_test_iostreams_ptr(MR.CS.Std.Istream._Underlying *_1);
                var __ret = __MR_CSharp_test_iostreams_ptr(_1 is not null ? _1._UnderlyingPtr : null);
                return __ret is not null ? new MR.CS.Std.Ostream(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_iostreams_cref`.
            public static unsafe MR.CS.Std.Const_Ostream testIostreamsCref(MR.CS.Std.Const_Istream _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Ostream._Underlying *__MR_CSharp_test_iostreams_cref(MR.CS.Std.Const_Istream._Underlying *_1);
                return new(__MR_CSharp_test_iostreams_cref(_1._UnderlyingPtr), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_iostreams_cptr`.
            public static unsafe MR.CS.Std.Const_Ostream? testIostreamsCptr(MR.CS.Std.Const_Istream? _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Ostream._Underlying *__MR_CSharp_test_iostreams_cptr(MR.CS.Std.Const_Istream._Underlying *_1);
                var __ret = __MR_CSharp_test_iostreams_cptr(_1 is not null ? _1._UnderlyingPtr : null);
                return __ret is not null ? new MR.CS.Std.Const_Ostream(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_uniqueptr`.
            /// Parameter `b` defaults to `std::move(default_uniqueptr)`.
            public static unsafe void *testUniqueptr(void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_uniqueptr(void *a, void *b);
                return __MR_CSharp_test_uniqueptr(a, b);
            }

            /// Generated from function `MR::CSharp::test_uniqueptr_ref`.
            /// Parameter `b` defaults to `default_uniqueptr`.
            public static unsafe MR.CS.Std.UniquePtr_Int testUniqueptrRef(MR.CS.Std.UniquePtr_Int a, MR.CS.Std.UniquePtr_Int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_ref", ExactSpelling = true)]
                extern static MR.CS.Std.UniquePtr_Int._Underlying *__MR_CSharp_test_uniqueptr_ref(MR.CS.Std.UniquePtr_Int._Underlying *a, MR.CS.Std.UniquePtr_Int._Underlying *b);
                return new(__MR_CSharp_test_uniqueptr_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_uniqueptr_cref`.
            /// Parameter `b` defaults to `default_uniqueptr`.
            public static unsafe MR.CS.Std.Const_UniquePtr_Int testUniqueptrCref(MR.CS.Std.Const_UniquePtr_Int a, MR.CS.Std.Const_UniquePtr_Int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_UniquePtr_Int._Underlying *__MR_CSharp_test_uniqueptr_cref(MR.CS.Std.Const_UniquePtr_Int._Underlying *a, MR.CS.Std.Const_UniquePtr_Int._Underlying *b);
                return new(__MR_CSharp_test_uniqueptr_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_uniqueptr_ptr`.
            /// Parameter `c` defaults to `&default_uniqueptr`.
            public static unsafe MR.CS.Std.UniquePtr_Int? testUniqueptrPtr(MR.CS.Std.UniquePtr_Int? a, MR.CS.Std.UniquePtr_Int? b = null, MR.CS.Std._InOptMut_UniquePtr_Int? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.UniquePtr_Int._Underlying *__MR_CSharp_test_uniqueptr_ptr(MR.CS.Std.UniquePtr_Int._Underlying *a, MR.CS.Std.UniquePtr_Int._Underlying *b, MR.CS.Std.UniquePtr_Int._Underlying **c);
                MR.CS.Std.UniquePtr_Int._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_uniqueptr_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.UniquePtr_Int(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_uniqueptr_cptr`.
            /// Parameter `c` defaults to `&default_uniqueptr`.
            public static unsafe MR.CS.Std.Const_UniquePtr_Int? testUniqueptrCptr(MR.CS.Std.Const_UniquePtr_Int? a, MR.CS.Std.Const_UniquePtr_Int? b = null, MR.CS.Std._InOptConst_UniquePtr_Int? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_UniquePtr_Int._Underlying *__MR_CSharp_test_uniqueptr_cptr(MR.CS.Std.Const_UniquePtr_Int._Underlying *a, MR.CS.Std.Const_UniquePtr_Int._Underlying *b, MR.CS.Std.Const_UniquePtr_Int._Underlying **c);
                MR.CS.Std.Const_UniquePtr_Int._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_uniqueptr_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_UniquePtr_Int(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_plainarr_ref`.
            /// Parameter `b` defaults to `default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ArrayInt42 testPlainarrRef(ref MR.CS.ArrayInt42 a, MR.CS.ArrayInt42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 *__MR_CSharp_test_plainarr_ref(MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 *b);
                fixed (MR.CS.ArrayInt42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr_cref`.
            /// Parameter `b` defaults to `default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ConstArrayInt42 testPlainarrCref(ref MR.CS.ConstArrayInt42 a, MR.CS.ConstArrayInt42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 *__MR_CSharp_test_plainarr_cref(MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 *b);
                fixed (MR.CS.ConstArrayInt42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray&&)default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ArrayInt42 testPlainarrRref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ArrayInt42 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ArrayInt42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_rref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 *__MR_CSharp_test_plainarr_rref(MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 *b);
                fixed (MR.CS.ArrayInt42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_rref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray&&)default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ConstArrayInt42 testPlainarrCrref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ConstArrayInt42 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ConstArrayInt42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_crref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 *__MR_CSharp_test_plainarr_crref(MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 *b);
                fixed (MR.CS.ConstArrayInt42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_crref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr_ptr`.
            /// Parameter `c` defaults to `&default_plainarr`.
            public static unsafe MR.CS.ArrayInt42 *testPlainarrPtr(MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 *b = null, MR.CS.ArrayInt42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 *__MR_CSharp_test_plainarr_ptr(MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 *b, MR.CS.ArrayInt42 **c);
                return __MR_CSharp_test_plainarr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarr_cptr`.
            /// Parameter `c` defaults to `&default_plainarr`.
            public static unsafe MR.CS.ConstArrayInt42 *testPlainarrCptr(MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 *b = null, MR.CS.ConstArrayInt42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 *__MR_CSharp_test_plainarr_cptr(MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 *b, MR.CS.ConstArrayInt42 **c);
                return __MR_CSharp_test_plainarr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarr2_ref`.
            /// Parameter `b` defaults to `default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ArrayInt10_20 testPlainarr2Ref(ref MR.CS.ArrayInt10_20 a, MR.CS.ArrayInt10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt10_20 *__MR_CSharp_test_plainarr2_ref(MR.CS.ArrayInt10_20 *a, MR.CS.ArrayInt10_20 *b);
                fixed (MR.CS.ArrayInt10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr2_cref`.
            /// Parameter `b` defaults to `default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ConstArrayInt10_20 testPlainarr2Cref(ref MR.CS.ConstArrayInt10_20 a, MR.CS.ConstArrayInt10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt10_20 *__MR_CSharp_test_plainarr2_cref(MR.CS.ConstArrayInt10_20 *a, MR.CS.ConstArrayInt10_20 *b);
                fixed (MR.CS.ConstArrayInt10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr2_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray2&&)default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ArrayInt10_20 testPlainarr2Rref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ArrayInt10_20 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ArrayInt10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_rref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt10_20 *__MR_CSharp_test_plainarr2_rref(MR.CS.ArrayInt10_20 *a, MR.CS.ArrayInt10_20 *b);
                fixed (MR.CS.ArrayInt10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_rref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr2_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray2&&)default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ConstArrayInt10_20 testPlainarr2Crref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ConstArrayInt10_20 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ConstArrayInt10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_crref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt10_20 *__MR_CSharp_test_plainarr2_crref(MR.CS.ConstArrayInt10_20 *a, MR.CS.ConstArrayInt10_20 *b);
                fixed (MR.CS.ConstArrayInt10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_crref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarr2_ptr`.
            /// Parameter `c` defaults to `&default_plainarr2`.
            public static unsafe MR.CS.ArrayInt10_20 *testPlainarr2Ptr(MR.CS.ArrayInt10_20 *a, MR.CS.ArrayInt10_20 *b = null, MR.CS.ArrayInt10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt10_20 *__MR_CSharp_test_plainarr2_ptr(MR.CS.ArrayInt10_20 *a, MR.CS.ArrayInt10_20 *b, MR.CS.ArrayInt10_20 **c);
                return __MR_CSharp_test_plainarr2_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarr2_cptr`.
            /// Parameter `c` defaults to `&default_plainarr2`.
            public static unsafe MR.CS.ConstArrayInt10_20 *testPlainarr2Cptr(MR.CS.ConstArrayInt10_20 *a, MR.CS.ConstArrayInt10_20 *b = null, MR.CS.ConstArrayInt10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt10_20 *__MR_CSharp_test_plainarr2_cptr(MR.CS.ConstArrayInt10_20 *a, MR.CS.ConstArrayInt10_20 *b, MR.CS.ConstArrayInt10_20 **c);
                return __MR_CSharp_test_plainarr2_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarrenum_ref`.
            /// Parameter `b` defaults to `default_plainarrenum`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.CSharp.ArrayE1_42 testPlainarrenumRef(ref MR.CS.CSharp.ArrayE1_42 a, MR.CS.CSharp.ArrayE1_42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_42 *__MR_CSharp_test_plainarrenum_ref(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b);
                fixed (MR.CS.CSharp.ArrayE1_42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarrenum_cref`.
            /// Parameter `b` defaults to `default_plainarrenum`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.CSharp.ConstArrayE1_42 testPlainarrenumCref(ref MR.CS.CSharp.ConstArrayE1_42 a, MR.CS.CSharp.ConstArrayE1_42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_42 *__MR_CSharp_test_plainarrenum_cref(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b);
                fixed (MR.CS.CSharp.ConstArrayE1_42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarrenum_ptr`.
            /// Parameter `c` defaults to `&default_plainarrenum`.
            public static unsafe MR.CS.CSharp.ArrayE1_42 *testPlainarrenumPtr(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b = null, MR.CS.CSharp.ArrayE1_42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_42 *__MR_CSharp_test_plainarrenum_ptr(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b, MR.CS.CSharp.ArrayE1_42 **c);
                return __MR_CSharp_test_plainarrenum_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarrenum_cptr`.
            /// Parameter `c` defaults to `&default_plainarrenum`.
            public static unsafe MR.CS.CSharp.ConstArrayE1_42 *testPlainarrenumCptr(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b = null, MR.CS.CSharp.ConstArrayE1_42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_42 *__MR_CSharp_test_plainarrenum_cptr(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b, MR.CS.CSharp.ConstArrayE1_42 **c);
                return __MR_CSharp_test_plainarrenum_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarrenum2_ref`.
            /// Parameter `b` defaults to `default_plainarrenum2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.CSharp.ArrayE1_10_20 testPlainarrenum2Ref(ref MR.CS.CSharp.ArrayE1_10_20 a, MR.CS.CSharp.ArrayE1_10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_ref(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b);
                fixed (MR.CS.CSharp.ArrayE1_10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum2_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarrenum2_cref`.
            /// Parameter `b` defaults to `default_plainarrenum2`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.CSharp.ConstArrayE1_10_20 testPlainarrenum2Cref(ref MR.CS.CSharp.ConstArrayE1_10_20 a, MR.CS.CSharp.ConstArrayE1_10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_cref(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b);
                fixed (MR.CS.CSharp.ConstArrayE1_10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum2_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_plainarrenum2_ptr`.
            /// Parameter `c` defaults to `&default_plainarrenum2`.
            public static unsafe MR.CS.CSharp.ArrayE1_10_20 *testPlainarrenum2Ptr(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b = null, MR.CS.CSharp.ArrayE1_10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_ptr(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b, MR.CS.CSharp.ArrayE1_10_20 **c);
                return __MR_CSharp_test_plainarrenum2_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_plainarrenum2_cptr`.
            /// Parameter `c` defaults to `&default_plainarrenum2`.
            public static unsafe MR.CS.CSharp.ConstArrayE1_10_20 *testPlainarrenum2Cptr(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b = null, MR.CS.CSharp.ConstArrayE1_10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_cptr(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b, MR.CS.CSharp.ConstArrayE1_10_20 **c);
                return __MR_CSharp_test_plainarrenum2_cptr(a, b, c);
            }

            // Some multi-level pointer madness:
            /// Generated from function `MR::CSharp::test_ptrs1`.
            public static unsafe MR.CS.ArrayInt42 **testPtrs1(MR.CS.ArrayInt42 **ptr, ref MR.CS.ArrayInt42 *ref_)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ptrs1", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 **__MR_CSharp_test_ptrs1(MR.CS.ArrayInt42 **ptr, MR.CS.ArrayInt42 **ref_);
                fixed (MR.CS.ArrayInt42 **__ptr_ref_ = &ref_)
                {
                    return __MR_CSharp_test_ptrs1(ptr, __ptr_ref_);
                }
            }

            /// Generated from function `MR::CSharp::test_ptrs2`.
            public static unsafe MR.CS.ArrayInt42 ***testPtrs2(MR.CS.ArrayInt42 ***ptr, ref MR.CS.ArrayInt42 **ref_)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ptrs2", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 ***__MR_CSharp_test_ptrs2(MR.CS.ArrayInt42 ***ptr, MR.CS.ArrayInt42 ***ref_);
                fixed (MR.CS.ArrayInt42 ***__ptr_ref_ = &ref_)
                {
                    return __MR_CSharp_test_ptrs2(ptr, __ptr_ref_);
                }
            }

            /// Generated from function `MR::CSharp::test_intptr_ref`.
            /// Parameter `b` defaults to `default_intptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref int *testIntptrRef(ref int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_ref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_ref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intptr_cref`.
            /// Parameter `b` defaults to `default_intptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly int *testIntptrCref(in int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_cref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_cref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intptr_ptr`.
            /// Parameter `c` defaults to `&default_intptr`.
            public static unsafe int **testIntptrPtr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_ptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_ptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_intptr_cptr`.
            /// Parameter `c` defaults to `&default_intptr`.
            public static unsafe int **testIntptrCptr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_cptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_cptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_intcptr_ref`.
            /// Parameter `b` defaults to `default_intcptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref int *testIntcptrRef(ref int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_ref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_ref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intcptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intcptr_cref`.
            /// Parameter `b` defaults to `default_intcptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly int *testIntcptrCref(in int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_cref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_cref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intcptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intcptr_ptr`.
            /// Parameter `c` defaults to `&default_intcptr`.
            public static unsafe int **testIntcptrPtr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_ptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_ptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intcptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_intcptr_cptr`.
            /// Parameter `c` defaults to `&default_intcptr`.
            public static unsafe int **testIntcptrCptr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_cptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_cptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intcptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_intptrptr_ref`.
            /// Parameter `b` defaults to `default_intptrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref int **testIntptrptrRef(ref int **a, int ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_ref", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_ref(int ***a, int ***b);
                fixed (int ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptrptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intptrptr_cref`.
            /// Parameter `b` defaults to `default_intptrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly int **testIntptrptrCref(in int **a, int ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_cref", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_cref(int ***a, int ***b);
                fixed (int ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptrptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_intptrptr_ptr`.
            /// Parameter `c` defaults to `&default_intptrptr`.
            public static unsafe int ***testIntptrptrPtr(int ***a, int ***b = null, int ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_ptr", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_ptr(int ***a, int ***b, int ****c);
                return __MR_CSharp_test_intptrptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_intptrptr_cptr`.
            /// Parameter `c` defaults to `&default_intptrptr`.
            public static unsafe int ***testIntptrptrCptr(int ***a, int ***b = null, int ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_cptr", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_cptr(int ***a, int ***b, int ****c);
                return __MR_CSharp_test_intptrptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_voidptr_ref`.
            /// Parameter `b` defaults to `default_voidptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref void *testVoidptrRef(ref void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_ref", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_ref(void **a, void **b);
                fixed (void **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_voidptr_cref`.
            /// Parameter `b` defaults to `default_voidptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly void *testVoidptrCref(in void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_cref", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_cref(void **a, void **b);
                fixed (void **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_voidptr_ptr`.
            /// Parameter `c` defaults to `&default_voidptr`.
            public static unsafe void **testVoidptrPtr(void **a, void **b = null, void ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_ptr", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_ptr(void **a, void **b, void ***c);
                return __MR_CSharp_test_voidptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_voidptr_cptr`.
            /// Parameter `c` defaults to `&default_voidptr`.
            public static unsafe void **testVoidptrCptr(void **a, void **b = null, void ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_cptr", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_cptr(void **a, void **b, void ***c);
                return __MR_CSharp_test_voidptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_voidptrptr_ref`.
            /// Parameter `b` defaults to `default_voidptrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref void **testVoidptrptrRef(ref void **a, void ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_ref", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_ref(void ***a, void ***b);
                fixed (void ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptrptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_voidptrptr_cref`.
            /// Parameter `b` defaults to `default_voidptrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly void **testVoidptrptrCref(in void **a, void ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_cref", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_cref(void ***a, void ***b);
                fixed (void ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptrptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_voidptrptr_ptr`.
            /// Parameter `c` defaults to `&default_voidptrptr`.
            public static unsafe void ***testVoidptrptrPtr(void ***a, void ***b = null, void ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_ptr", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_ptr(void ***a, void ***b, void ****c);
                return __MR_CSharp_test_voidptrptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_voidptrptr_cptr`.
            /// Parameter `c` defaults to `&default_voidptrptr`.
            public static unsafe void ***testVoidptrptrCptr(void ***a, void ***b = null, void ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_cptr", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_cptr(void ***a, void ***b, void ****c);
                return __MR_CSharp_test_voidptrptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_arrptr_ref`.
            /// Parameter `b` defaults to `default_arrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ArrayInt42 *testArrptrRef(ref MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 **__MR_CSharp_test_arrptr_ref(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b);
                fixed (MR.CS.ArrayInt42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_arrptr_cref`.
            /// Parameter `b` defaults to `default_arrptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly MR.CS.ArrayInt42 *testArrptrCref(in MR.CS.ArrayInt42 *a, MR.CS.ArrayInt42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_cref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 **__MR_CSharp_test_arrptr_cref(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b);
                fixed (MR.CS.ArrayInt42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_arrptr_ptr`.
            /// Parameter `c` defaults to `&default_arrptr`.
            public static unsafe MR.CS.ArrayInt42 **testArrptrPtr(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b = null, MR.CS.ArrayInt42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 **__MR_CSharp_test_arrptr_ptr(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b, MR.CS.ArrayInt42 ***c);
                return __MR_CSharp_test_arrptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_arrptr_cptr`.
            /// Parameter `c` defaults to `&default_arrptr`.
            public static unsafe MR.CS.ArrayInt42 **testArrptrCptr(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b = null, MR.CS.ArrayInt42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_cptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt42 **__MR_CSharp_test_arrptr_cptr(MR.CS.ArrayInt42 **a, MR.CS.ArrayInt42 **b, MR.CS.ArrayInt42 ***c);
                return __MR_CSharp_test_arrptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_arrcptr_ref`.
            /// Parameter `b` defaults to `default_arrcptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref MR.CS.ConstArrayInt42 *testArrcptrRef(ref MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_ref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 **__MR_CSharp_test_arrcptr_ref(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b);
                fixed (MR.CS.ConstArrayInt42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrcptr_ref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_arrcptr_cref`.
            /// Parameter `b` defaults to `default_arrcptr`.
            /// In C++ this function returns an rvalue reference.
            public static unsafe ref readonly MR.CS.ConstArrayInt42 *testArrcptrCref(in MR.CS.ConstArrayInt42 *a, MR.CS.ConstArrayInt42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 **__MR_CSharp_test_arrcptr_cref(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b);
                fixed (MR.CS.ConstArrayInt42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrcptr_cref(__ptr_a, b);
                }
            }

            /// Generated from function `MR::CSharp::test_arrcptr_ptr`.
            /// Parameter `c` defaults to `&default_arrcptr`.
            public static unsafe MR.CS.ConstArrayInt42 **testArrcptrPtr(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b = null, MR.CS.ConstArrayInt42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_ptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 **__MR_CSharp_test_arrcptr_ptr(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b, MR.CS.ConstArrayInt42 ***c);
                return __MR_CSharp_test_arrcptr_ptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::test_arrcptr_cptr`.
            /// Parameter `c` defaults to `&default_arrcptr`.
            public static unsafe MR.CS.ConstArrayInt42 **testArrcptrCptr(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b = null, MR.CS.ConstArrayInt42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt42 **__MR_CSharp_test_arrcptr_cptr(MR.CS.ConstArrayInt42 **a, MR.CS.ConstArrayInt42 **b, MR.CS.ConstArrayInt42 ***c);
                return __MR_CSharp_test_arrcptr_cptr(a, b, c);
            }

            /// Generated from function `MR::CSharp::nameConflicts`.
            public static void nameConflicts()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_nameConflicts", ExactSpelling = true)]
                extern static void __MR_CSharp_nameConflicts();
                __MR_CSharp_nameConflicts();
            }

            /// Generated from function `MR::CSharp::nameConflictsExposed`.
            public static void nameConflictsExposed()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_nameConflictsExposed", ExactSpelling = true)]
                extern static void __MR_CSharp_nameConflictsExposed();
                __MR_CSharp_nameConflictsExposed();
            }

            // Test how template arguments are added to function names when needed to avoid ambiguities.
            /// Generated from function `MR::CSharp::template_a<int>`.
            public static void templateA(int _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_a_int", ExactSpelling = true)]
                extern static void __MR_CSharp_template_a_int(int _1);
                __MR_CSharp_template_a_int(_1);
            }

            // Test how template arguments are added to function names when needed to avoid ambiguities.
            /// Generated from function `MR::CSharp::template_a<float>`.
            public static void templateA(float _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_a_float", ExactSpelling = true)]
                extern static void __MR_CSharp_template_a_float(float _1);
                __MR_CSharp_template_a_float(_1);
            }

            /// Generated from function `MR::CSharp::template_b<int>`.
            public static int templateB_Int()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_b_int", ExactSpelling = true)]
                extern static int __MR_CSharp_template_b_int();
                return __MR_CSharp_template_b_int();
            }

            /// Generated from function `MR::CSharp::template_b<float>`.
            public static float templateB_Float()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_b_float", ExactSpelling = true)]
                extern static float __MR_CSharp_template_b_float();
                return __MR_CSharp_template_b_float();
            }

            /// Generated from function `MR::CSharp::template_c<int>`.
            public static void templateC_Int()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_c_int", ExactSpelling = true)]
                extern static void __MR_CSharp_template_c_int();
                __MR_CSharp_template_c_int();
            }

            /// Generated from function `MR::CSharp::template_c<float>`.
            public static void templateC_Float()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_c_float", ExactSpelling = true)]
                extern static void __MR_CSharp_template_c_float();
                __MR_CSharp_template_c_float();
            }

            /// Generated from function `MR::CSharp::instantiate`.
            public static void instantiate()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_instantiate", ExactSpelling = true)]
                extern static void __MR_CSharp_instantiate();
                __MR_CSharp_instantiate();
            }

            /// Generated from function `MR::CSharp::test_expected_int`.
            /// Parameter `b` defaults to `std::expected<int, float>{42}`.
            public static unsafe MR.CS.Std.Expected_Int_Float testExpectedInt(MR.CS.Std.Const_Expected_Int_Float a, MR.CS.Std.Const_Expected_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Int_Float._Underlying *__MR_CSharp_test_expected_int(MR.CS.Std.Expected_Int_Float._Underlying *a, MR.CS.Std.Expected_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_int_ref`.
            /// Parameter `b` defaults to `default_expected_int`.
            public static unsafe MR.CS.Std.Expected_Int_Float testExpectedIntRef(MR.CS.Std.Expected_Int_Float a, MR.CS.Std.Expected_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Int_Float._Underlying *__MR_CSharp_test_expected_int_ref(MR.CS.Std.Expected_Int_Float._Underlying *a, MR.CS.Std.Expected_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_int_cref`.
            /// Parameter `b` defaults to `default_expected_int`.
            public static unsafe MR.CS.Std.Const_Expected_Int_Float testExpectedIntCref(MR.CS.Std.Const_Expected_Int_Float a, MR.CS.Std.Const_Expected_Int_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_Int_Float._Underlying *__MR_CSharp_test_expected_int_cref(MR.CS.Std.Const_Expected_Int_Float._Underlying *a, MR.CS.Std.Const_Expected_Int_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_int_ptr`.
            /// Parameter `c` defaults to `&default_expected_int`.
            public static unsafe MR.CS.Std.Expected_Int_Float? testExpectedIntPtr(MR.CS.Std.Expected_Int_Float? a, MR.CS.Std.Expected_Int_Float? b = null, MR.CS.Std._InOptMut_Expected_Int_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Int_Float._Underlying *__MR_CSharp_test_expected_int_ptr(MR.CS.Std.Expected_Int_Float._Underlying *a, MR.CS.Std.Expected_Int_Float._Underlying *b, MR.CS.Std.Expected_Int_Float._Underlying **c);
                MR.CS.Std.Expected_Int_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_int_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_Int_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_int_cptr`.
            /// Parameter `c` defaults to `&default_expected_int`.
            public static unsafe MR.CS.Std.Const_Expected_Int_Float? testExpectedIntCptr(MR.CS.Std.Const_Expected_Int_Float? a, MR.CS.Std.Const_Expected_Int_Float? b = null, MR.CS.Std._InOptConst_Expected_Int_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_Int_Float._Underlying *__MR_CSharp_test_expected_int_cptr(MR.CS.Std.Const_Expected_Int_Float._Underlying *a, MR.CS.Std.Const_Expected_Int_Float._Underlying *b, MR.CS.Std.Const_Expected_Int_Float._Underlying **c);
                MR.CS.Std.Const_Expected_Int_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_int_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_Int_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_void`.
            /// Parameter `b` defaults to `std::expected<void, float>{}`.
            public static unsafe MR.CS.Std.Expected_Void_Float testExpectedVoid(MR.CS.Std.Const_Expected_Void_Float a, MR.CS.Std.Const_Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void(MR.CS.Std.Expected_Void_Float._Underlying *a, MR.CS.Std.Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_void_ref`.
            /// Parameter `b` defaults to `default_expected_void`.
            public static unsafe MR.CS.Std.Expected_Void_Float testExpectedVoidRef(MR.CS.Std.Expected_Void_Float a, MR.CS.Std.Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_ref(MR.CS.Std.Expected_Void_Float._Underlying *a, MR.CS.Std.Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_void_cref`.
            /// Parameter `b` defaults to `default_expected_void`.
            public static unsafe MR.CS.Std.Const_Expected_Void_Float testExpectedVoidCref(MR.CS.Std.Const_Expected_Void_Float a, MR.CS.Std.Const_Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_cref(MR.CS.Std.Const_Expected_Void_Float._Underlying *a, MR.CS.Std.Const_Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_void_ptr`.
            /// Parameter `c` defaults to `&default_expected_void`.
            public static unsafe MR.CS.Std.Expected_Void_Float? testExpectedVoidPtr(MR.CS.Std.Expected_Void_Float? a, MR.CS.Std.Expected_Void_Float? b = null, MR.CS.Std._InOptMut_Expected_Void_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_ptr(MR.CS.Std.Expected_Void_Float._Underlying *a, MR.CS.Std.Expected_Void_Float._Underlying *b, MR.CS.Std.Expected_Void_Float._Underlying **c);
                MR.CS.Std.Expected_Void_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_void_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_Void_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_void_cptr`.
            /// Parameter `c` defaults to `&default_expected_void`.
            public static unsafe MR.CS.Std.Const_Expected_Void_Float? testExpectedVoidCptr(MR.CS.Std.Const_Expected_Void_Float? a, MR.CS.Std.Const_Expected_Void_Float? b = null, MR.CS.Std._InOptConst_Expected_Void_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_cptr(MR.CS.Std.Const_Expected_Void_Float._Underlying *a, MR.CS.Std.Const_Expected_Void_Float._Underlying *b, MR.CS.Std.Const_Expected_Void_Float._Underlying **c);
                MR.CS.Std.Const_Expected_Void_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_void_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_Void_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_enum`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::E1, float>{E1::b}`.
            public static unsafe MR.CS.Std.Expected_MRCSharpE1_Float testExpectedEnum(MR.CS.Std.Const_Expected_MRCSharpE1_Float a, MR.CS.Std.Const_Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum(MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_enum_ref`.
            /// Parameter `b` defaults to `default_expected_enum`.
            public static unsafe MR.CS.Std.Expected_MRCSharpE1_Float testExpectedEnumRef(MR.CS.Std.Expected_MRCSharpE1_Float a, MR.CS.Std.Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_ref(MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_enum_cref`.
            /// Parameter `b` defaults to `default_expected_enum`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpE1_Float testExpectedEnumCref(MR.CS.Std.Const_Expected_MRCSharpE1_Float a, MR.CS.Std.Const_Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_cref(MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_enum_ptr`.
            /// Parameter `c` defaults to `&default_expected_enum`.
            public static unsafe MR.CS.Std.Expected_MRCSharpE1_Float? testExpectedEnumPtr(MR.CS.Std.Expected_MRCSharpE1_Float? a, MR.CS.Std.Expected_MRCSharpE1_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpE1_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_ptr(MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpE1_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpE1_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_enum_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpE1_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_enum_cptr`.
            /// Parameter `c` defaults to `&default_expected_enum`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpE1_Float? testExpectedEnumCptr(MR.CS.Std.Const_Expected_MRCSharpE1_Float? a, MR.CS.Std.Const_Expected_MRCSharpE1_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpE1_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_cptr(MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpE1_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_enum_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpE1_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_triv`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::Trivial, float>{MR::CSharp::Trivial{}}`.
            public static unsafe MR.CS.Std.Expected_MRCSharpTrivial_Float testExpectedTriv(MR.CS.Std.Const_Expected_MRCSharpTrivial_Float a, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv(MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_triv_ref`.
            /// Parameter `b` defaults to `default_expected_triv`.
            public static unsafe MR.CS.Std.Expected_MRCSharpTrivial_Float testExpectedTrivRef(MR.CS.Std.Expected_MRCSharpTrivial_Float a, MR.CS.Std.Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_ref(MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_triv_cref`.
            /// Parameter `b` defaults to `default_expected_triv`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpTrivial_Float testExpectedTrivCref(MR.CS.Std.Const_Expected_MRCSharpTrivial_Float a, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_cref(MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_triv_ptr`.
            /// Parameter `c` defaults to `&default_expected_triv`.
            public static unsafe MR.CS.Std.Expected_MRCSharpTrivial_Float? testExpectedTrivPtr(MR.CS.Std.Expected_MRCSharpTrivial_Float? a, MR.CS.Std.Expected_MRCSharpTrivial_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_ptr(MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_triv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpTrivial_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_triv_cptr`.
            /// Parameter `c` defaults to `&default_expected_triv`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpTrivial_Float? testExpectedTrivCptr(MR.CS.Std.Const_Expected_MRCSharpTrivial_Float? a, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_cptr(MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_triv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpTrivial_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_nontriv`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::NonTrivial, float>{MR::CSharp::NonTrivial{}}`.
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Expected_MRCSharpNonTrivial_Float> testExpectedNontriv(MR.CS.Std._ByValue_Expected_MRCSharpNonTrivial_Float a, MR.CS.Std._ByValue_Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv(MR.CS.Misc._PassBy a_pass_by, MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.Std.Expected_MRCSharpNonTrivial_Float(__MR_CSharp_test_expected_nontriv(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// Generated from function `MR::CSharp::test_expected_nontriv_ref`.
            /// Parameter `b` defaults to `default_expected_nontriv`.
            public static unsafe MR.CS.Std.Expected_MRCSharpNonTrivial_Float testExpectedNontrivRef(MR.CS.Std.Expected_MRCSharpNonTrivial_Float a, MR.CS.Std.Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_ref(MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_nontriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_nontriv_cref`.
            /// Parameter `b` defaults to `default_expected_nontriv`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float testExpectedNontrivCref(MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float a, MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_cref(MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_nontriv_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_nontriv_ptr`.
            /// Parameter `c` defaults to `&default_expected_nontriv`.
            public static unsafe MR.CS.Std.Expected_MRCSharpNonTrivial_Float? testExpectedNontrivPtr(MR.CS.Std.Expected_MRCSharpNonTrivial_Float? a, MR.CS.Std.Expected_MRCSharpNonTrivial_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpNonTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_ptr(MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpNonTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_nontriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpNonTrivial_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_nontriv_cptr`.
            /// Parameter `c` defaults to `&default_expected_nontriv`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float? testExpectedNontrivCptr(MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float? a, MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpNonTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_cptr(MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_nontriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpNonTrivial_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_shared`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::SA, float>{MR::CSharp::SA{}}`.
            public static unsafe MR.CS.Std.Expected_MRCSharpSA_Float testExpectedShared(MR.CS.Std.Const_Expected_MRCSharpSA_Float a, MR.CS.Std.Const_Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared(MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_shared_ref`.
            /// Parameter `b` defaults to `default_expected_shared`.
            public static unsafe MR.CS.Std.Expected_MRCSharpSA_Float testExpectedSharedRef(MR.CS.Std.Expected_MRCSharpSA_Float a, MR.CS.Std.Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_ref(MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_shared_cref`.
            /// Parameter `b` defaults to `default_expected_shared`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpSA_Float testExpectedSharedCref(MR.CS.Std.Const_Expected_MRCSharpSA_Float a, MR.CS.Std.Const_Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_cref(MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_shared_ptr`.
            /// Parameter `c` defaults to `&default_expected_shared`.
            public static unsafe MR.CS.Std.Expected_MRCSharpSA_Float? testExpectedSharedPtr(MR.CS.Std.Expected_MRCSharpSA_Float? a, MR.CS.Std.Expected_MRCSharpSA_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpSA_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_ptr(MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpSA_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpSA_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_shared_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpSA_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_shared_cptr`.
            /// Parameter `c` defaults to `&default_expected_shared`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpSA_Float? testExpectedSharedCptr(MR.CS.Std.Const_Expected_MRCSharpSA_Float? a, MR.CS.Std.Const_Expected_MRCSharpSA_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpSA_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_cptr(MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpSA_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_shared_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpSA_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_exposed`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::ExposedLayout, float>{MR::CSharp::ExposedLayout{}}`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayout_Float testExpectedExposed(MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float a, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed(MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_ref`.
            /// Parameter `b` defaults to `default_expected_exposed`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayout_Float testExpectedExposedRef(MR.CS.Std.Expected_MRCSharpExposedLayout_Float a, MR.CS.Std.Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_ref(MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_cref`.
            /// Parameter `b` defaults to `default_expected_exposed`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float testExpectedExposedCref(MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float a, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_cref(MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_ptr`.
            /// Parameter `c` defaults to `&default_expected_exposed`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayout_Float? testExpectedExposedPtr(MR.CS.Std.Expected_MRCSharpExposedLayout_Float? a, MR.CS.Std.Expected_MRCSharpExposedLayout_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpExposedLayout_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_ptr(MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpExposedLayout_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_exposed_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpExposedLayout_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_cptr`.
            /// Parameter `c` defaults to `&default_expected_exposed`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float? testExpectedExposedCptr(MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float? a, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpExposedLayout_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_cptr(MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_exposed_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpExposedLayout_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_shared`.
            /// Parameter `b` defaults to `std::expected<MR::CSharp::ExposedLayoutSh, float>{MR::CSharp::ExposedLayoutSh{}}`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedShared(MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared(MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_shared_ref`.
            /// Parameter `b` defaults to `default_expected_exposed_shared`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedSharedRef(MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_ref(MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_shared_cref`.
            /// Parameter `b` defaults to `default_expected_exposed_shared`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedSharedCref(MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_cref(MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_shared_ptr`.
            /// Parameter `c` defaults to `&default_expected_exposed_shared`.
            public static unsafe MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float? testExpectedExposedSharedPtr(MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float? a, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float? b = null, MR.CS.Std._InOptMut_Expected_MRCSharpExposedLayoutSh_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_ptr(MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b, MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying **c);
                MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_exposed_shared_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Expected_MRCSharpExposedLayoutSh_Float(__ret, is_owning: false) : null;
            }

            /// Generated from function `MR::CSharp::test_expected_exposed_shared_cptr`.
            /// Parameter `c` defaults to `&default_expected_exposed_shared`.
            public static unsafe MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float? testExpectedExposedSharedCptr(MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float? a, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null, MR.CS.Std._InOptConst_Expected_MRCSharpExposedLayoutSh_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_cptr(MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *b, MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying **c);
                MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __ret = __MR_CSharp_test_expected_exposed_shared_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __ret is not null ? new MR.CS.Std.Const_Expected_MRCSharpExposedLayoutSh_Float(__ret, is_owning: false) : null;
            }
        }
    }
}

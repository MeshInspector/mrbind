public static partial class MR
{
    public static partial class CS
    {
        public static partial class CSharp
        {
            /// <summary>
            /// Enum comment.
            /// </summary>
            public enum E1 : int
            {
                // A
                A = 10,
                // B
                B = 20,
                // C
                C = 30,
            }

            /// <summary>
            /// This enum is intended to be boolean.
            /// </summary>
            public enum E2 : byte
            {
                A = 0,
                B = 1,
            }

            /// <summary>
            /// Generated from class `MR::CSharp::A`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::C`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::B`
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the const half of the class.
            /// </summary>
            public class Const_A : MR.CS.Misc.Object<Const_A>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_Destroy(_Underlying *_this);
                    __MR_CSharp_A_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_A() {Dispose(false);}

                internal unsafe Const_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_A() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_A_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public unsafe Const_A(MR.CS.CSharp._ByValue_A _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_A_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public Const_A(Const_A _other) : this(new _ByValue_A(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public Const_A(A _other) : this((Const_A)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::A::bar`.
                /// </summary>
                public unsafe void bar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_A_bar(_UnderlyingPtr, _1, _2);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::static_foo`.
                /// </summary>
                public static void staticFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_static_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_static_foo();
                    __MR_CSharp_A_static_foo();
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::static_bar`.
                /// </summary>
                public static void staticBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_static_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_static_bar(int _1, int _2);
                    __MR_CSharp_A_static_bar(_1, _2);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::virtual_bar`.
                /// </summary>
                public unsafe void virtualBar(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_virtual_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_virtual_bar(_Underlying *_this, int _1, int _2);
                    __MR_CSharp_A_virtual_bar(_UnderlyingPtr, _1, _2);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::A`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::C`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::B`
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the non-const half of the class.
            /// </summary>
            public class A : Const_A
            {
                internal unsafe A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe A() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_A_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public unsafe A(MR.CS.CSharp._ByValue_A _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_A_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public A(Const_A _other) : this(new _ByValue_A(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::A::A`.
                /// </summary>
                public A(A _other) : this((Const_A)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::A::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.A assign(MR.CS.CSharp._ByValue_A _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_A_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.A._Underlying *_other);
                    MR.CS.CSharp.A __ret;
                    __ret = new(__MR_CSharp_A_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    __ret._KeepAlive(this);
                    return __ret;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_foo(_Underlying *_this);
                    __MR_CSharp_A_foo(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::virtual_foo`.
                /// </summary>
                public unsafe void virtualFoo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_virtual_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_A_virtual_foo(_Underlying *_this);
                    __MR_CSharp_A_virtual_foo(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::A::refs`.
                /// </summary>
                public unsafe ref int refs(ref int x, ref int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_refs", ExactSpelling = true)]
                    extern static int *__MR_CSharp_A_refs(_Underlying *_this, int *x, int *_2);
                    fixed (int *__ptr_x = &x)
                    {
                        fixed (int *__ptr__2 = &_2)
                        {
                            return ref *__MR_CSharp_A_refs(_UnderlyingPtr, __ptr_x, __ptr__2);
                        }
                    }
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `A` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `A`/`Const_A` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_A
            {
                internal readonly Const_A? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_A() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_A(Const_A new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_A(Const_A arg) {return new(arg);}
                public _ByValue_A(MR.CS.Misc._Moved<A> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_A(MR.CS.Misc._Moved<A> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `A` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `A`/`Const_A` directly.
            /// </summary>
            public class _InOptMut_A
            {
                public A? Opt;

                public _InOptMut_A() {}
                public _InOptMut_A(A value) {Opt = value;}
                public static implicit operator _InOptMut_A(A value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `A` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `A`/`Const_A` to pass it to the function.
            /// </summary>
            public class _InOptConst_A
            {
                public Const_A? Opt;

                public _InOptConst_A() {}
                public _InOptConst_A(Const_A value) {Opt = value;}
                public static implicit operator _InOptConst_A(Const_A value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::B`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            /// This is the const half of the class.
            /// </summary>
            public class Const_B : MR.CS.Misc.Object<Const_B>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_B_Destroy(_Underlying *_this);
                    __MR_CSharp_B_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_B() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_B self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_B_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_B_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_B?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_B ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe Const_B(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_B() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_B_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public unsafe Const_B(MR.CS.CSharp._ByValue_B _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_B_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public Const_B(Const_B _other) : this(new _ByValue_B(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public Const_B(B _other) : this((Const_B)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public unsafe Const_B(int a, int b) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_Construct(int a, int b);
                    _UnderlyingPtr = __MR_CSharp_B_Construct(a, b);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::B`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            /// This is the non-const half of the class.
            /// </summary>
            public class B : Const_B
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(B self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_B_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_B_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator B?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_B(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    B ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe B(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe B() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_B_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public unsafe B(MR.CS.CSharp._ByValue_B _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_B_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public B(Const_B _other) : this(new _ByValue_B(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public B(B _other) : this((Const_B)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::B::B`.
                /// </summary>
                public unsafe B(int a, int b) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_Construct(int a, int b);
                    _UnderlyingPtr = __MR_CSharp_B_Construct(a, b);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::B::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.B assign(MR.CS.CSharp._ByValue_B _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_B_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.B._Underlying *__MR_CSharp_B_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.B._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_B_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `B` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `B`/`Const_B` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_B
            {
                internal readonly Const_B? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_B() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_B(Const_B new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_B(Const_B arg) {return new(arg);}
                public _ByValue_B(MR.CS.Misc._Moved<B> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_B(MR.CS.Misc._Moved<B> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `B` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_B`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `B`/`Const_B` directly.
            /// </summary>
            public class _InOptMut_B
            {
                public B? Opt;

                public _InOptMut_B() {}
                public _InOptMut_B(B value) {Opt = value;}
                public static implicit operator _InOptMut_B(B value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `B` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_B`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `B`/`Const_B` to pass it to the function.
            /// </summary>
            public class _InOptConst_B
            {
                public Const_B? Opt;

                public _InOptConst_B() {}
                public _InOptConst_B(Const_B value) {Opt = value;}
                public static implicit operator _InOptConst_B(Const_B value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::C`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::A`
            /// This is the const half of the class.
            /// </summary>
            public class Const_C : MR.CS.Misc.Object<Const_C>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_C_Destroy(_Underlying *_this);
                    __MR_CSharp_C_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_C() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_C self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_C_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_C_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_C?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_C ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe Const_C(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_C() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_C_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public unsafe Const_C(MR.CS.CSharp._ByValue_C _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_C_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public Const_C(Const_C _other) : this(new _ByValue_C(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public Const_C(C _other) : this((Const_C)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::C`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::A`
            /// This is the non-const half of the class.
            /// </summary>
            public class C : Const_C
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(C self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_C_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_C_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator C?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_C(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    C ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe C(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe C() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_C_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public unsafe C(MR.CS.CSharp._ByValue_C _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_C_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public C(Const_C _other) : this(new _ByValue_C(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::C::C`.
                /// </summary>
                public C(C _other) : this((Const_C)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::C::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.C assign(MR.CS.CSharp._ByValue_C _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_C_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.C._Underlying *__MR_CSharp_C_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.C._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_C_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `C` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `C`/`Const_C` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_C
            {
                internal readonly Const_C? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_C() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_C(Const_C new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_C(Const_C arg) {return new(arg);}
                public _ByValue_C(MR.CS.Misc._Moved<C> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_C(MR.CS.Misc._Moved<C> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `C` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_C`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `C`/`Const_C` directly.
            /// </summary>
            public class _InOptMut_C
            {
                public C? Opt;

                public _InOptMut_C() {}
                public _InOptMut_C(C value) {Opt = value;}
                public static implicit operator _InOptMut_C(C value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `C` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_C`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `C`/`Const_C` to pass it to the function.
            /// </summary>
            public class _InOptConst_C
            {
                public Const_C? Opt;

                public _InOptConst_C() {}
                public _InOptConst_C(Const_C value) {Opt = value;}
                public static implicit operator _InOptConst_C(Const_C value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::D`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the const half of the class.
            /// </summary>
            public class Const_D : MR.CS.Misc.Object<Const_D>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_Destroy(_Underlying *_this);
                    __MR_CSharp_D_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_D() {Dispose(false);}

                internal unsafe Const_D(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_D() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_D_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::D::D`.
                /// </summary>
                public unsafe Const_D(MR.CS.CSharp.Const_D _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_ConstructFromAnother(MR.CS.CSharp.D._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_D_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::D::D`.
                /// </summary>
                public Const_D(D _other) : this((Const_D)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::D::d1`.
                /// </summary>
                public unsafe void d1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_d1", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_d1(_Underlying *_this);
                    __MR_CSharp_D_d1(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::D`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            ///     `MR::CSharp::G`
            /// This is the non-const half of the class.
            /// </summary>
            public class D : Const_D
            {
                internal unsafe D(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe D() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_D_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::D::D`.
                /// </summary>
                public unsafe D(MR.CS.CSharp.Const_D _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_ConstructFromAnother(MR.CS.CSharp.D._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_D_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::D::D`.
                /// </summary>
                public D(D _other) : this((Const_D)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::D::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.D assign(MR.CS.CSharp.Const_D _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_D_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.D._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_D_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::D::d2`.
                /// </summary>
                public unsafe void d2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_D_d2", ExactSpelling = true)]
                    extern static void __MR_CSharp_D_d2(_Underlying *_this);
                    __MR_CSharp_D_d2(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `D` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_D`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `D`/`Const_D` directly.
            /// </summary>
            public class _InOptMut_D
            {
                public D? Opt;

                public _InOptMut_D() {}
                public _InOptMut_D(D value) {Opt = value;}
                public static implicit operator _InOptMut_D(D value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `D` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_D`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `D`/`Const_D` to pass it to the function.
            /// </summary>
            public class _InOptConst_D
            {
                public Const_D? Opt;

                public _InOptConst_D() {}
                public _InOptConst_D(Const_D value) {Opt = value;}
                public static implicit operator _InOptConst_D(Const_D value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::E`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::G`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            /// This is the const half of the class.
            /// </summary>
            public class Const_E : MR.CS.Misc.Object<Const_E>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_Destroy(_Underlying *_this);
                    __MR_CSharp_E_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_E() {Dispose(false);}

                internal unsafe Const_E(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_E() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_E_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::E::E`.
                /// </summary>
                public unsafe Const_E(MR.CS.CSharp.Const_E _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_ConstructFromAnother(MR.CS.CSharp.E._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_E_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::E::E`.
                /// </summary>
                public Const_E(E _other) : this((Const_E)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::E::e1`.
                /// </summary>
                public unsafe void e1()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_e1", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_e1(_Underlying *_this);
                    __MR_CSharp_E_e1(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::E`.
            /// Derived classes:
            ///   Virtual:
            ///     `MR::CSharp::G`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::F`
            /// This is the non-const half of the class.
            /// </summary>
            public class E : Const_E
            {
                internal unsafe E(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe E() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_E_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::E::E`.
                /// </summary>
                public unsafe E(MR.CS.CSharp.Const_E _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_ConstructFromAnother(MR.CS.CSharp.E._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_E_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::E::E`.
                /// </summary>
                public E(E _other) : this((Const_E)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::E::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.E assign(MR.CS.CSharp.Const_E _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_E_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.E._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_E_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::E::e2`.
                /// </summary>
                public unsafe void e2()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_E_e2", ExactSpelling = true)]
                    extern static void __MR_CSharp_E_e2(_Underlying *_this);
                    __MR_CSharp_E_e2(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `E` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_E`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `E`/`Const_E` directly.
            /// </summary>
            public class _InOptMut_E
            {
                public E? Opt;

                public _InOptMut_E() {}
                public _InOptMut_E(E value) {Opt = value;}
                public static implicit operator _InOptMut_E(E value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `E` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_E`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `E`/`Const_E` to pass it to the function.
            /// </summary>
            public class _InOptConst_E
            {
                public Const_E? Opt;

                public _InOptConst_E() {}
                public _InOptConst_E(Const_E value) {Opt = value;}
                public static implicit operator _InOptConst_E(Const_E value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::F`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            ///     `MR::CSharp::E`
            /// This is the const half of the class.
            /// </summary>
            public class Const_F : MR.CS.Misc.Object<Const_F>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_F_Destroy(_Underlying *_this);
                    __MR_CSharp_F_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_F() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_D(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_D._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.Const_D ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_E(Const_F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_E._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.Const_E ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_F?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_F ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe Const_F(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_F() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_F_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public unsafe Const_F(MR.CS.CSharp._ByValue_F _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_F_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public Const_F(Const_F _other) : this(new _ByValue_F(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public Const_F(F _other) : this((Const_F)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::F`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            ///     `MR::CSharp::E`
            /// This is the non-const half of the class.
            /// </summary>
            public class F : Const_F
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.D(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.D ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.E(F self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_F_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.E ret = new(__MR_CSharp_F_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator F?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_F(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    F ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe F(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe F() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_F_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public unsafe F(MR.CS.CSharp._ByValue_F _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_F_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public F(Const_F _other) : this(new _ByValue_F(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::F::F`.
                /// </summary>
                public F(F _other) : this((Const_F)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::F::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.F assign(MR.CS.CSharp._ByValue_F _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_F_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.F._Underlying *__MR_CSharp_F_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.F._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_F_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `F` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `F`/`Const_F` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_F
            {
                internal readonly Const_F? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_F() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_F(Const_F new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_F(Const_F arg) {return new(arg);}
                public _ByValue_F(MR.CS.Misc._Moved<F> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_F(MR.CS.Misc._Moved<F> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `F` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_F`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `F`/`Const_F` directly.
            /// </summary>
            public class _InOptMut_F
            {
                public F? Opt;

                public _InOptMut_F() {}
                public _InOptMut_F(F value) {Opt = value;}
                public static implicit operator _InOptMut_F(F value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `F` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_F`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `F`/`Const_F` to pass it to the function.
            /// </summary>
            public class _InOptConst_F
            {
                public Const_F? Opt;

                public _InOptConst_F() {}
                public _InOptConst_F(Const_F value) {Opt = value;}
                public static implicit operator _InOptConst_F(Const_F value) {return new(value);}
            }

            // Even if the secondary bases are virtual, this doesn't affect anything.
            /// <summary>
            /// Generated from class `MR::CSharp::G`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::E`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            /// This is the const half of the class.
            /// </summary>
            public class Const_G : MR.CS.Misc.Object<Const_G>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_G_Destroy(_Underlying *_this);
                    __MR_CSharp_G_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_G() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_A(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.Const_A ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_D(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_D._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.Const_D ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_E(Const_G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_E._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.Const_E ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_G?(MR.CS.CSharp.Const_A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(MR.CS.CSharp.Const_A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_G ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe Const_G(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_G() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_G_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public unsafe Const_G(MR.CS.CSharp._ByValue_G _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_G_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public Const_G(Const_G _other) : this(new _ByValue_G(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public Const_G(G _other) : this((Const_G)_other) {}
            }

            // Even if the secondary bases are virtual, this doesn't affect anything.
            /// <summary>
            /// Generated from class `MR::CSharp::G`.
            /// Base classes:
            ///   Virtual:
            ///     `MR::CSharp::E`
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::A`
            ///     `MR::CSharp::D`
            /// This is the non-const half of the class.
            /// </summary>
            public class G : Const_G
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.A(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_A", ExactSpelling = true)]
                    extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_A(_Underlying *_this);
                    MR.CS.CSharp.A ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_A(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.D(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_D", ExactSpelling = true)]
                    extern static MR.CS.CSharp.D._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_D(_Underlying *_this);
                    MR.CS.CSharp.D ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_D(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.E(G self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_UpcastTo_MR_CSharp_E", ExactSpelling = true)]
                    extern static MR.CS.CSharp.E._Underlying *__MR_CSharp_G_UpcastTo_MR_CSharp_E(_Underlying *_this);
                    MR.CS.CSharp.E ret = new(__MR_CSharp_G_UpcastTo_MR_CSharp_E(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator G?(MR.CS.CSharp.A parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(MR.CS.CSharp.A._Underlying *_this);
                    var ptr = __MR_CSharp_A_DynamicDowncastTo_MR_CSharp_G(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    G ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe G(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe G() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_G_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public unsafe G(MR.CS.CSharp._ByValue_G _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_G_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public G(Const_G _other) : this(new _ByValue_G(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::G::G`.
                /// </summary>
                public G(G _other) : this((Const_G)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::G::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.G assign(MR.CS.CSharp._ByValue_G _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_G_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.G._Underlying *__MR_CSharp_G_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.G._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_G_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `G` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `G`/`Const_G` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_G
            {
                internal readonly Const_G? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_G() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_G(Const_G new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_G(Const_G arg) {return new(arg);}
                public _ByValue_G(MR.CS.Misc._Moved<G> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_G(MR.CS.Misc._Moved<G> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `G` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_G`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `G`/`Const_G` directly.
            /// </summary>
            public class _InOptMut_G
            {
                public G? Opt;

                public _InOptMut_G() {}
                public _InOptMut_G(G value) {Opt = value;}
                public static implicit operator _InOptMut_G(G value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `G` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_G`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `G`/`Const_G` to pass it to the function.
            /// </summary>
            public class _InOptConst_G
            {
                public Const_G? Opt;

                public _InOptConst_G() {}
                public _InOptConst_G(Const_G value) {Opt = value;}
                public static implicit operator _InOptConst_G(Const_G value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::Trivial`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_Trivial : MR.CS.Misc.Object<Const_Trivial>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_Trivial_Destroy(_Underlying *_this);
                    __MR_CSharp_Trivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_Trivial() {Dispose(false);}

                internal unsafe Const_Trivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_Trivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Trivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                /// </summary>
                public unsafe Const_Trivial(MR.CS.CSharp.Const_Trivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_ConstructFromAnother(MR.CS.CSharp.Trivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Trivial_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                /// </summary>
                public Const_Trivial(Trivial _other) : this((Const_Trivial)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::Trivial`.
            /// This is the non-const half of the class.
            /// </summary>
            public class Trivial : Const_Trivial
            {
                internal unsafe Trivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Trivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Trivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                /// </summary>
                public unsafe Trivial(MR.CS.CSharp.Const_Trivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_ConstructFromAnother(MR.CS.CSharp.Trivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Trivial_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Trivial::Trivial`.
                /// </summary>
                public Trivial(Trivial _other) : this((Const_Trivial)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::Trivial::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.Trivial assign(MR.CS.CSharp.Const_Trivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Trivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_Trivial_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Trivial._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_Trivial_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Trivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_Trivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Trivial`/`Const_Trivial` directly.
            /// </summary>
            public class _InOptMut_Trivial
            {
                public Trivial? Opt;

                public _InOptMut_Trivial() {}
                public _InOptMut_Trivial(Trivial value) {Opt = value;}
                public static implicit operator _InOptMut_Trivial(Trivial value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Trivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_Trivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Trivial`/`Const_Trivial` to pass it to the function.
            /// </summary>
            public class _InOptConst_Trivial
            {
                public Const_Trivial? Opt;

                public _InOptConst_Trivial() {}
                public _InOptConst_Trivial(Const_Trivial value) {Opt = value;}
                public static implicit operator _InOptConst_Trivial(Const_Trivial value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TrivialDerived`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TrivialDerived : MR.CS.Misc.Object<Const_TrivialDerived>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TrivialDerived_Destroy(_Underlying *_this);
                    __MR_CSharp_TrivialDerived_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TrivialDerived() {Dispose(false);}

                internal unsafe Const_TrivialDerived(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_TrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                /// </summary>
                public unsafe Const_TrivialDerived(MR.CS.CSharp.Const_TrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_ConstructFromAnother(MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                /// </summary>
                public Const_TrivialDerived(TrivialDerived _other) : this((Const_TrivialDerived)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TrivialDerived`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TrivialDerived : Const_TrivialDerived
            {
                internal unsafe TrivialDerived(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe TrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                /// </summary>
                public unsafe TrivialDerived(MR.CS.CSharp.Const_TrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_ConstructFromAnother(MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TrivialDerived_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TrivialDerived::TrivialDerived`.
                /// </summary>
                public TrivialDerived(TrivialDerived _other) : this((Const_TrivialDerived)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TrivialDerived::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.TrivialDerived assign(MR.CS.CSharp.Const_TrivialDerived _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TrivialDerived_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TrivialDerived._Underlying *__MR_CSharp_TrivialDerived_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TrivialDerived._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_TrivialDerived_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `TrivialDerived` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TrivialDerived`/`Const_TrivialDerived` directly.
            /// </summary>
            public class _InOptMut_TrivialDerived
            {
                public TrivialDerived? Opt;

                public _InOptMut_TrivialDerived() {}
                public _InOptMut_TrivialDerived(TrivialDerived value) {Opt = value;}
                public static implicit operator _InOptMut_TrivialDerived(TrivialDerived value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TrivialDerived` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TrivialDerived`/`Const_TrivialDerived` to pass it to the function.
            /// </summary>
            public class _InOptConst_TrivialDerived
            {
                public Const_TrivialDerived? Opt;

                public _InOptConst_TrivialDerived() {}
                public _InOptConst_TrivialDerived(Const_TrivialDerived value) {Opt = value;}
                public static implicit operator _InOptConst_TrivialDerived(Const_TrivialDerived value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivial`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_NonTrivial : MR.CS.Misc.Object<Const_NonTrivial>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivial() {Dispose(false);}

                internal unsafe Const_NonTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_NonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public unsafe Const_NonTrivial(MR.CS.CSharp._ByValue_NonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public Const_NonTrivial(Const_NonTrivial _other) : this(new _ByValue_NonTrivial(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public Const_NonTrivial(NonTrivial _other) : this((Const_NonTrivial)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivial`.
            /// This is the non-const half of the class.
            /// </summary>
            public class NonTrivial : Const_NonTrivial
            {
                internal unsafe NonTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe NonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public unsafe NonTrivial(MR.CS.CSharp._ByValue_NonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public NonTrivial(Const_NonTrivial _other) : this(new _ByValue_NonTrivial(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivial::NonTrivial`.
                /// </summary>
                public NonTrivial(NonTrivial _other) : this((Const_NonTrivial)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::NonTrivial::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.NonTrivial assign(MR.CS.CSharp._ByValue_NonTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_NonTrivial_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivial._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_NonTrivial_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `NonTrivial` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_NonTrivial
            {
                internal readonly Const_NonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivial(Const_NonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivial(Const_NonTrivial arg) {return new(arg);}
                public _ByValue_NonTrivial(MR.CS.Misc._Moved<NonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivial(MR.CS.Misc._Moved<NonTrivial> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives an optional `NonTrivial` by value,
            ///   and also has a default argument, meaning it has two different null states.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument.
            /// * Pass `MR.CS.Misc.NullOptType` to pass no object.
            /// </summary>
            public class _ByValueOptOpt_NonTrivial
            {
                internal readonly Const_NonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueOptOpt_NonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueOptOpt_NonTrivial(Const_NonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueOptOpt_NonTrivial(Const_NonTrivial arg) {return new(arg);}
                public _ByValueOptOpt_NonTrivial(MR.CS.Misc._Moved<NonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueOptOpt_NonTrivial(MR.CS.Misc._Moved<NonTrivial> arg) {return new(arg);}
                public _ByValueOptOpt_NonTrivial(MR.CS.Misc.NullOptType nullopt) {PassByMode = MR.CS.Misc._PassBy.no_object;}
                public static implicit operator _ByValueOptOpt_NonTrivial(MR.CS.Misc.NullOptType nullopt) {return new(nullopt);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` directly.
            /// </summary>
            public class _InOptMut_NonTrivial
            {
                public NonTrivial? Opt;

                public _InOptMut_NonTrivial() {}
                public _InOptMut_NonTrivial(NonTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivial(NonTrivial value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivial`/`Const_NonTrivial` to pass it to the function.
            /// </summary>
            public class _InOptConst_NonTrivial
            {
                public Const_NonTrivial? Opt;

                public _InOptConst_NonTrivial() {}
                public _InOptConst_NonTrivial(Const_NonTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivial(Const_NonTrivial value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivialDerived`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_NonTrivialDerived : MR.CS.Misc.Object<Const_NonTrivialDerived>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivialDerived_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivialDerived_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivialDerived() {Dispose(false);}

                internal unsafe Const_NonTrivialDerived(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_NonTrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public unsafe Const_NonTrivialDerived(MR.CS.CSharp._ByValue_NonTrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public Const_NonTrivialDerived(Const_NonTrivialDerived _other) : this(new _ByValue_NonTrivialDerived(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public Const_NonTrivialDerived(NonTrivialDerived _other) : this((Const_NonTrivialDerived)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivialDerived`.
            /// This is the non-const half of the class.
            /// </summary>
            public class NonTrivialDerived : Const_NonTrivialDerived
            {
                internal unsafe NonTrivialDerived(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe NonTrivialDerived() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public unsafe NonTrivialDerived(MR.CS.CSharp._ByValue_NonTrivialDerived _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialDerived_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public NonTrivialDerived(Const_NonTrivialDerived _other) : this(new _ByValue_NonTrivialDerived(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialDerived::NonTrivialDerived`.
                /// </summary>
                public NonTrivialDerived(NonTrivialDerived _other) : this((Const_NonTrivialDerived)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::NonTrivialDerived::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.NonTrivialDerived assign(MR.CS.CSharp._ByValue_NonTrivialDerived _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialDerived_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialDerived._Underlying *__MR_CSharp_NonTrivialDerived_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialDerived._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_NonTrivialDerived_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `NonTrivialDerived` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_NonTrivialDerived
            {
                internal readonly Const_NonTrivialDerived? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivialDerived() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivialDerived(Const_NonTrivialDerived new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivialDerived(Const_NonTrivialDerived arg) {return new(arg);}
                public _ByValue_NonTrivialDerived(MR.CS.Misc._Moved<NonTrivialDerived> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivialDerived(MR.CS.Misc._Moved<NonTrivialDerived> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivialDerived` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` directly.
            /// </summary>
            public class _InOptMut_NonTrivialDerived
            {
                public NonTrivialDerived? Opt;

                public _InOptMut_NonTrivialDerived() {}
                public _InOptMut_NonTrivialDerived(NonTrivialDerived value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivialDerived(NonTrivialDerived value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivialDerived` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivialDerived`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialDerived`/`Const_NonTrivialDerived` to pass it to the function.
            /// </summary>
            public class _InOptConst_NonTrivialDerived
            {
                public Const_NonTrivialDerived? Opt;

                public _InOptConst_NonTrivialDerived() {}
                public _InOptConst_NonTrivialDerived(Const_NonTrivialDerived value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivialDerived(Const_NonTrivialDerived value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SA`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SA : MR.CS.Misc.SharedObject<Const_SA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SA_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_get(_UnderlyingSharedPtr);
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is owning or not.
                /// </summary>
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_use_count", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SA_use_count(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_use_count(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                /// </summary>
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SA_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SA_get(_UnderlyingSharedPtr) is not null;
                    }
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SA_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SA_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SA() {Dispose(false);}

                internal unsafe Const_SA(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_ConstructNonOwning(ptr);
                }

                internal unsafe Const_SA(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe SA _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SA_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SA_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SA_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SA_Construct(ptr);
                }

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SA() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SA_DefaultConstruct());
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SA::SA`.
                /// </summary>
                public unsafe Const_SA(MR.CS.CSharp.Const_SA _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_ConstructFromAnother(MR.CS.CSharp.SA._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SA_ConstructFromAnother(_other._UnderlyingPtr));
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SA::SA`.
                /// </summary>
                public Const_SA(SA _other) : this((Const_SA)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SA`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the non-const half of the class.
            /// </summary>
            public class SA : Const_SA
            {
                internal unsafe SA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe SA(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SA() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SA_DefaultConstruct());
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SA::SA`.
                /// </summary>
                public unsafe SA(MR.CS.CSharp.Const_SA _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_ConstructFromAnother(MR.CS.CSharp.SA._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SA_ConstructFromAnother(_other._UnderlyingPtr));
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SA::SA`.
                /// </summary>
                public SA(SA _other) : this((Const_SA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SA assign(MR.CS.CSharp.Const_SA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.SA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_SA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SA` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SA`/`Const_SA` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValueShared_SA
            {
                internal readonly Const_SA? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SA() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SA(Const_SA new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SA(Const_SA arg) {return new(arg);}
                public _ByValueShared_SA(MR.CS.Misc._Moved<SA> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SA(MR.CS.Misc._Moved<SA> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SA`/`Const_SA` directly.
            /// </summary>
            public class _InOptMut_SA
            {
                public SA? Opt;

                public _InOptMut_SA() {}
                public _InOptMut_SA(SA value) {Opt = value;}
                public static implicit operator _InOptMut_SA(SA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SA`/`Const_SA` to pass it to the function.
            /// </summary>
            public class _InOptConst_SA
            {
                public Const_SA? Opt;

                public _InOptConst_SA() {}
                public _InOptConst_SA(Const_SA value) {Opt = value;}
                public static implicit operator _InOptConst_SA(Const_SA value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SB`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SB : MR.CS.Misc.Object<Const_SB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_SB_Destroy(_Underlying *_this);
                    __MR_CSharp_SB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SB() {Dispose(false);}

                // Make this non-trivial for a change.
                public unsafe MR.CS.Std.Const_String s {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_SB_Get_s(MR.CS.CSharp.Const_SB._Underlying *_this);
                        this.s = new(__MR_CSharp_SB_Get_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_SB(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::SB` elementwise.
                /// </summary>
                public unsafe Const_SB(ReadOnlySpan<char> s) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFrom(byte *s, byte *s_end);
                    byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                    int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                    fixed (byte *__ptr_s = __bytes_s)
                    {
                        _UnderlyingPtr = __MR_CSharp_SB_ConstructFrom(__ptr_s, __ptr_s + __len_s);
                        _FinalizeFields();
                    }
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public unsafe Const_SB(MR.CS.CSharp._ByValue_SB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public Const_SB(Const_SB _other) : this(new _ByValue_SB(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public Const_SB(SB _other) : this((Const_SB)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SB`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SC`
            /// This is the non-const half of the class.
            /// </summary>
            public class SB : Const_SB
            {
                // Make this non-trivial for a change.
                public new unsafe MR.CS.Std.String s {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_SB_GetMutable_s(MR.CS.CSharp.SB._Underlying *_this);
                        this.s = new(__MR_CSharp_SB_GetMutable_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe SB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::SB` elementwise.
                /// </summary>
                public unsafe SB(ReadOnlySpan<char> s) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFrom(byte *s, byte *s_end);
                    byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                    int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                    fixed (byte *__ptr_s = __bytes_s)
                    {
                        _UnderlyingPtr = __MR_CSharp_SB_ConstructFrom(__ptr_s, __ptr_s + __len_s);
                        _FinalizeFields();
                    }
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public unsafe SB(MR.CS.CSharp._ByValue_SB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public SB(Const_SB _other) : this(new _ByValue_SB(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SB::SB`.
                /// </summary>
                public SB(SB _other) : this((Const_SB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SB assign(MR.CS.CSharp._ByValue_SB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SB_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SB._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_SB_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SB` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SB`/`Const_SB` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_SB
            {
                internal readonly Const_SB? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SB() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SB(Const_SB new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SB(Const_SB arg) {return new(arg);}
                public _ByValue_SB(MR.CS.Misc._Moved<SB> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SB(MR.CS.Misc._Moved<SB> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SB`/`Const_SB` directly.
            /// </summary>
            public class _InOptMut_SB
            {
                public SB? Opt;

                public _InOptMut_SB() {}
                public _InOptMut_SB(SB value) {Opt = value;}
                public static implicit operator _InOptMut_SB(SB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SB`/`Const_SB` to pass it to the function.
            /// </summary>
            public class _InOptConst_SB
            {
                public Const_SB? Opt;

                public _InOptConst_SB() {}
                public _InOptConst_SB(Const_SB value) {Opt = value;}
                public static implicit operator _InOptConst_SB(Const_SB value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SC`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SA`
            ///     `MR::CSharp::SB`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SC : MR.CS.Misc.Object<Const_SC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_SC_Destroy(_Underlying *_this);
                    __MR_CSharp_SC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SC() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_SA(Const_SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SA._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(_Underlying *_this);
                    MR.CS.CSharp.Const_SA ret = new(__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_SB(Const_SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SB._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(_Underlying *_this);
                    MR.CS.CSharp.Const_SB ret = new(__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                internal unsafe Const_SC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public unsafe Const_SC(MR.CS.CSharp._ByValue_SC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public Const_SC(Const_SC _other) : this(new _ByValue_SC(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public Const_SC(SC _other) : this((Const_SC)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SC`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SA`
            ///     `MR::CSharp::SB`
            /// This is the non-const half of the class.
            /// </summary>
            public class SC : Const_SC
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.SA(SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SA._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(_Underlying *_this);
                    MR.CS.CSharp.SA ret = new(__MR_CSharp_SC_UpcastTo_MR_CSharp_SA(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.SB(SC self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_UpcastTo_MR_CSharp_SB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SB._Underlying *__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(_Underlying *_this);
                    MR.CS.CSharp.SB ret = new(__MR_CSharp_SC_UpcastTo_MR_CSharp_SB(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                internal unsafe SC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public unsafe SC(MR.CS.CSharp._ByValue_SC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public SC(Const_SC _other) : this(new _ByValue_SC(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SC::SC`.
                /// </summary>
                public SC(SC _other) : this((Const_SC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SC assign(MR.CS.CSharp._ByValue_SC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SC._Underlying *__MR_CSharp_SC_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SC._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_SC_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SC`/`Const_SC` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_SC
            {
                internal readonly Const_SC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SC(Const_SC new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SC(Const_SC arg) {return new(arg);}
                public _ByValue_SC(MR.CS.Misc._Moved<SC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SC(MR.CS.Misc._Moved<SC> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SC`/`Const_SC` directly.
            /// </summary>
            public class _InOptMut_SC
            {
                public SC? Opt;

                public _InOptMut_SC() {}
                public _InOptMut_SC(SC value) {Opt = value;}
                public static implicit operator _InOptMut_SC(SC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SC`/`Const_SC` to pass it to the function.
            /// </summary>
            public class _InOptConst_SC
            {
                public Const_SC? Opt;

                public _InOptConst_SC() {}
                public _InOptConst_SC(Const_SC value) {Opt = value;}
                public static implicit operator _InOptConst_SC(Const_SC value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SD`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SD : MR.CS.Misc.Object<Const_SD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_SD_Destroy(_Underlying *_this);
                    __MR_CSharp_SD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SD() {Dispose(false);}

                internal unsafe Const_SD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public unsafe Const_SD(MR.CS.CSharp._ByValue_SD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SD_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public Const_SD(Const_SD _other) : this(new _ByValue_SD(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public Const_SD(SD _other) : this((Const_SD)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SD`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the non-const half of the class.
            /// </summary>
            public class SD : Const_SD
            {
                internal unsafe SD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public unsafe SD(MR.CS.CSharp._ByValue_SD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SD_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public SD(Const_SD _other) : this(new _ByValue_SD(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SD::SD`.
                /// </summary>
                public SD(SD _other) : this((Const_SD)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SD assign(MR.CS.CSharp._ByValue_SD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SD_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SD._Underlying *_other);
                    MR.CS.CSharp.SD __ret;
                    __ret = new(__MR_CSharp_SD_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SD` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SD`/`Const_SD` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_SD
            {
                internal readonly Const_SD? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SD() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SD(Const_SD new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SD(Const_SD arg) {return new(arg);}
                public _ByValue_SD(MR.CS.Misc._Moved<SD> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SD(MR.CS.Misc._Moved<SD> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SD`/`Const_SD` directly.
            /// </summary>
            public class _InOptMut_SD
            {
                public SD? Opt;

                public _InOptMut_SD() {}
                public _InOptMut_SD(SD value) {Opt = value;}
                public static implicit operator _InOptMut_SD(SD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SD`/`Const_SD` to pass it to the function.
            /// </summary>
            public class _InOptConst_SD
            {
                public Const_SD? Opt;

                public _InOptConst_SD() {}
                public _InOptConst_SD(Const_SD value) {Opt = value;}
                public static implicit operator _InOptConst_SD(Const_SD value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SE`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SE : MR.CS.Misc.SharedObject<Const_SE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_SE_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_get(_UnderlyingSharedPtr);
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is owning or not.
                /// </summary>
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_use_count", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_SE_use_count(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_use_count(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                /// </summary>
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_SE_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_SE_get(_UnderlyingSharedPtr) is not null;
                    }
                }

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_SE_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_SE_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SE() {Dispose(false);}

                // Make this non-trivial for a change.
                public unsafe MR.CS.Std.Const_String s {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_SE_Get_s(MR.CS.CSharp.Const_SE._Underlying *_this);
                        this.s = new(__MR_CSharp_SE_Get_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_SE(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_ConstructNonOwning(ptr);
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_SE(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingSharedPtr = shared_ptr;
                    if (shared_ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                internal static unsafe SE _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_SE_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_SE_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_SE_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_SE_Construct(ptr);
                }

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SE() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SE_DefaultConstruct());
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::SE` elementwise.
                /// </summary>
                public unsafe Const_SE(ReadOnlySpan<char> s) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFrom(byte *s, byte *s_end);
                    byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                    int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                    fixed (byte *__ptr_s = __bytes_s)
                    {
                        _LateMakeShared(__MR_CSharp_SE_ConstructFrom(__ptr_s, __ptr_s + __len_s));
                        _FinalizeFields();
                    }
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public unsafe Const_SE(MR.CS.CSharp._ByValue_SE _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public Const_SE(Const_SE _other) : this(new _ByValue_SE(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public Const_SE(SE _other) : this((Const_SE)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SE`.
            /// Derived classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SF`
            /// This is the non-const half of the class.
            /// </summary>
            public class SE : Const_SE
            {
                // Make this non-trivial for a change.
                public new unsafe MR.CS.Std.String s {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_SE_GetMutable_s(MR.CS.CSharp.SE._Underlying *_this);
                        this.s = new(__MR_CSharp_SE_GetMutable_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe SE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe SE(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning)
                {
                    if (shared_ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SE() : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_DefaultConstruct();
                    _LateMakeShared(__MR_CSharp_SE_DefaultConstruct());
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::SE` elementwise.
                /// </summary>
                public unsafe SE(ReadOnlySpan<char> s) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFrom(byte *s, byte *s_end);
                    byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                    int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                    fixed (byte *__ptr_s = __bytes_s)
                    {
                        _LateMakeShared(__MR_CSharp_SE_ConstructFrom(__ptr_s, __ptr_s + __len_s));
                        _FinalizeFields();
                    }
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public unsafe SE(MR.CS.CSharp._ByValue_SE _other) : this(shared_ptr: null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    _LateMakeShared(__MR_CSharp_SE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null));
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public SE(Const_SE _other) : this(new _ByValue_SE(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SE::SE`.
                /// </summary>
                public SE(SE _other) : this((Const_SE)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SE assign(MR.CS.CSharp._ByValue_SE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SE_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SE._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_SE_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SE`/`Const_SE` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_SE
            {
                internal readonly Const_SE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SE(Const_SE new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SE(Const_SE arg) {return new(arg);}
                public _ByValue_SE(MR.CS.Misc._Moved<SE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SE(MR.CS.Misc._Moved<SE> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SE`/`Const_SE` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValueShared_SE
            {
                internal readonly Const_SE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_SE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_SE(Const_SE new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_SE(Const_SE arg) {return new(arg);}
                public _ByValueShared_SE(MR.CS.Misc._Moved<SE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_SE(MR.CS.Misc._Moved<SE> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SE`/`Const_SE` directly.
            /// </summary>
            public class _InOptMut_SE
            {
                public SE? Opt;

                public _InOptMut_SE() {}
                public _InOptMut_SE(SE value) {Opt = value;}
                public static implicit operator _InOptMut_SE(SE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SE`/`Const_SE` to pass it to the function.
            /// </summary>
            public class _InOptConst_SE
            {
                public Const_SE? Opt;

                public _InOptConst_SE() {}
                public _InOptConst_SE(Const_SE value) {Opt = value;}
                public static implicit operator _InOptConst_SE(Const_SE value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SF`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SD`
            ///     `MR::CSharp::SE`
            /// This is the const half of the class.
            /// </summary>
            public class Const_SF : MR.CS.Misc.Object<Const_SF>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_SF_Destroy(_Underlying *_this);
                    __MR_CSharp_SF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_SF() {Dispose(false);}

                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.Const_SD(Const_SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SD._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(_Underlying *_this);
                    MR.CS.CSharp.Const_SD ret = new(__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.Const_SE(Const_SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_SE._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(_Underlying *_this);
                    MR.CS.CSharp.Const_SE ret = new(__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator Const_SF?(MR.CS.CSharp.Const_SD parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(MR.CS.CSharp.Const_SD._Underlying *_this);
                    var ptr = __MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    Const_SF ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe Const_SF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_SF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public unsafe Const_SF(MR.CS.CSharp._ByValue_SF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public Const_SF(Const_SF _other) : this(new _ByValue_SF(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public Const_SF(SF _other) : this((Const_SF)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::SF`.
            /// Base classes:
            ///   Direct: (non-virtual)
            ///     `MR::CSharp::SD`
            ///     `MR::CSharp::SE`
            /// This is the non-const half of the class.
            /// </summary>
            public class SF : Const_SF
            {
                // Upcasts:
                public static unsafe implicit operator MR.CS.CSharp.SD(SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SD._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(_Underlying *_this);
                    MR.CS.CSharp.SD ret = new(__MR_CSharp_SF_UpcastTo_MR_CSharp_SD(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }
                public static unsafe implicit operator MR.CS.CSharp.SE(SF self)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_UpcastTo_MR_CSharp_SE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SE._Underlying *__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(_Underlying *_this);
                    MR.CS.CSharp.SE ret = new(__MR_CSharp_SF_UpcastTo_MR_CSharp_SE(self._UnderlyingPtr), is_owning: false);
                    ret._KeepAliveEnclosingObject = self;
                    return ret;
                }

                // Downcasts:
                public static unsafe explicit operator SF?(MR.CS.CSharp.SD parent)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF", ExactSpelling = true)]
                    extern static _Underlying *__MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(MR.CS.CSharp.SD._Underlying *_this);
                    var ptr = __MR_CSharp_SD_DynamicDowncastTo_MR_CSharp_SF(parent._UnderlyingPtr);
                    if (ptr is null) return null;
                    SF ret = new(ptr, is_owning: false);
                    ret._KeepAliveEnclosingObject = parent;
                    return ret;
                }

                internal unsafe SF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe SF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_SF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public unsafe SF(MR.CS.CSharp._ByValue_SF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_SF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public SF(Const_SF _other) : this(new _ByValue_SF(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::SF::SF`.
                /// </summary>
                public SF(SF _other) : this((Const_SF)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::SF::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.SF assign(MR.CS.CSharp._ByValue_SF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_SF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.SF._Underlying *__MR_CSharp_SF_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.SF._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_SF_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `SF` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `SF`/`Const_SF` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_SF
            {
                internal readonly Const_SF? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_SF() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_SF(Const_SF new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_SF(Const_SF arg) {return new(arg);}
                public _ByValue_SF(MR.CS.Misc._Moved<SF> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_SF(MR.CS.Misc._Moved<SF> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_SF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SF`/`Const_SF` directly.
            /// </summary>
            public class _InOptMut_SF
            {
                public SF? Opt;

                public _InOptMut_SF() {}
                public _InOptMut_SF(SF value) {Opt = value;}
                public static implicit operator _InOptMut_SF(SF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `SF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_SF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `SF`/`Const_SF` to pass it to the function.
            /// </summary>
            public class _InOptConst_SF
            {
                public Const_SF? Opt;

                public _InOptConst_SF() {}
                public _InOptConst_SF(Const_SF value) {Opt = value;}
                public static implicit operator _InOptConst_SF(Const_SF value) {return new(value);}
            }

            // Nested classes.
            /// <summary>
            /// Generated from class `MR::CSharp::Outer`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_Outer : MR.CS.Misc.Object<Const_Outer>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_Outer_Destroy(_Underlying *_this);
                    __MR_CSharp_Outer_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_Outer() {Dispose(false);}

                internal unsafe Const_Outer(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_Outer() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Outer_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                /// </summary>
                public unsafe Const_Outer(MR.CS.CSharp.Const_Outer _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_ConstructFromAnother(MR.CS.CSharp.Outer._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Outer_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                /// </summary>
                public Const_Outer(Outer _other) : this((Const_Outer)_other) {}

                /// <summary>
                /// Generated from class `MR::CSharp::Outer::Inner`.
                /// This is the const half of the class.
                /// </summary>
                public class Const_Inner : MR.CS.Misc.Object<Const_Inner>, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_Outer_Inner_Destroy(_Underlying *_this);
                        __MR_CSharp_Outer_Inner_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_Inner() {Dispose(false);}

                    internal unsafe Const_Inner(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Const_Inner() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_DefaultConstruct();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    /// </summary>
                    public unsafe Const_Inner(MR.CS.CSharp.Outer.Const_Inner _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_ConstructFromAnother(MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    /// </summary>
                    public Const_Inner(Inner _other) : this((Const_Inner)_other) {}
                }

                /// <summary>
                /// Generated from class `MR::CSharp::Outer::Inner`.
                /// This is the non-const half of the class.
                /// </summary>
                public class Inner : Const_Inner
                {
                    internal unsafe Inner(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Inner() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_DefaultConstruct();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    /// </summary>
                    public unsafe Inner(MR.CS.CSharp.Outer.Const_Inner _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_ConstructFromAnother(MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_Outer_Inner_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::Outer::Inner::Inner`.
                    /// </summary>
                    public Inner(Inner _other) : this((Const_Inner)_other) {}

                    /// <summary>
                    /// Generated from method `MR::CSharp::Outer::Inner::operator=`.
                    /// </summary>
                    public unsafe MR.CS.CSharp.Outer.Inner assign(MR.CS.CSharp.Outer.Const_Inner _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Outer.Inner._Underlying *__MR_CSharp_Outer_Inner_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Outer.Inner._Underlying *_other);
                        _DiscardKeepAlive();
                        _KeepAlive(_other);
                        return new(__MR_CSharp_Outer_Inner_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }

                    /// <summary>
                    /// Generated from method `MR::CSharp::Outer::Inner::bar`.
                    /// </summary>
                    public unsafe void bar()
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_Inner_bar", ExactSpelling = true)]
                        extern static void __MR_CSharp_Outer_Inner_bar(_Underlying *_this);
                        __MR_CSharp_Outer_Inner_bar(_UnderlyingPtr);
                    }
                }

                /// <summary>
                /// This is used for optional parameters of class `Inner` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_Inner`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Inner`/`Const_Inner` directly.
                /// </summary>
                public class _InOptMut_Inner
                {
                    public Inner? Opt;

                    public _InOptMut_Inner() {}
                    public _InOptMut_Inner(Inner value) {Opt = value;}
                    public static implicit operator _InOptMut_Inner(Inner value) {return new(value);}
                }

                /// <summary>
                /// This is used for optional parameters of class `Inner` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_Inner`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Inner`/`Const_Inner` to pass it to the function.
                /// </summary>
                public class _InOptConst_Inner
                {
                    public Const_Inner? Opt;

                    public _InOptConst_Inner() {}
                    public _InOptConst_Inner(Const_Inner value) {Opt = value;}
                    public static implicit operator _InOptConst_Inner(Const_Inner value) {return new(value);}
                }
            }

            // Nested classes.
            /// <summary>
            /// Generated from class `MR::CSharp::Outer`.
            /// This is the non-const half of the class.
            /// </summary>
            public class Outer : Const_Outer
            {
                internal unsafe Outer(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Outer() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_Outer_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                /// </summary>
                public unsafe Outer(MR.CS.CSharp.Const_Outer _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_ConstructFromAnother(MR.CS.CSharp.Outer._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_Outer_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::Outer::Outer`.
                /// </summary>
                public Outer(Outer _other) : this((Const_Outer)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::Outer::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.Outer assign(MR.CS.CSharp.Const_Outer _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Outer._Underlying *__MR_CSharp_Outer_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.Outer._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_Outer_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::Outer::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_Outer_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_Outer_foo(_Underlying *_this);
                    __MR_CSharp_Outer_foo(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Outer` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_Outer`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Outer`/`Const_Outer` directly.
            /// </summary>
            public class _InOptMut_Outer
            {
                public Outer? Opt;

                public _InOptMut_Outer() {}
                public _InOptMut_Outer(Outer value) {Opt = value;}
                public static implicit operator _InOptMut_Outer(Outer value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Outer` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_Outer`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Outer`/`Const_Outer` to pass it to the function.
            /// </summary>
            public class _InOptConst_Outer
            {
                public Const_Outer? Opt;

                public _InOptConst_Outer() {}
                public _InOptConst_Outer(Const_Outer value) {Opt = value;}
                public static implicit operator _InOptConst_Outer(Const_Outer value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestFields`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TestFields : MR.CS.Misc.Object<Const_TestFields>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestFields_Destroy(_Underlying *_this);
                    __MR_CSharp_TestFields_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestFields() {Dispose(false);}

                public static unsafe ref int StaticI => ref *__ref_storage_StaticI;
                private protected static unsafe int *__ref_storage_StaticI;

                public static unsafe int StaticConstI => *__ref_storage_StaticConstI;
                private protected static unsafe int *__ref_storage_StaticConstI;

                public static unsafe ref int StaticIRef => ref *__ref_storage_StaticIRef;
                private protected static unsafe int *__ref_storage_StaticIRef;

                public static unsafe int StaticConstIRef => *__ref_storage_StaticConstIRef;
                private protected static unsafe int *__ref_storage_StaticConstIRef;

                public static unsafe MR.CS.Std.String StaticS {get; private protected set;}

                public static unsafe MR.CS.Std.Const_String StaticConstS {get; private protected set;}

                public static unsafe MR.CS.Std.String StaticSRef {get; private protected set;}

                public static unsafe MR.CS.Std.Const_String StaticConstSRef {get; private protected set;}

                public unsafe int i => *__ref_storage_i;
                private protected unsafe int *__ref_storage_i;

                public unsafe int constI => *__ref_storage_constI;
                private protected unsafe int *__ref_storage_constI;

                public unsafe ref int iRef => ref *__ref_storage_iRef;
                private protected unsafe int *__ref_storage_iRef;

                public unsafe int constIRef => *__ref_storage_constIRef;
                private protected unsafe int *__ref_storage_constIRef;

                public unsafe MR.CS.Std.Const_String s {get; private protected set;}

                public unsafe MR.CS.Std.Const_String constS {get; private protected set;}

                public unsafe MR.CS.Std.String sRef {get; private protected set;}

                public unsafe MR.CS.Std.Const_String constSRef {get; private protected set;}

                unsafe static Const_TestFields()
                {
                    { // StaticI (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_static_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_GetMutable_static_i();
                        Const_TestFields.__ref_storage_StaticI = __MR_CSharp_TestFields_GetMutable_static_i();
                    }

                    { // StaticConstI (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_const_i();
                        Const_TestFields.__ref_storage_StaticConstI = __MR_CSharp_TestFields_Get_static_const_i();
                    }

                    { // StaticIRef (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_i_ref();
                        Const_TestFields.__ref_storage_StaticIRef = __MR_CSharp_TestFields_Get_static_i_ref();
                    }

                    { // StaticConstIRef (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_static_const_i_ref();
                        Const_TestFields.__ref_storage_StaticConstIRef = __MR_CSharp_TestFields_Get_static_const_i_ref();
                    }

                    { // StaticS
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_static_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_GetMutable_static_s();
                        Const_TestFields.StaticS = new(__MR_CSharp_TestFields_GetMutable_static_s(), is_owning: false);
                    }

                    { // StaticConstS
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_static_const_s();
                        Const_TestFields.StaticConstS = new(__MR_CSharp_TestFields_Get_static_const_s(), is_owning: false);
                    }

                    { // StaticSRef
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_Get_static_s_ref();
                        Const_TestFields.StaticSRef = new(__MR_CSharp_TestFields_Get_static_s_ref(), is_owning: false);
                    }

                    { // StaticConstSRef
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_static_const_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_static_const_s_ref();
                        Const_TestFields.StaticConstSRef = new(__MR_CSharp_TestFields_Get_static_const_s_ref(), is_owning: false);
                    }
                }

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // i (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_i(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.__ref_storage_i = __MR_CSharp_TestFields_Get_i(_UnderlyingPtr);
                    }

                    { // constI (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_const_i(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.__ref_storage_constI = __MR_CSharp_TestFields_Get_const_i(_UnderlyingPtr);
                    }

                    { // iRef (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_i_ref(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.__ref_storage_iRef = __MR_CSharp_TestFields_Get_i_ref(_UnderlyingPtr);
                    }

                    { // constIRef (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_i_ref", ExactSpelling = true)]
                        extern static int *__MR_CSharp_TestFields_Get_const_i_ref(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.__ref_storage_constIRef = __MR_CSharp_TestFields_Get_const_i_ref(_UnderlyingPtr);
                    }

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_s(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.s = new(__MR_CSharp_TestFields_Get_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }

                    { // constS
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_const_s(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.constS = new(__MR_CSharp_TestFields_Get_const_s(_UnderlyingPtr), is_owning: false);
                        this.constS._KeepAliveEnclosingObject = this;
                    }

                    { // sRef
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_Get_s_ref(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.sRef = new(__MR_CSharp_TestFields_Get_s_ref(_UnderlyingPtr), is_owning: false);
                        this.sRef._KeepAliveEnclosingObject = this;
                    }

                    { // constSRef
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_Get_const_s_ref", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_TestFields_Get_const_s_ref(MR.CS.CSharp.Const_TestFields._Underlying *_this);
                        this.constSRef = new(__MR_CSharp_TestFields_Get_const_s_ref(_UnderlyingPtr), is_owning: false);
                        this.constSRef._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_TestFields(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public unsafe Const_TestFields(MR.CS.CSharp._ByValue_TestFields _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestFields._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public Const_TestFields(Const_TestFields _other) : this(new _ByValue_TestFields(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public Const_TestFields(TestFields _other) : this((Const_TestFields)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::TestFields` elementwise.
                /// </summary>
                public unsafe Const_TestFields(int i, int const_i, ref int i_ref, int const_i_ref, ReadOnlySpan<char> s, ReadOnlySpan<char> const_s, MR.CS.Std.String s_ref, ReadOnlySpan<char> const_s_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFrom(int i, int const_i, int *i_ref, int *const_i_ref, byte *s, byte *s_end, byte *const_s, byte *const_s_end, MR.CS.Std.String._Underlying *s_ref, byte *const_s_ref, byte *const_s_ref_end);
                    fixed (int *__ptr_i_ref = &i_ref)
                    {
                        byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                        int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                        fixed (byte *__ptr_s = __bytes_s)
                        {
                            byte[] __bytes_const_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s.Length)];
                            int __len_const_s = System.Text.Encoding.UTF8.GetBytes(const_s, __bytes_const_s);
                            fixed (byte *__ptr_const_s = __bytes_const_s)
                            {
                                byte[] __bytes_const_s_ref = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s_ref.Length)];
                                int __len_const_s_ref = System.Text.Encoding.UTF8.GetBytes(const_s_ref, __bytes_const_s_ref);
                                fixed (byte *__ptr_const_s_ref = __bytes_const_s_ref)
                                {
                                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFrom(i, const_i, __ptr_i_ref, &const_i_ref, __ptr_s, __ptr_s + __len_s, __ptr_const_s, __ptr_const_s + __len_const_s, s_ref._UnderlyingPtr, __ptr_const_s_ref, __ptr_const_s_ref + __len_const_s_ref);
                                    _KeepAlive(s_ref);
                                    _FinalizeFields();
                                }
                            }
                        }
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestFields`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TestFields : Const_TestFields
            {
                public new unsafe ref int i => ref *__ref_storage_i;

                public new unsafe MR.CS.Std.String s {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_TestFields_GetMutable_s(MR.CS.CSharp.TestFields._Underlying *_this);
                        this.s = new(__MR_CSharp_TestFields_GetMutable_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe TestFields(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public unsafe TestFields(MR.CS.CSharp._ByValue_TestFields _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestFields._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public TestFields(Const_TestFields _other) : this(new _ByValue_TestFields(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestFields::TestFields`.
                /// </summary>
                public TestFields(TestFields _other) : this((Const_TestFields)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::TestFields` elementwise.
                /// </summary>
                public unsafe TestFields(int i, int const_i, ref int i_ref, int const_i_ref, ReadOnlySpan<char> s, ReadOnlySpan<char> const_s, MR.CS.Std.String s_ref, ReadOnlySpan<char> const_s_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestFields_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestFields._Underlying *__MR_CSharp_TestFields_ConstructFrom(int i, int const_i, int *i_ref, int *const_i_ref, byte *s, byte *s_end, byte *const_s, byte *const_s_end, MR.CS.Std.String._Underlying *s_ref, byte *const_s_ref, byte *const_s_ref_end);
                    fixed (int *__ptr_i_ref = &i_ref)
                    {
                        byte[] __bytes_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(s.Length)];
                        int __len_s = System.Text.Encoding.UTF8.GetBytes(s, __bytes_s);
                        fixed (byte *__ptr_s = __bytes_s)
                        {
                            byte[] __bytes_const_s = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s.Length)];
                            int __len_const_s = System.Text.Encoding.UTF8.GetBytes(const_s, __bytes_const_s);
                            fixed (byte *__ptr_const_s = __bytes_const_s)
                            {
                                byte[] __bytes_const_s_ref = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(const_s_ref.Length)];
                                int __len_const_s_ref = System.Text.Encoding.UTF8.GetBytes(const_s_ref, __bytes_const_s_ref);
                                fixed (byte *__ptr_const_s_ref = __bytes_const_s_ref)
                                {
                                    _UnderlyingPtr = __MR_CSharp_TestFields_ConstructFrom(i, const_i, __ptr_i_ref, &const_i_ref, __ptr_s, __ptr_s + __len_s, __ptr_const_s, __ptr_const_s + __len_const_s, s_ref._UnderlyingPtr, __ptr_const_s_ref, __ptr_const_s_ref + __len_const_s_ref);
                                    _KeepAlive(s_ref);
                                    _FinalizeFields();
                                }
                            }
                        }
                    }
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `TestFields` by value.
            /// Usage:
            /// * Pass an instance of `TestFields`/`Const_TestFields` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_TestFields
            {
                internal readonly Const_TestFields? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_TestFields(Const_TestFields new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_TestFields(Const_TestFields arg) {return new(arg);}
                public _ByValue_TestFields(MR.CS.Misc._Moved<TestFields> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_TestFields(MR.CS.Misc._Moved<TestFields> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestFields` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestFields`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestFields`/`Const_TestFields` directly.
            /// </summary>
            public class _InOptMut_TestFields
            {
                public TestFields? Opt;

                public _InOptMut_TestFields() {}
                public _InOptMut_TestFields(TestFields value) {Opt = value;}
                public static implicit operator _InOptMut_TestFields(TestFields value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestFields` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestFields`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestFields`/`Const_TestFields` to pass it to the function.
            /// </summary>
            public class _InOptConst_TestFields
            {
                public Const_TestFields? Opt;

                public _InOptConst_TestFields() {}
                public _InOptConst_TestFields(Const_TestFields value) {Opt = value;}
                public static implicit operator _InOptConst_TestFields(Const_TestFields value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestConstness`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TestConstness : MR.CS.Misc.Object<Const_TestConstness>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_Destroy(_Underlying *_this);
                    __MR_CSharp_TestConstness_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestConstness() {Dispose(false);}

                internal unsafe Const_TestConstness(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_TestConstness() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TestConstness_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                /// </summary>
                public unsafe Const_TestConstness(MR.CS.CSharp.Const_TestConstness _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_ConstructFromAnother(MR.CS.CSharp.TestConstness._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestConstness_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                /// </summary>
                public Const_TestConstness(TestConstness _other) : this((Const_TestConstness)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TestConstness::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_foo(_Underlying *_this);
                    __MR_CSharp_TestConstness_foo(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestConstness`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TestConstness : Const_TestConstness
            {
                internal unsafe TestConstness(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe TestConstness() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_TestConstness_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                /// </summary>
                public unsafe TestConstness(MR.CS.CSharp.Const_TestConstness _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_ConstructFromAnother(MR.CS.CSharp.TestConstness._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestConstness_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestConstness::TestConstness`.
                /// </summary>
                public TestConstness(TestConstness _other) : this((Const_TestConstness)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TestConstness::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.TestConstness assign(MR.CS.CSharp.Const_TestConstness _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestConstness._Underlying *__MR_CSharp_TestConstness_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestConstness._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_TestConstness_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestConstness::foo`.
                /// </summary>
                public unsafe new void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestConstness_foo_mut", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestConstness_foo_mut(_Underlying *_this);
                    __MR_CSharp_TestConstness_foo_mut(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `TestConstness` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestConstness`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestConstness`/`Const_TestConstness` directly.
            /// </summary>
            public class _InOptMut_TestConstness
            {
                public TestConstness? Opt;

                public _InOptMut_TestConstness() {}
                public _InOptMut_TestConstness(TestConstness value) {Opt = value;}
                public static implicit operator _InOptMut_TestConstness(TestConstness value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestConstness` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestConstness`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestConstness`/`Const_TestConstness` to pass it to the function.
            /// </summary>
            public class _InOptConst_TestConstness
            {
                public Const_TestConstness? Opt;

                public _InOptConst_TestConstness() {}
                public _InOptConst_TestConstness(Const_TestConstness value) {Opt = value;}
                public static implicit operator _InOptConst_TestConstness(Const_TestConstness value) {return new(value);}
            }

            // This is the happy path.
            // This emits static operators in the const half, and non-static operators (or functions pre C# 14) in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrA : MR.CS.Misc.Object<Const_IncrDecrA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrA_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrA() {Dispose(false);}

                internal unsafe Const_IncrDecrA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                /// </summary>
                public unsafe Const_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_ConstructFromAnother(MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                /// </summary>
                public Const_IncrDecrA(IncrDecrA _other) : this((Const_IncrDecrA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrA::operator++`.
                /// </summary>
                public static unsafe IncrDecrA operator++(MR.CS.CSharp.Const_IncrDecrA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_incr_MR_CSharp_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA._Underlying *_this);
                    IncrDecrA __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrA __ret = new(__MR_C_incr_MR_CSharp_IncrDecrA(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrA::operator--`.
                /// </summary>
                public static unsafe IncrDecrA operator--(MR.CS.CSharp.Const_IncrDecrA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_decr_MR_CSharp_IncrDecrA(MR.CS.CSharp.Const_IncrDecrA._Underlying *_this);
                    IncrDecrA __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrA __ret = new(__MR_C_decr_MR_CSharp_IncrDecrA(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This is the happy path.
            // This emits static operators in the const half, and non-static operators (or functions pre C# 14) in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrA : Const_IncrDecrA
            {
                internal unsafe IncrDecrA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                /// </summary>
                public unsafe IncrDecrA(MR.CS.CSharp.Const_IncrDecrA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_ConstructFromAnother(MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrA::IncrDecrA`.
                /// </summary>
                public IncrDecrA(IncrDecrA _other) : this((Const_IncrDecrA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IncrDecrA assign(MR.CS.CSharp.Const_IncrDecrA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_CSharp_IncrDecrA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IncrDecrA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrA::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_incr_MR_CSharp_IncrDecrA(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrA __ret = new(__MR_C_incr_MR_CSharp_IncrDecrA(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrA::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrA._Underlying *__MR_C_decr_MR_CSharp_IncrDecrA(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrA __ret = new(__MR_C_decr_MR_CSharp_IncrDecrA(_UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrA`/`Const_IncrDecrA` directly.
            /// </summary>
            public class _InOptMut_IncrDecrA
            {
                public IncrDecrA? Opt;

                public _InOptMut_IncrDecrA() {}
                public _InOptMut_IncrDecrA(IncrDecrA value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrA(IncrDecrA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrA`/`Const_IncrDecrA` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrA
            {
                public Const_IncrDecrA? Opt;

                public _InOptConst_IncrDecrA() {}
                public _InOptConst_IncrDecrA(Const_IncrDecrA value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrA(Const_IncrDecrA value) {return new(value);}
            }

            // This is a somewhat happy path. Same as above, but everything gets emitted in the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrB : MR.CS.Misc.Object<Const_IncrDecrB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrB_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrB() {Dispose(false);}

                internal unsafe Const_IncrDecrB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                /// </summary>
                public unsafe Const_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_ConstructFromAnother(MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                /// </summary>
                public Const_IncrDecrB(IncrDecrB _other) : this((Const_IncrDecrB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrB::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_incr_MR_CSharp_IncrDecrB(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrB __ret = new(__MR_C_incr_MR_CSharp_IncrDecrB(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrB::operator++`.
                /// </summary>
                public static unsafe IncrDecrB operator++(MR.CS.CSharp.Const_IncrDecrB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_incr_MR_CSharp_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB._Underlying *_this);
                    IncrDecrB __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrB __ret = new(__MR_C_incr_MR_CSharp_IncrDecrB(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrB::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_decr_MR_CSharp_IncrDecrB(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrB __ret = new(__MR_C_decr_MR_CSharp_IncrDecrB(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrB::operator--`.
                /// </summary>
                public static unsafe IncrDecrB operator--(MR.CS.CSharp.Const_IncrDecrB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrB._Underlying *__MR_C_decr_MR_CSharp_IncrDecrB(MR.CS.CSharp.Const_IncrDecrB._Underlying *_this);
                    IncrDecrB __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrB __ret = new(__MR_C_decr_MR_CSharp_IncrDecrB(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This is a somewhat happy path. Same as above, but everything gets emitted in the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrB : Const_IncrDecrB
            {
                internal unsafe IncrDecrB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                /// </summary>
                public unsafe IncrDecrB(MR.CS.CSharp.Const_IncrDecrB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_ConstructFromAnother(MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrB::IncrDecrB`.
                /// </summary>
                public IncrDecrB(IncrDecrB _other) : this((Const_IncrDecrB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IncrDecrB assign(MR.CS.CSharp.Const_IncrDecrB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrB._Underlying *__MR_CSharp_IncrDecrB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IncrDecrB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrB`/`Const_IncrDecrB` directly.
            /// </summary>
            public class _InOptMut_IncrDecrB
            {
                public IncrDecrB? Opt;

                public _InOptMut_IncrDecrB() {}
                public _InOptMut_IncrDecrB(IncrDecrB value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrB(IncrDecrB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrB`/`Const_IncrDecrB` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrB
            {
                public Const_IncrDecrB? Opt;

                public _InOptConst_IncrDecrB() {}
                public _InOptConst_IncrDecrB(Const_IncrDecrB value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrB(Const_IncrDecrB value) {return new(value);}
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are not marked const, so they're also in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrC : MR.CS.Misc.Object<Const_IncrDecrC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrC_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrC() {Dispose(false);}

                internal unsafe Const_IncrDecrC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrC::IncrDecrC`.
                /// </summary>
                public unsafe Const_IncrDecrC(MR.CS.CSharp.Const_IncrDecrC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_ConstructFromAnother(MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are not marked const, so they're also in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrC : Const_IncrDecrC
            {
                internal unsafe IncrDecrC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrC::IncrDecrC`.
                /// </summary>
                public unsafe IncrDecrC(MR.CS.CSharp.Const_IncrDecrC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_ConstructFromAnother(MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IncrDecrC assign(MR.CS.CSharp.Const_IncrDecrC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_CSharp_IncrDecrC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IncrDecrC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrC::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_incr_MR_CSharp_IncrDecrC(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrC __ret = new(__MR_C_incr_MR_CSharp_IncrDecrC(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrC::operator++`.
                /// </summary>
                public static unsafe IncrDecrC operator++(MR.CS.CSharp.IncrDecrC _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_incr_MR_CSharp_IncrDecrC(MR.CS.CSharp.IncrDecrC._Underlying *_this);
                    IncrDecrC __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrC __ret = new(__MR_C_incr_MR_CSharp_IncrDecrC(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrC::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_decr_MR_CSharp_IncrDecrC(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrC __ret = new(__MR_C_decr_MR_CSharp_IncrDecrC(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrC::operator--`.
                /// </summary>
                public static unsafe IncrDecrC operator--(MR.CS.CSharp.IncrDecrC _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrC._Underlying *__MR_C_decr_MR_CSharp_IncrDecrC(MR.CS.CSharp.IncrDecrC._Underlying *_this);
                    IncrDecrC __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrC __ret = new(__MR_C_decr_MR_CSharp_IncrDecrC(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrC`/`Const_IncrDecrC` directly.
            /// </summary>
            public class _InOptMut_IncrDecrC
            {
                public IncrDecrC? Opt;

                public _InOptMut_IncrDecrC() {}
                public _InOptMut_IncrDecrC(IncrDecrC value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrC(IncrDecrC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrC`/`Const_IncrDecrC` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrC
            {
                public Const_IncrDecrC? Opt;

                public _InOptConst_IncrDecrC() {}
                public _InOptConst_IncrDecrC(Const_IncrDecrC value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrC(Const_IncrDecrC value) {return new(value);}
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are in the const half due to being marked const.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrD : MR.CS.Misc.Object<Const_IncrDecrD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrD_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrD() {Dispose(false);}

                internal unsafe Const_IncrDecrD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrD::IncrDecrD`.
                /// </summary>
                public unsafe Const_IncrDecrD(MR.CS.CSharp.Const_IncrDecrD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_ConstructFromAnother(MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrD::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_incr_MR_CSharp_IncrDecrD(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrD __ret = new(__MR_C_incr_MR_CSharp_IncrDecrD(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrD::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_decr_MR_CSharp_IncrDecrD(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrD __ret = new(__MR_C_decr_MR_CSharp_IncrDecrD(_UnderlyingPtr), is_owning: false);
                }
            }

            // This is a somewhat happy path. Since here the copy ctor takes a non-const reference, the static operators get added to the non-const half.
            // The non-static ones are in the const half due to being marked const.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrD : Const_IncrDecrD
            {
                internal unsafe IncrDecrD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrD::IncrDecrD`.
                /// </summary>
                public unsafe IncrDecrD(MR.CS.CSharp.Const_IncrDecrD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_ConstructFromAnother(MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IncrDecrD assign(MR.CS.CSharp.Const_IncrDecrD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrD._Underlying *__MR_CSharp_IncrDecrD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrD._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IncrDecrD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrD::operator++`.
                /// </summary>
                public static unsafe IncrDecrD operator++(MR.CS.CSharp.IncrDecrD _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_incr_MR_CSharp_IncrDecrD(MR.CS.CSharp.IncrDecrD._Underlying *_this);
                    IncrDecrD __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrD __ret = new(__MR_C_incr_MR_CSharp_IncrDecrD(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrD::operator--`.
                /// </summary>
                public static unsafe IncrDecrD operator--(MR.CS.CSharp.IncrDecrD _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrD", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrD._Underlying *__MR_C_decr_MR_CSharp_IncrDecrD(MR.CS.CSharp.IncrDecrD._Underlying *_this);
                    IncrDecrD __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrD __ret = new(__MR_C_decr_MR_CSharp_IncrDecrD(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrD`/`Const_IncrDecrD` directly.
            /// </summary>
            public class _InOptMut_IncrDecrD
            {
                public IncrDecrD? Opt;

                public _InOptMut_IncrDecrD() {}
                public _InOptMut_IncrDecrD(IncrDecrD value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrD(IncrDecrD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrD`/`Const_IncrDecrD` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrD
            {
                public Const_IncrDecrD? Opt;

                public _InOptConst_IncrDecrD() {}
                public _InOptConst_IncrDecrD(Const_IncrDecrD value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrD(Const_IncrDecrD value) {return new(value);}
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrE : MR.CS.Misc.Object<Const_IncrDecrE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrE_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrE() {Dispose(false);}

                internal unsafe Const_IncrDecrE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrE::IncrDecrE`.
                /// </summary>
                public unsafe Const_IncrDecrE(MR.CS.CSharp._ByValue_IncrDecrE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrE : Const_IncrDecrE
            {
                internal unsafe IncrDecrE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrE::IncrDecrE`.
                /// </summary>
                public unsafe IncrDecrE(MR.CS.CSharp._ByValue_IncrDecrE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_CSharp_IncrDecrE_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrE_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrE::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_C_incr_MR_CSharp_IncrDecrE(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrE __ret = new(__MR_C_incr_MR_CSharp_IncrDecrE(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrE::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrE", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrE._Underlying *__MR_C_decr_MR_CSharp_IncrDecrE(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrE __ret = new(__MR_C_decr_MR_CSharp_IncrDecrE(_UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `IncrDecrE` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_IncrDecrE
            {
                internal readonly Const_IncrDecrE? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IncrDecrE() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IncrDecrE(MR.CS.Misc._Moved<IncrDecrE> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IncrDecrE(MR.CS.Misc._Moved<IncrDecrE> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrE`/`Const_IncrDecrE` directly.
            /// </summary>
            public class _InOptMut_IncrDecrE
            {
                public IncrDecrE? Opt;

                public _InOptMut_IncrDecrE() {}
                public _InOptMut_IncrDecrE(IncrDecrE value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrE(IncrDecrE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrE`/`Const_IncrDecrE` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrE
            {
                public Const_IncrDecrE? Opt;

                public _InOptConst_IncrDecrE() {}
                public _InOptConst_IncrDecrE(Const_IncrDecrE value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrE(Const_IncrDecrE value) {return new(value);}
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrF`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrF : MR.CS.Misc.Object<Const_IncrDecrF>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrF_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrF() {Dispose(false);}

                internal unsafe Const_IncrDecrF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrF::IncrDecrF`.
                /// </summary>
                public unsafe Const_IncrDecrF(MR.CS.CSharp._ByValue_IncrDecrF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrF::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrF", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrF._Underlying *__MR_C_incr_MR_CSharp_IncrDecrF(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrF __ret = new(__MR_C_incr_MR_CSharp_IncrDecrF(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrF::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrF", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrF._Underlying *__MR_C_decr_MR_CSharp_IncrDecrF(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrF __ret = new(__MR_C_decr_MR_CSharp_IncrDecrF(_UnderlyingPtr), is_owning: false);
                }
            }

            // Here we don't special-case those operators due to the class being non-copyable (and not trivially movable). They get spawned as functions as usual, in the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrF`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrF : Const_IncrDecrF
            {
                internal unsafe IncrDecrF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrF::IncrDecrF`.
                /// </summary>
                public unsafe IncrDecrF(MR.CS.CSharp._ByValue_IncrDecrF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrF._Underlying *__MR_CSharp_IncrDecrF_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IncrDecrF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrF_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `IncrDecrF` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_IncrDecrF
            {
                internal readonly Const_IncrDecrF? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IncrDecrF() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IncrDecrF(MR.CS.Misc._Moved<IncrDecrF> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IncrDecrF(MR.CS.Misc._Moved<IncrDecrF> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrF`/`Const_IncrDecrF` directly.
            /// </summary>
            public class _InOptMut_IncrDecrF
            {
                public IncrDecrF? Opt;

                public _InOptMut_IncrDecrF() {}
                public _InOptMut_IncrDecrF(IncrDecrF value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrF(IncrDecrF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrF`/`Const_IncrDecrF` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrF
            {
                public Const_IncrDecrF? Opt;

                public _InOptConst_IncrDecrF() {}
                public _InOptConst_IncrDecrF(Const_IncrDecrF value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrF(Const_IncrDecrF value) {return new(value);}
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrG`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrG : MR.CS.Misc.Object<Const_IncrDecrG>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrG_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrG() {Dispose(false);}

                internal unsafe Const_IncrDecrG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrG::IncrDecrG`.
                /// </summary>
                public unsafe Const_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_ConstructFromAnother(MR.CS.CSharp.IncrDecrG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrG::operator++`.
                /// </summary>
                public static unsafe IncrDecrG operator++(MR.CS.CSharp.Const_IncrDecrG _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_incr_MR_CSharp_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG._Underlying *_this);
                    IncrDecrG __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrG __ret = new(__MR_C_incr_MR_CSharp_IncrDecrG(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrG::operator--`.
                /// </summary>
                public static unsafe IncrDecrG operator--(MR.CS.CSharp.Const_IncrDecrG _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_decr_MR_CSharp_IncrDecrG(MR.CS.CSharp.Const_IncrDecrG._Underlying *_this);
                    IncrDecrG __this_copy = new(_this);
                    MR.CS.CSharp.IncrDecrG __ret = new(__MR_C_decr_MR_CSharp_IncrDecrG(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrG`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrG : Const_IncrDecrG
            {
                internal unsafe IncrDecrG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrG::IncrDecrG`.
                /// </summary>
                public unsafe IncrDecrG(MR.CS.CSharp.Const_IncrDecrG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_CSharp_IncrDecrG_ConstructFromAnother(MR.CS.CSharp.IncrDecrG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrG::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_incr_MR_CSharp_IncrDecrG(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrG __ret = new(__MR_C_incr_MR_CSharp_IncrDecrG(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrG::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrG", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrG._Underlying *__MR_C_decr_MR_CSharp_IncrDecrG(_Underlying *_this);
                    MR.CS.CSharp.IncrDecrG __ret = new(__MR_C_decr_MR_CSharp_IncrDecrG(_UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrG`/`Const_IncrDecrG` directly.
            /// </summary>
            public class _InOptMut_IncrDecrG
            {
                public IncrDecrG? Opt;

                public _InOptMut_IncrDecrG() {}
                public _InOptMut_IncrDecrG(IncrDecrG value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrG(IncrDecrG value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrG`/`Const_IncrDecrG` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrG
            {
                public Const_IncrDecrG? Opt;

                public _InOptConst_IncrDecrG() {}
                public _InOptConst_IncrDecrG(Const_IncrDecrG value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrG(Const_IncrDecrG value) {return new(value);}
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrH`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrH : MR.CS.Misc.Object<Const_IncrDecrH>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrH_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrH() {Dispose(false);}

                internal unsafe Const_IncrDecrH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrH::IncrDecrH`.
                /// </summary>
                public unsafe Const_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_ConstructFromAnother(MR.CS.CSharp.IncrDecrH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrH::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_incr_MR_CSharp_IncrDecrH(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrH __ret = new(__MR_C_incr_MR_CSharp_IncrDecrH(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrH::operator++`.
                /// </summary>
                public static unsafe IncrDecrH operator++(MR.CS.CSharp.Const_IncrDecrH _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_incr_MR_CSharp_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH._Underlying *_this);
                    IncrDecrH __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrH __ret = new(__MR_C_incr_MR_CSharp_IncrDecrH(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrH::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_decr_MR_CSharp_IncrDecrH(_Underlying *_this);
                    MR.CS.CSharp.Const_IncrDecrH __ret = new(__MR_C_decr_MR_CSharp_IncrDecrH(_UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrH::operator--`.
                /// </summary>
                public static unsafe IncrDecrH operator--(MR.CS.CSharp.Const_IncrDecrH _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrH", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IncrDecrH._Underlying *__MR_C_decr_MR_CSharp_IncrDecrH(MR.CS.CSharp.Const_IncrDecrH._Underlying *_this);
                    IncrDecrH __this_copy = new(_this);
                    MR.CS.CSharp.Const_IncrDecrH __ret = new(__MR_C_decr_MR_CSharp_IncrDecrH(__this_copy._UnderlyingPtr), is_owning: false);
                    return __this_copy;
                }
            }

            // This class is non-copyable, but is trivially movable, so we treat it as if it was copyable.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrH`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrH : Const_IncrDecrH
            {
                internal unsafe IncrDecrH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrH::IncrDecrH`.
                /// </summary>
                public unsafe IncrDecrH(MR.CS.CSharp.Const_IncrDecrH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrH._Underlying *__MR_CSharp_IncrDecrH_ConstructFromAnother(MR.CS.CSharp.IncrDecrH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrH`/`Const_IncrDecrH` directly.
            /// </summary>
            public class _InOptMut_IncrDecrH
            {
                public IncrDecrH? Opt;

                public _InOptMut_IncrDecrH() {}
                public _InOptMut_IncrDecrH(IncrDecrH value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrH(IncrDecrH value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrH`/`Const_IncrDecrH` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrH
            {
                public Const_IncrDecrH? Opt;

                public _InOptConst_IncrDecrH() {}
                public _InOptConst_IncrDecrH(Const_IncrDecrH value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrH(Const_IncrDecrH value) {return new(value);}
            }

            // Friend functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrI`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IncrDecrI : MR.CS.Misc.Object<Const_IncrDecrI>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IncrDecrI_Destroy(_Underlying *_this);
                    __MR_CSharp_IncrDecrI_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IncrDecrI() {Dispose(false);}

                internal unsafe Const_IncrDecrI(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IncrDecrI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                /// </summary>
                public unsafe Const_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_ConstructFromAnother(MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                /// </summary>
                public Const_IncrDecrI(IncrDecrI _other) : this((Const_IncrDecrI)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_incr_MR_CSharp_IncrDecrI(_Underlying *_1);
                    int __ret = __MR_C_incr_MR_CSharp_IncrDecrI(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator++`.
                /// </summary>
                public static unsafe IncrDecrI operator++(MR.CS.CSharp.Const_IncrDecrI _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_incr_MR_CSharp_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI._Underlying *_1);
                    IncrDecrI __this_copy = new(_1);
                    int __ret = __MR_C_incr_MR_CSharp_IncrDecrI(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_decr_MR_CSharp_IncrDecrI(_Underlying *_1);
                    int __ret = __MR_C_decr_MR_CSharp_IncrDecrI(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public static unsafe IncrDecrI operator--(MR.CS.CSharp.Const_IncrDecrI _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_IncrDecrI", ExactSpelling = true)]
                    extern static int __MR_C_decr_MR_CSharp_IncrDecrI(MR.CS.CSharp.Const_IncrDecrI._Underlying *_1);
                    IncrDecrI __this_copy = new(_1);
                    int __ret = __MR_C_decr_MR_CSharp_IncrDecrI(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }
            }

            // Friend functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IncrDecrI`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IncrDecrI : Const_IncrDecrI
            {
                internal unsafe IncrDecrI(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IncrDecrI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                /// </summary>
                public unsafe IncrDecrI(MR.CS.CSharp.Const_IncrDecrI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_ConstructFromAnother(MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IncrDecrI_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IncrDecrI::IncrDecrI`.
                /// </summary>
                public IncrDecrI(IncrDecrI _other) : this((Const_IncrDecrI)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IncrDecrI::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IncrDecrI assign(MR.CS.CSharp.Const_IncrDecrI _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IncrDecrI_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IncrDecrI._Underlying *__MR_CSharp_IncrDecrI_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IncrDecrI._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IncrDecrI_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrI` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IncrDecrI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrI`/`Const_IncrDecrI` directly.
            /// </summary>
            public class _InOptMut_IncrDecrI
            {
                public IncrDecrI? Opt;

                public _InOptMut_IncrDecrI() {}
                public _InOptMut_IncrDecrI(IncrDecrI value) {Opt = value;}
                public static implicit operator _InOptMut_IncrDecrI(IncrDecrI value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IncrDecrI` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IncrDecrI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IncrDecrI`/`Const_IncrDecrI` to pass it to the function.
            /// </summary>
            public class _InOptConst_IncrDecrI
            {
                public Const_IncrDecrI? Opt;

                public _InOptConst_IncrDecrI() {}
                public _InOptConst_IncrDecrI(Const_IncrDecrI value) {Opt = value;}
                public static implicit operator _InOptConst_IncrDecrI(Const_IncrDecrI value) {return new(value);}
            }

            // Test equality comparison.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_EqualityA : MR.CS.Misc.Object<Const_EqualityA>, System.IDisposable, System.IEquatable<MR.CS.CSharp.Const_EqualityA>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityA_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityA() {Dispose(false);}

                internal unsafe Const_EqualityA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_EqualityA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                /// </summary>
                public unsafe Const_EqualityA(MR.CS.CSharp.Const_EqualityA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_ConstructFromAnother(MR.CS.CSharp.EqualityA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                /// </summary>
                public Const_EqualityA(EqualityA _other) : this((Const_EqualityA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityA::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.Const_EqualityA _this, MR.CS.CSharp.Const_EqualityA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityA", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityA(MR.CS.CSharp.Const_EqualityA._Underlying *_this, MR.CS.CSharp.Const_EqualityA._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityA(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Const_EqualityA _this, MR.CS.CSharp.Const_EqualityA _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.Const_EqualityA? _1)
                {
                    if (_1 is null)
                        return false;
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.Const_EqualityA)
                        return this == (MR.CS.CSharp.Const_EqualityA)other;
                    return false;
                }
            }

            // Test equality comparison.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class EqualityA : Const_EqualityA, System.IEquatable<int>
            {
                internal unsafe EqualityA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe EqualityA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                /// </summary>
                public unsafe EqualityA(MR.CS.CSharp.Const_EqualityA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_ConstructFromAnother(MR.CS.CSharp.EqualityA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityA::EqualityA`.
                /// </summary>
                public EqualityA(EqualityA _other) : this((Const_EqualityA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.EqualityA assign(MR.CS.CSharp.Const_EqualityA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityA._Underlying *__MR_CSharp_EqualityA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_EqualityA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityA::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.EqualityA _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityA_int32_t", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityA_int32_t(MR.CS.CSharp.EqualityA._Underlying *_this, int _1);
                    return __MR_C_equal_MR_CSharp_EqualityA_int32_t(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityA _this, int _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(int _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is int)
                        return this == (int)other;
                    return base.Equals(other);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityA`/`Const_EqualityA` directly.
            /// </summary>
            public class _InOptMut_EqualityA
            {
                public EqualityA? Opt;

                public _InOptMut_EqualityA() {}
                public _InOptMut_EqualityA(EqualityA value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityA(EqualityA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityA`/`Const_EqualityA` to pass it to the function.
            /// </summary>
            public class _InOptConst_EqualityA
            {
                public Const_EqualityA? Opt;

                public _InOptConst_EqualityA() {}
                public _InOptConst_EqualityA(Const_EqualityA value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityA(Const_EqualityA value) {return new(value);}
            }

            // Return type isn't `bool`.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_EqualityB : MR.CS.Misc.Object<Const_EqualityB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityB_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityB() {Dispose(false);}

                internal unsafe Const_EqualityB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_EqualityB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                /// </summary>
                public unsafe Const_EqualityB(MR.CS.CSharp.Const_EqualityB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_ConstructFromAnother(MR.CS.CSharp.EqualityB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                /// </summary>
                public Const_EqualityB(EqualityB _other) : this((Const_EqualityB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityB::operator==`.
                /// </summary>
                public unsafe int equal(MR.CS.CSharp.Const_EqualityB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityB", ExactSpelling = true)]
                    extern static int __MR_C_equal_MR_CSharp_EqualityB(_Underlying *_this, MR.CS.CSharp.Const_EqualityB._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityB(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // Return type isn't `bool`.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class EqualityB : Const_EqualityB
            {
                internal unsafe EqualityB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe EqualityB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                /// </summary>
                public unsafe EqualityB(MR.CS.CSharp.Const_EqualityB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_ConstructFromAnother(MR.CS.CSharp.EqualityB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityB::EqualityB`.
                /// </summary>
                public EqualityB(EqualityB _other) : this((Const_EqualityB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.EqualityB assign(MR.CS.CSharp.Const_EqualityB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityB._Underlying *__MR_CSharp_EqualityB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_EqualityB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityB::operator==`.
                /// </summary>
                public unsafe int equal(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityB_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_equal_MR_CSharp_EqualityB_int32_t(_Underlying *_this, int _1);
                    return __MR_C_equal_MR_CSharp_EqualityB_int32_t(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityB::operator!=`.
                /// </summary>
                public unsafe int notEqual(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_equal_MR_CSharp_EqualityB_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_not_equal_MR_CSharp_EqualityB_int32_t(_Underlying *_this, int _1);
                    return __MR_C_not_equal_MR_CSharp_EqualityB_int32_t(_UnderlyingPtr, _1);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityB`/`Const_EqualityB` directly.
            /// </summary>
            public class _InOptMut_EqualityB
            {
                public EqualityB? Opt;

                public _InOptMut_EqualityB() {}
                public _InOptMut_EqualityB(EqualityB value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityB(EqualityB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityB`/`Const_EqualityB` to pass it to the function.
            /// </summary>
            public class _InOptConst_EqualityB
            {
                public Const_EqualityB? Opt;

                public _InOptConst_EqualityB() {}
                public _InOptConst_EqualityB(Const_EqualityB value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityB(Const_EqualityB value) {return new(value);}
            }

            // Return type is `void`.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_EqualityC : MR.CS.Misc.Object<Const_EqualityC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityC_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityC() {Dispose(false);}

                internal unsafe Const_EqualityC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_EqualityC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                /// </summary>
                public unsafe Const_EqualityC(MR.CS.CSharp.Const_EqualityC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_ConstructFromAnother(MR.CS.CSharp.EqualityC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                /// </summary>
                public Const_EqualityC(EqualityC _other) : this((Const_EqualityC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityC::operator==`.
                /// </summary>
                public unsafe void equal(MR.CS.CSharp.Const_EqualityC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityC", ExactSpelling = true)]
                    extern static void __MR_C_equal_MR_CSharp_EqualityC(_Underlying *_this, MR.CS.CSharp.Const_EqualityC._Underlying *_1);
                    __MR_C_equal_MR_CSharp_EqualityC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // Return type is `void`.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class EqualityC : Const_EqualityC
            {
                internal unsafe EqualityC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe EqualityC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                /// </summary>
                public unsafe EqualityC(MR.CS.CSharp.Const_EqualityC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_ConstructFromAnother(MR.CS.CSharp.EqualityC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityC::EqualityC`.
                /// </summary>
                public EqualityC(EqualityC _other) : this((Const_EqualityC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.EqualityC assign(MR.CS.CSharp.Const_EqualityC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityC._Underlying *__MR_CSharp_EqualityC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_EqualityC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityC::operator==`.
                /// </summary>
                public unsafe void equal(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityC_int32_t", ExactSpelling = true)]
                    extern static void __MR_C_equal_MR_CSharp_EqualityC_int32_t(_Underlying *_this, int _1);
                    __MR_C_equal_MR_CSharp_EqualityC_int32_t(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityC::operator!=`.
                /// </summary>
                public unsafe void notEqual(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_equal_MR_CSharp_EqualityC_int32_t", ExactSpelling = true)]
                    extern static void __MR_C_not_equal_MR_CSharp_EqualityC_int32_t(_Underlying *_this, int _1);
                    __MR_C_not_equal_MR_CSharp_EqualityC_int32_t(_UnderlyingPtr, _1);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityC`/`Const_EqualityC` directly.
            /// </summary>
            public class _InOptMut_EqualityC
            {
                public EqualityC? Opt;

                public _InOptMut_EqualityC() {}
                public _InOptMut_EqualityC(EqualityC value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityC(EqualityC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityC`/`Const_EqualityC` to pass it to the function.
            /// </summary>
            public class _InOptConst_EqualityC
            {
                public Const_EqualityC? Opt;

                public _InOptConst_EqualityC() {}
                public _InOptConst_EqualityC(Const_EqualityC value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityC(Const_EqualityC value) {return new(value);}
            }

            // The C# parameter type ends with `?`, and isn't a managed type.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_EqualityD : MR.CS.Misc.Object<Const_EqualityD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityD_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityD() {Dispose(false);}

                internal unsafe Const_EqualityD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_EqualityD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                /// </summary>
                public unsafe Const_EqualityD(MR.CS.CSharp.Const_EqualityD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_ConstructFromAnother(MR.CS.CSharp.EqualityD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                /// </summary>
                public Const_EqualityD(EqualityD _other) : this((Const_EqualityD)_other) {}
            }

            // The C# parameter type ends with `?`, and isn't a managed type.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class EqualityD : Const_EqualityD, System.IEquatable<int?>
            {
                internal unsafe EqualityD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe EqualityD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                /// </summary>
                public unsafe EqualityD(MR.CS.CSharp.Const_EqualityD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_ConstructFromAnother(MR.CS.CSharp.EqualityD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityD::EqualityD`.
                /// </summary>
                public EqualityD(EqualityD _other) : this((Const_EqualityD)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.EqualityD assign(MR.CS.CSharp.Const_EqualityD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityD._Underlying *__MR_CSharp_EqualityD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityD._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_EqualityD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityD::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.EqualityD _this, int? _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityD_const_int32_t_ptr", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityD_const_int32_t_ptr(MR.CS.CSharp.EqualityD._Underlying *_this, int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    return __MR_C_equal_MR_CSharp_EqualityD_const_int32_t_ptr(_this._UnderlyingPtr, _1.HasValue ? &__deref__1 : null) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityD _this, int? _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(int? _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is int)
                        return this == (int)other;
                    return false;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityD`/`Const_EqualityD` directly.
            /// </summary>
            public class _InOptMut_EqualityD
            {
                public EqualityD? Opt;

                public _InOptMut_EqualityD() {}
                public _InOptMut_EqualityD(EqualityD value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityD(EqualityD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityD`/`Const_EqualityD` to pass it to the function.
            /// </summary>
            public class _InOptConst_EqualityD
            {
                public Const_EqualityD? Opt;

                public _InOptConst_EqualityD() {}
                public _InOptConst_EqualityD(Const_EqualityD value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityD(Const_EqualityD value) {return new(value);}
            }

            // The C# parameter type ends with `?`, and is a managed type.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_EqualityE : MR.CS.Misc.Object<Const_EqualityE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_EqualityE_Destroy(_Underlying *_this);
                    __MR_CSharp_EqualityE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_EqualityE() {Dispose(false);}

                internal unsafe Const_EqualityE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_EqualityE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                /// </summary>
                public unsafe Const_EqualityE(MR.CS.CSharp.Const_EqualityE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_ConstructFromAnother(MR.CS.CSharp.EqualityE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                /// </summary>
                public Const_EqualityE(EqualityE _other) : this((Const_EqualityE)_other) {}
            }

            // The C# parameter type ends with `?`, and is a managed type.
            /// <summary>
            /// Generated from class `MR::CSharp::EqualityE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class EqualityE : Const_EqualityE, System.IEquatable<MR.CS.CSharp.EqualityD?>
            {
                internal unsafe EqualityE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe EqualityE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_EqualityE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                /// </summary>
                public unsafe EqualityE(MR.CS.CSharp.Const_EqualityE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_ConstructFromAnother(MR.CS.CSharp.EqualityE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_EqualityE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::EqualityE::EqualityE`.
                /// </summary>
                public EqualityE(EqualityE _other) : this((Const_EqualityE)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.EqualityE assign(MR.CS.CSharp.Const_EqualityE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_EqualityE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.EqualityE._Underlying *__MR_CSharp_EqualityE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.EqualityE._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_EqualityE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::EqualityE::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.EqualityE _this, MR.CS.CSharp.EqualityD? _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr(MR.CS.CSharp.EqualityE._Underlying *_this, MR.CS.CSharp.EqualityD._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_EqualityE_MR_CSharp_EqualityD_ptr(_this._UnderlyingPtr, _1 is not null ? _1._UnderlyingPtr : null) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.EqualityE _this, MR.CS.CSharp.EqualityD? _1)
                {
                    return !(_this == _1);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.EqualityD? _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.EqualityD)
                        return this == (MR.CS.CSharp.EqualityD)other;
                    return false;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_EqualityE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityE`/`Const_EqualityE` directly.
            /// </summary>
            public class _InOptMut_EqualityE
            {
                public EqualityE? Opt;

                public _InOptMut_EqualityE() {}
                public _InOptMut_EqualityE(EqualityE value) {Opt = value;}
                public static implicit operator _InOptMut_EqualityE(EqualityE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `EqualityE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_EqualityE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `EqualityE`/`Const_EqualityE` to pass it to the function.
            /// </summary>
            public class _InOptConst_EqualityE
            {
                public Const_EqualityE? Opt;

                public _InOptConst_EqualityE() {}
                public _InOptConst_EqualityE(Const_EqualityE value) {Opt = value;}
                public static implicit operator _InOptConst_EqualityE(Const_EqualityE value) {return new(value);}
            }

            // The happy path, the operator is const.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalA : MR.CS.Misc.Object<Const_RelationalA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalA_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalA() {Dispose(false);}

                internal unsafe Const_RelationalA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                /// </summary>
                public unsafe Const_RelationalA(MR.CS.CSharp.Const_RelationalA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_ConstructFromAnother(MR.CS.CSharp.RelationalA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                /// </summary>
                public Const_RelationalA(RelationalA _other) : this((Const_RelationalA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalA::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalA", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalA(MR.CS.CSharp.Const_RelationalA._Underlying *_this, MR.CS.CSharp.Const_RelationalA._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalA(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.Const_RelationalA _this, MR.CS.CSharp.Const_RelationalA _1)
                {
                    return !(_this < _1);
                }
            }

            // The happy path, the operator is const.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalA : Const_RelationalA
            {
                internal unsafe RelationalA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                /// </summary>
                public unsafe RelationalA(MR.CS.CSharp.Const_RelationalA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_ConstructFromAnother(MR.CS.CSharp.RelationalA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalA::RelationalA`.
                /// </summary>
                public RelationalA(RelationalA _other) : this((Const_RelationalA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalA assign(MR.CS.CSharp.Const_RelationalA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalA._Underlying *__MR_CSharp_RelationalA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalA`/`Const_RelationalA` directly.
            /// </summary>
            public class _InOptMut_RelationalA
            {
                public RelationalA? Opt;

                public _InOptMut_RelationalA() {}
                public _InOptMut_RelationalA(RelationalA value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalA(RelationalA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalA`/`Const_RelationalA` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalA
            {
                public Const_RelationalA? Opt;

                public _InOptConst_RelationalA() {}
                public _InOptConst_RelationalA(Const_RelationalA value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalA(Const_RelationalA value) {return new(value);}
            }

            // The happy path, the operator is non-const.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalB : MR.CS.Misc.Object<Const_RelationalB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalB_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalB() {Dispose(false);}

                internal unsafe Const_RelationalB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                /// </summary>
                public unsafe Const_RelationalB(MR.CS.CSharp.Const_RelationalB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_ConstructFromAnother(MR.CS.CSharp.RelationalB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                /// </summary>
                public Const_RelationalB(RelationalB _other) : this((Const_RelationalB)_other) {}
            }

            // The happy path, the operator is non-const.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalB : Const_RelationalB
            {
                internal unsafe RelationalB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                /// </summary>
                public unsafe RelationalB(MR.CS.CSharp.Const_RelationalB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_ConstructFromAnother(MR.CS.CSharp.RelationalB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalB::RelationalB`.
                /// </summary>
                public RelationalB(RelationalB _other) : this((Const_RelationalB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalB assign(MR.CS.CSharp.Const_RelationalB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalB._Underlying *__MR_CSharp_RelationalB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalB::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalB", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalB(MR.CS.CSharp.RelationalB._Underlying *_this, MR.CS.CSharp.RelationalB._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalB(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.RelationalB _this, MR.CS.CSharp.RelationalB _1)
                {
                    return !(_this < _1);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalB`/`Const_RelationalB` directly.
            /// </summary>
            public class _InOptMut_RelationalB
            {
                public RelationalB? Opt;

                public _InOptMut_RelationalB() {}
                public _InOptMut_RelationalB(RelationalB value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalB(RelationalB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalB`/`Const_RelationalB` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalB
            {
                public Const_RelationalB? Opt;

                public _InOptConst_RelationalB() {}
                public _InOptConst_RelationalB(Const_RelationalB value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalB(Const_RelationalB value) {return new(value);}
            }

            // The operators have mixed constness, which causes them to be demoted to functions.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalC : MR.CS.Misc.Object<Const_RelationalC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalC_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalC() {Dispose(false);}

                internal unsafe Const_RelationalC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                /// </summary>
                public unsafe Const_RelationalC(MR.CS.CSharp.Const_RelationalC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_ConstructFromAnother(MR.CS.CSharp.RelationalC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                /// </summary>
                public Const_RelationalC(RelationalC _other) : this((Const_RelationalC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalC::operator<`.
                /// </summary>
                public unsafe bool less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalC::operator>`.
                /// </summary>
                public unsafe bool greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                // bool operator<=(RelationalC &) const {return false;} // Skip one operator to observe the function missing.
                /// <summary>
                /// Generated from method `MR::CSharp::RelationalC::operator>=`.
                /// </summary>
                public unsafe bool greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_equal_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }
            }

            // The operators have mixed constness, which causes them to be demoted to functions.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalC : Const_RelationalC
            {
                internal unsafe RelationalC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                /// </summary>
                public unsafe RelationalC(MR.CS.CSharp.Const_RelationalC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_ConstructFromAnother(MR.CS.CSharp.RelationalC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalC::RelationalC`.
                /// </summary>
                public RelationalC(RelationalC _other) : this((Const_RelationalC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalC assign(MR.CS.CSharp.Const_RelationalC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalC._Underlying *__MR_CSharp_RelationalC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalC`/`Const_RelationalC` directly.
            /// </summary>
            public class _InOptMut_RelationalC
            {
                public RelationalC? Opt;

                public _InOptMut_RelationalC() {}
                public _InOptMut_RelationalC(RelationalC value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalC(RelationalC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalC`/`Const_RelationalC` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalC
            {
                public Const_RelationalC? Opt;

                public _InOptConst_RelationalC() {}
                public _InOptConst_RelationalC(Const_RelationalC value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalC(Const_RelationalC value) {return new(value);}
            }

            // The operators have operands of different types, causing them to be demoted to functions.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalD : MR.CS.Misc.Object<Const_RelationalD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalD_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalD() {Dispose(false);}

                internal unsafe Const_RelationalD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                /// </summary>
                public unsafe Const_RelationalD(MR.CS.CSharp.Const_RelationalD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_ConstructFromAnother(MR.CS.CSharp.RelationalD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                /// </summary>
                public Const_RelationalD(RelationalD _other) : this((Const_RelationalD)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalD::operator<`.
                /// </summary>
                public unsafe bool less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalD::operator>`.
                /// </summary>
                public unsafe bool greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalD::operator<=`.
                /// </summary>
                public unsafe bool lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalD::operator>=`.
                /// </summary>
                public unsafe bool greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static byte __MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalD_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }
            }

            // The operators have operands of different types, causing them to be demoted to functions.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalD : Const_RelationalD
            {
                internal unsafe RelationalD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                /// </summary>
                public unsafe RelationalD(MR.CS.CSharp.Const_RelationalD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_ConstructFromAnother(MR.CS.CSharp.RelationalD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalD::RelationalD`.
                /// </summary>
                public RelationalD(RelationalD _other) : this((Const_RelationalD)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalD assign(MR.CS.CSharp.Const_RelationalD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalD._Underlying *__MR_CSharp_RelationalD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalD._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalD`/`Const_RelationalD` directly.
            /// </summary>
            public class _InOptMut_RelationalD
            {
                public RelationalD? Opt;

                public _InOptMut_RelationalD() {}
                public _InOptMut_RelationalD(RelationalD value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalD(RelationalD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalD`/`Const_RelationalD` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalD
            {
                public Const_RelationalD? Opt;

                public _InOptConst_RelationalD() {}
                public _InOptConst_RelationalD(Const_RelationalD value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalD(Const_RelationalD value) {return new(value);}
            }

            // The operators have a weird return type.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalE : MR.CS.Misc.Object<Const_RelationalE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalE_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalE() {Dispose(false);}

                internal unsafe Const_RelationalE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                /// </summary>
                public unsafe Const_RelationalE(MR.CS.CSharp.Const_RelationalE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_ConstructFromAnother(MR.CS.CSharp.RelationalE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                /// </summary>
                public Const_RelationalE(RelationalE _other) : this((Const_RelationalE)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalE::operator<`.
                /// </summary>
                public unsafe int less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalE::operator>`.
                /// </summary>
                public unsafe int greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalE::operator<=`.
                /// </summary>
                public unsafe int lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_less_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalE::operator>=`.
                /// </summary>
                public unsafe int greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static int __MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    return __MR_C_greater_equal_MR_CSharp_RelationalE_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // The operators have a weird return type.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalE : Const_RelationalE
            {
                internal unsafe RelationalE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                /// </summary>
                public unsafe RelationalE(MR.CS.CSharp.Const_RelationalE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_ConstructFromAnother(MR.CS.CSharp.RelationalE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalE::RelationalE`.
                /// </summary>
                public RelationalE(RelationalE _other) : this((Const_RelationalE)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalE assign(MR.CS.CSharp.Const_RelationalE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalE._Underlying *__MR_CSharp_RelationalE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalE._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalE`/`Const_RelationalE` directly.
            /// </summary>
            public class _InOptMut_RelationalE
            {
                public RelationalE? Opt;

                public _InOptMut_RelationalE() {}
                public _InOptMut_RelationalE(RelationalE value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalE(RelationalE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalE`/`Const_RelationalE` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalE
            {
                public Const_RelationalE? Opt;

                public _InOptConst_RelationalE() {}
                public _InOptConst_RelationalE(Const_RelationalE value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalE(Const_RelationalE value) {return new(value);}
            }

            // The operators return void.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalF`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_RelationalF : MR.CS.Misc.Object<Const_RelationalF>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_RelationalF_Destroy(_Underlying *_this);
                    __MR_CSharp_RelationalF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_RelationalF() {Dispose(false);}

                internal unsafe Const_RelationalF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_RelationalF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                /// </summary>
                public unsafe Const_RelationalF(MR.CS.CSharp.Const_RelationalF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_ConstructFromAnother(MR.CS.CSharp.RelationalF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                /// </summary>
                public Const_RelationalF(RelationalF _other) : this((Const_RelationalF)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalF::operator<`.
                /// </summary>
                public unsafe void less(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_less_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalF::operator>`.
                /// </summary>
                public unsafe void greater(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_greater_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalF::operator<=`.
                /// </summary>
                public unsafe void lessEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_less_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalF::operator>=`.
                /// </summary>
                public unsafe void greaterEqual(MR.CS.CSharp.RelationalC _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC", ExactSpelling = true)]
                    extern static void __MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_Underlying *_this, MR.CS.CSharp.RelationalC._Underlying *_1);
                    __MR_C_greater_equal_MR_CSharp_RelationalF_MR_CSharp_RelationalC(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            // The operators return void.
            /// <summary>
            /// Generated from class `MR::CSharp::RelationalF`.
            /// This is the non-const half of the class.
            /// </summary>
            public class RelationalF : Const_RelationalF
            {
                internal unsafe RelationalF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe RelationalF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_RelationalF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                /// </summary>
                public unsafe RelationalF(MR.CS.CSharp.Const_RelationalF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_ConstructFromAnother(MR.CS.CSharp.RelationalF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_RelationalF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::RelationalF::RelationalF`.
                /// </summary>
                public RelationalF(RelationalF _other) : this((Const_RelationalF)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::RelationalF::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.RelationalF assign(MR.CS.CSharp.Const_RelationalF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_RelationalF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.RelationalF._Underlying *__MR_CSharp_RelationalF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.RelationalF._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_RelationalF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_RelationalF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalF`/`Const_RelationalF` directly.
            /// </summary>
            public class _InOptMut_RelationalF
            {
                public RelationalF? Opt;

                public _InOptMut_RelationalF() {}
                public _InOptMut_RelationalF(RelationalF value) {Opt = value;}
                public static implicit operator _InOptMut_RelationalF(RelationalF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `RelationalF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_RelationalF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `RelationalF`/`Const_RelationalF` to pass it to the function.
            /// </summary>
            public class _InOptConst_RelationalF
            {
                public Const_RelationalF? Opt;

                public _InOptConst_RelationalF() {}
                public _InOptConst_RelationalF(Const_RelationalF value) {Opt = value;}
                public static implicit operator _InOptConst_RelationalF(Const_RelationalF value) {return new(value);}
            }

            // The operator is injected correctly.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsA : MR.CS.Misc.Object<Const_StaticOpsLhsA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsA_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsA() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                /// </summary>
                public unsafe Const_StaticOpsLhsA(MR.CS.CSharp.Const_StaticOpsLhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                /// </summary>
                public Const_StaticOpsLhsA(StaticOpsLhsA _other) : this((Const_StaticOpsLhsA)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(Const_StaticOpsLhsA _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsA_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsA_int32_t(MR.CS.CSharp.StaticOpsLhsA._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsA_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            // The operator is injected correctly.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsA : Const_StaticOpsLhsA
            {
                internal unsafe StaticOpsLhsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                /// </summary>
                public unsafe StaticOpsLhsA(MR.CS.CSharp.Const_StaticOpsLhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsA::StaticOpsLhsA`.
                /// </summary>
                public StaticOpsLhsA(StaticOpsLhsA _other) : this((Const_StaticOpsLhsA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsA assign(MR.CS.CSharp.Const_StaticOpsLhsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsA._Underlying *__MR_CSharp_StaticOpsLhsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsLhsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsA`/`Const_StaticOpsLhsA` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsA
            {
                public StaticOpsLhsA? Opt;

                public _InOptMut_StaticOpsLhsA() {}
                public _InOptMut_StaticOpsLhsA(StaticOpsLhsA value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsA(StaticOpsLhsA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsA`/`Const_StaticOpsLhsA` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsA
            {
                public Const_StaticOpsLhsA? Opt;

                public _InOptConst_StaticOpsLhsA() {}
                public _InOptConst_StaticOpsLhsA(Const_StaticOpsLhsA value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsA(Const_StaticOpsLhsA value) {return new(value);}
            }

            // The operator injects but becomes a function, because it returns void.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsB : MR.CS.Misc.Object<Const_StaticOpsLhsB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsB_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsB() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                /// </summary>
                public unsafe Const_StaticOpsLhsB(MR.CS.CSharp.Const_StaticOpsLhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                /// </summary>
                public Const_StaticOpsLhsB(StaticOpsLhsB _other) : this((Const_StaticOpsLhsB)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public unsafe void add(int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsB_int32_t", ExactSpelling = true)]
                    extern static void __MR_C_add_MR_CSharp_StaticOpsLhsB_int32_t(_Underlying *_1, int _2);
                    __MR_C_add_MR_CSharp_StaticOpsLhsB_int32_t(_UnderlyingPtr, _2);
                }
            }

            // The operator injects but becomes a function, because it returns void.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsB : Const_StaticOpsLhsB
            {
                internal unsafe StaticOpsLhsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                /// </summary>
                public unsafe StaticOpsLhsB(MR.CS.CSharp.Const_StaticOpsLhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsB::StaticOpsLhsB`.
                /// </summary>
                public StaticOpsLhsB(StaticOpsLhsB _other) : this((Const_StaticOpsLhsB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsB assign(MR.CS.CSharp.Const_StaticOpsLhsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsB._Underlying *__MR_CSharp_StaticOpsLhsB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsLhsB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsB`/`Const_StaticOpsLhsB` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsB
            {
                public StaticOpsLhsB? Opt;

                public _InOptMut_StaticOpsLhsB() {}
                public _InOptMut_StaticOpsLhsB(StaticOpsLhsB value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsB(StaticOpsLhsB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsB`/`Const_StaticOpsLhsB` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsB
            {
                public Const_StaticOpsLhsB? Opt;

                public _InOptConst_StaticOpsLhsB() {}
                public _InOptConst_StaticOpsLhsB(Const_StaticOpsLhsB value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsB(Const_StaticOpsLhsB value) {return new(value);}
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsC : MR.CS.Misc.Object<Const_StaticOpsLhsC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsC_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsC() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsC::StaticOpsLhsC`.
                /// </summary>
                public unsafe Const_StaticOpsLhsC(MR.CS.CSharp._ByValue_StaticOpsLhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsC : Const_StaticOpsLhsC
            {
                internal unsafe StaticOpsLhsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsC::StaticOpsLhsC`.
                /// </summary>
                public unsafe StaticOpsLhsC(MR.CS.CSharp._ByValue_StaticOpsLhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsC._Underlying *__MR_CSharp_StaticOpsLhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `StaticOpsLhsC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_StaticOpsLhsC
            {
                internal readonly Const_StaticOpsLhsC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_StaticOpsLhsC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_StaticOpsLhsC(MR.CS.Misc._Moved<StaticOpsLhsC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_StaticOpsLhsC(MR.CS.Misc._Moved<StaticOpsLhsC> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsC`/`Const_StaticOpsLhsC` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsC
            {
                public StaticOpsLhsC? Opt;

                public _InOptMut_StaticOpsLhsC() {}
                public _InOptMut_StaticOpsLhsC(StaticOpsLhsC value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsC(StaticOpsLhsC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsC`/`Const_StaticOpsLhsC` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsC
            {
                public Const_StaticOpsLhsC? Opt;

                public _InOptConst_StaticOpsLhsC() {}
                public _InOptConst_StaticOpsLhsC(Const_StaticOpsLhsC value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsC(Const_StaticOpsLhsC value) {return new(value);}
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsD : MR.CS.Misc.Object<Const_StaticOpsLhsD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsD_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsD() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsD::StaticOpsLhsD`.
                /// </summary>
                public unsafe Const_StaticOpsLhsD(MR.CS.CSharp.Const_StaticOpsLhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(Const_StaticOpsLhsD _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsD_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsD_int32_t(MR.CS.CSharp.StaticOpsLhsD._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsD_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsD : Const_StaticOpsLhsD
            {
                internal unsafe StaticOpsLhsD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsD::StaticOpsLhsD`.
                /// </summary>
                public unsafe StaticOpsLhsD(MR.CS.CSharp.Const_StaticOpsLhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsD._Underlying *__MR_CSharp_StaticOpsLhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsD`/`Const_StaticOpsLhsD` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsD
            {
                public StaticOpsLhsD? Opt;

                public _InOptMut_StaticOpsLhsD() {}
                public _InOptMut_StaticOpsLhsD(StaticOpsLhsD value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsD(StaticOpsLhsD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsD`/`Const_StaticOpsLhsD` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsD
            {
                public Const_StaticOpsLhsD? Opt;

                public _InOptConst_StaticOpsLhsD() {}
                public _InOptConst_StaticOpsLhsD(Const_StaticOpsLhsD value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsD(Const_StaticOpsLhsD value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsE : MR.CS.Misc.Object<Const_StaticOpsLhsE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsE_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsE() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsE::StaticOpsLhsE`.
                /// </summary>
                public unsafe Const_StaticOpsLhsE(MR.CS.CSharp.Const_StaticOpsLhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsE : Const_StaticOpsLhsE
            {
                internal unsafe StaticOpsLhsE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsE::StaticOpsLhsE`.
                /// </summary>
                public unsafe StaticOpsLhsE(MR.CS.CSharp.Const_StaticOpsLhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsE assign(MR.CS.CSharp.Const_StaticOpsLhsE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsE._Underlying *__MR_CSharp_StaticOpsLhsE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsE._Underlying *_other);
                    MR.CS.CSharp.StaticOpsLhsE __ret;
                    __ret = new(__MR_CSharp_StaticOpsLhsE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    __ret._KeepAlive(this);
                    return __ret;
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.StaticOpsLhsE _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsE_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsE_int32_t(MR.CS.CSharp.StaticOpsLhsE._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsE_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsE`/`Const_StaticOpsLhsE` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsE
            {
                public StaticOpsLhsE? Opt;

                public _InOptMut_StaticOpsLhsE() {}
                public _InOptMut_StaticOpsLhsE(StaticOpsLhsE value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsE(StaticOpsLhsE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsE`/`Const_StaticOpsLhsE` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsE
            {
                public Const_StaticOpsLhsE? Opt;

                public _InOptConst_StaticOpsLhsE() {}
                public _InOptConst_StaticOpsLhsE(Const_StaticOpsLhsE value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsE(Const_StaticOpsLhsE value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsF`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsF : MR.CS.Misc.Object<Const_StaticOpsLhsF>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsF_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsF() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsF::StaticOpsLhsF`.
                /// </summary>
                public unsafe Const_StaticOpsLhsF(MR.CS.CSharp.Const_StaticOpsLhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.Const_StaticOpsLhsF _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsF_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsF_int32_t(MR.CS.CSharp.Const_StaticOpsLhsF._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsF_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsF`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsF : Const_StaticOpsLhsF
            {
                internal unsafe StaticOpsLhsF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsF::StaticOpsLhsF`.
                /// </summary>
                public unsafe StaticOpsLhsF(MR.CS.CSharp.Const_StaticOpsLhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsF::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsF assign(MR.CS.CSharp.Const_StaticOpsLhsF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsF._Underlying *__MR_CSharp_StaticOpsLhsF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsF._Underlying *_other);
                    MR.CS.CSharp.StaticOpsLhsF __ret;
                    __ret = new(__MR_CSharp_StaticOpsLhsF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsF`/`Const_StaticOpsLhsF` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsF
            {
                public StaticOpsLhsF? Opt;

                public _InOptMut_StaticOpsLhsF() {}
                public _InOptMut_StaticOpsLhsF(StaticOpsLhsF value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsF(StaticOpsLhsF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsF`/`Const_StaticOpsLhsF` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsF
            {
                public Const_StaticOpsLhsF? Opt;

                public _InOptConst_StaticOpsLhsF() {}
                public _InOptConst_StaticOpsLhsF(Const_StaticOpsLhsF value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsF(Const_StaticOpsLhsF value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsG`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsG : MR.CS.Misc.Object<Const_StaticOpsLhsG>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsG_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsG() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsG::StaticOpsLhsG`.
                /// </summary>
                public unsafe Const_StaticOpsLhsG(MR.CS.CSharp.Const_StaticOpsLhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsG`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsG : Const_StaticOpsLhsG
            {
                internal unsafe StaticOpsLhsG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsG::StaticOpsLhsG`.
                /// </summary>
                public unsafe StaticOpsLhsG(MR.CS.CSharp.Const_StaticOpsLhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsG::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsG assign(MR.CS.CSharp.Const_StaticOpsLhsG _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsG_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsG._Underlying *__MR_CSharp_StaticOpsLhsG_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsG._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsLhsG_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(StaticOpsLhsG _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsG_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsG_int32_t(MR.CS.CSharp.StaticOpsLhsG._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsG_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsG`/`Const_StaticOpsLhsG` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsG
            {
                public StaticOpsLhsG? Opt;

                public _InOptMut_StaticOpsLhsG() {}
                public _InOptMut_StaticOpsLhsG(StaticOpsLhsG value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsG(StaticOpsLhsG value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsG`/`Const_StaticOpsLhsG` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsG
            {
                public Const_StaticOpsLhsG? Opt;

                public _InOptConst_StaticOpsLhsG() {}
                public _InOptConst_StaticOpsLhsG(Const_StaticOpsLhsG value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsG(Const_StaticOpsLhsG value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsH`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsLhsH : MR.CS.Misc.Object<Const_StaticOpsLhsH>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsLhsH_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsLhsH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsLhsH() {Dispose(false);}

                internal unsafe Const_StaticOpsLhsH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsLhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsH::StaticOpsLhsH`.
                /// </summary>
                public unsafe Const_StaticOpsLhsH(MR.CS.CSharp.Const_StaticOpsLhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.Const_StaticOpsLhsH _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsH_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsLhsH_int32_t(MR.CS.CSharp.Const_StaticOpsLhsH._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_StaticOpsLhsH_int32_t(_1._UnderlyingPtr, _2);
                }
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsLhsH`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsLhsH : Const_StaticOpsLhsH
            {
                internal unsafe StaticOpsLhsH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsLhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsLhsH::StaticOpsLhsH`.
                /// </summary>
                public unsafe StaticOpsLhsH(MR.CS.CSharp.Const_StaticOpsLhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsLhsH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsLhsH::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsLhsH assign(MR.CS.CSharp.Const_StaticOpsLhsH _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsLhsH_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsLhsH._Underlying *__MR_CSharp_StaticOpsLhsH_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsLhsH._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsLhsH_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsLhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsH`/`Const_StaticOpsLhsH` directly.
            /// </summary>
            public class _InOptMut_StaticOpsLhsH
            {
                public StaticOpsLhsH? Opt;

                public _InOptMut_StaticOpsLhsH() {}
                public _InOptMut_StaticOpsLhsH(StaticOpsLhsH value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsLhsH(StaticOpsLhsH value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsLhsH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsLhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsLhsH`/`Const_StaticOpsLhsH` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsLhsH
            {
                public Const_StaticOpsLhsH? Opt;

                public _InOptConst_StaticOpsLhsH() {}
                public _InOptConst_StaticOpsLhsH(Const_StaticOpsLhsH value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsLhsH(Const_StaticOpsLhsH value) {return new(value);}
            }

            // The operator is injected correctly.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsA : MR.CS.Misc.Object<Const_StaticOpsRhsA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsA_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsA() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                /// </summary>
                public unsafe Const_StaticOpsRhsA(MR.CS.CSharp.Const_StaticOpsRhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                /// </summary>
                public Const_StaticOpsRhsA(StaticOpsRhsA _other) : this((Const_StaticOpsRhsA)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, Const_StaticOpsRhsA _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsA", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsA(int _1, MR.CS.CSharp.StaticOpsRhsA._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsA(_1, _2._UnderlyingPtr);
                }
            }

            // The operator is injected correctly.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsA : Const_StaticOpsRhsA
            {
                internal unsafe StaticOpsRhsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                /// </summary>
                public unsafe StaticOpsRhsA(MR.CS.CSharp.Const_StaticOpsRhsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsA::StaticOpsRhsA`.
                /// </summary>
                public StaticOpsRhsA(StaticOpsRhsA _other) : this((Const_StaticOpsRhsA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsA assign(MR.CS.CSharp.Const_StaticOpsRhsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsA._Underlying *__MR_CSharp_StaticOpsRhsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsRhsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsA`/`Const_StaticOpsRhsA` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsA
            {
                public StaticOpsRhsA? Opt;

                public _InOptMut_StaticOpsRhsA() {}
                public _InOptMut_StaticOpsRhsA(StaticOpsRhsA value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsA(StaticOpsRhsA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsA`/`Const_StaticOpsRhsA` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsA
            {
                public Const_StaticOpsRhsA? Opt;

                public _InOptConst_StaticOpsRhsA() {}
                public _InOptConst_StaticOpsRhsA(Const_StaticOpsRhsA value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsA(Const_StaticOpsRhsA value) {return new(value);}
            }

            // The operator injects but becomes a function, because it returns void.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsB : MR.CS.Misc.Object<Const_StaticOpsRhsB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsB_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsB() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                /// </summary>
                public unsafe Const_StaticOpsRhsB(MR.CS.CSharp.Const_StaticOpsRhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                /// </summary>
                public Const_StaticOpsRhsB(StaticOpsRhsB _other) : this((Const_StaticOpsRhsB)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe void add(int _1, MR.CS.CSharp.Const_StaticOpsRhsB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsB", ExactSpelling = true)]
                    extern static void __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsB(int _1, MR.CS.CSharp.StaticOpsRhsB._Underlying *_2);
                    __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsB(_1, _2._UnderlyingPtr);
                }
            }

            // The operator injects but becomes a function, because it returns void.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsB : Const_StaticOpsRhsB
            {
                internal unsafe StaticOpsRhsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                /// </summary>
                public unsafe StaticOpsRhsB(MR.CS.CSharp.Const_StaticOpsRhsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsB::StaticOpsRhsB`.
                /// </summary>
                public StaticOpsRhsB(StaticOpsRhsB _other) : this((Const_StaticOpsRhsB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsB assign(MR.CS.CSharp.Const_StaticOpsRhsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsB._Underlying *__MR_CSharp_StaticOpsRhsB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsRhsB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsB`/`Const_StaticOpsRhsB` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsB
            {
                public StaticOpsRhsB? Opt;

                public _InOptMut_StaticOpsRhsB() {}
                public _InOptMut_StaticOpsRhsB(StaticOpsRhsB value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsB(StaticOpsRhsB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsB`/`Const_StaticOpsRhsB` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsB
            {
                public Const_StaticOpsRhsB? Opt;

                public _InOptConst_StaticOpsRhsB() {}
                public _InOptConst_StaticOpsRhsB(Const_StaticOpsRhsB value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsB(Const_StaticOpsRhsB value) {return new(value);}
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsC : MR.CS.Misc.Object<Const_StaticOpsRhsC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsC_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsC() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsC::StaticOpsRhsC`.
                /// </summary>
                public unsafe Const_StaticOpsRhsC(MR.CS.CSharp._ByValue_StaticOpsRhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            // The operator fails to inject because the class isn't copyable (and isn't trivially movable), and the operator takes it by value.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsC : Const_StaticOpsRhsC
            {
                internal unsafe StaticOpsRhsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsC::StaticOpsRhsC`.
                /// </summary>
                public unsafe StaticOpsRhsC(MR.CS.CSharp._ByValue_StaticOpsRhsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsC._Underlying *__MR_CSharp_StaticOpsRhsC_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsC_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `StaticOpsRhsC` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_StaticOpsRhsC
            {
                internal readonly Const_StaticOpsRhsC? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_StaticOpsRhsC() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_StaticOpsRhsC(MR.CS.Misc._Moved<StaticOpsRhsC> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_StaticOpsRhsC(MR.CS.Misc._Moved<StaticOpsRhsC> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsC`/`Const_StaticOpsRhsC` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsC
            {
                public StaticOpsRhsC? Opt;

                public _InOptMut_StaticOpsRhsC() {}
                public _InOptMut_StaticOpsRhsC(StaticOpsRhsC value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsC(StaticOpsRhsC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsC`/`Const_StaticOpsRhsC` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsC
            {
                public Const_StaticOpsRhsC? Opt;

                public _InOptConst_StaticOpsRhsC() {}
                public _InOptConst_StaticOpsRhsC(Const_StaticOpsRhsC value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsC(Const_StaticOpsRhsC value) {return new(value);}
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsD : MR.CS.Misc.Object<Const_StaticOpsRhsD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsD_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsD() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsD(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsD::StaticOpsRhsD`.
                /// </summary>
                public unsafe Const_StaticOpsRhsD(MR.CS.CSharp.Const_StaticOpsRhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, Const_StaticOpsRhsD _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsD", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsD(int _1, MR.CS.CSharp.StaticOpsRhsD._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsD(_1, _2._UnderlyingPtr);
                }
            }

            // The class is non-copyable, but is trivially movable, so the by-value operator injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsD : Const_StaticOpsRhsD
            {
                internal unsafe StaticOpsRhsD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsD::StaticOpsRhsD`.
                /// </summary>
                public unsafe StaticOpsRhsD(MR.CS.CSharp.Const_StaticOpsRhsD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsD._Underlying *__MR_CSharp_StaticOpsRhsD_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsD`/`Const_StaticOpsRhsD` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsD
            {
                public StaticOpsRhsD? Opt;

                public _InOptMut_StaticOpsRhsD() {}
                public _InOptMut_StaticOpsRhsD(StaticOpsRhsD value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsD(StaticOpsRhsD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsD`/`Const_StaticOpsRhsD` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsD
            {
                public Const_StaticOpsRhsD? Opt;

                public _InOptConst_StaticOpsRhsD() {}
                public _InOptConst_StaticOpsRhsD(Const_StaticOpsRhsD value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsD(Const_StaticOpsRhsD value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsE : MR.CS.Misc.Object<Const_StaticOpsRhsE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsE_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsE() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsE(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsE::StaticOpsRhsE`.
                /// </summary>
                public unsafe Const_StaticOpsRhsE(MR.CS.CSharp.Const_StaticOpsRhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            // The class isn't copyable, but the operator takes it by reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsE : Const_StaticOpsRhsE
            {
                internal unsafe StaticOpsRhsE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsE::StaticOpsRhsE`.
                /// </summary>
                public unsafe StaticOpsRhsE(MR.CS.CSharp.Const_StaticOpsRhsE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsE assign(MR.CS.CSharp.Const_StaticOpsRhsE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsE._Underlying *__MR_CSharp_StaticOpsRhsE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsE._Underlying *_other);
                    MR.CS.CSharp.StaticOpsRhsE __ret;
                    __ret = new(__MR_CSharp_StaticOpsRhsE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    __ret._KeepAlive(this);
                    return __ret;
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, MR.CS.CSharp.StaticOpsRhsE _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsE", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsE(int _1, MR.CS.CSharp.StaticOpsRhsE._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsE(_1, _2._UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsE`/`Const_StaticOpsRhsE` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsE
            {
                public StaticOpsRhsE? Opt;

                public _InOptMut_StaticOpsRhsE() {}
                public _InOptMut_StaticOpsRhsE(StaticOpsRhsE value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsE(StaticOpsRhsE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsE`/`Const_StaticOpsRhsE` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsE
            {
                public Const_StaticOpsRhsE? Opt;

                public _InOptConst_StaticOpsRhsE() {}
                public _InOptConst_StaticOpsRhsE(Const_StaticOpsRhsE value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsE(Const_StaticOpsRhsE value) {return new(value);}
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsF`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsF : MR.CS.Misc.Object<Const_StaticOpsRhsF>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsF_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsF() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsF(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsF::StaticOpsRhsF`.
                /// </summary>
                public unsafe Const_StaticOpsRhsF(MR.CS.CSharp.Const_StaticOpsRhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, MR.CS.CSharp.Const_StaticOpsRhsF _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsF", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsF(int _1, MR.CS.CSharp.Const_StaticOpsRhsF._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsF(_1, _2._UnderlyingPtr);
                }
            }

            // The class isn't copyable, but the operator takes it by const reference, so it injects fine.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsF`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsF : Const_StaticOpsRhsF
            {
                internal unsafe StaticOpsRhsF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsF::StaticOpsRhsF`.
                /// </summary>
                public unsafe StaticOpsRhsF(MR.CS.CSharp.Const_StaticOpsRhsF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsF::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsF assign(MR.CS.CSharp.Const_StaticOpsRhsF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsF._Underlying *__MR_CSharp_StaticOpsRhsF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsF._Underlying *_other);
                    MR.CS.CSharp.StaticOpsRhsF __ret;
                    __ret = new(__MR_CSharp_StaticOpsRhsF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsF`/`Const_StaticOpsRhsF` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsF
            {
                public StaticOpsRhsF? Opt;

                public _InOptMut_StaticOpsRhsF() {}
                public _InOptMut_StaticOpsRhsF(StaticOpsRhsF value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsF(StaticOpsRhsF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsF`/`Const_StaticOpsRhsF` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsF
            {
                public Const_StaticOpsRhsF? Opt;

                public _InOptConst_StaticOpsRhsF() {}
                public _InOptConst_StaticOpsRhsF(Const_StaticOpsRhsF value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsF(Const_StaticOpsRhsF value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsG`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsG : MR.CS.Misc.Object<Const_StaticOpsRhsG>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsG_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsG() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsG(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsG::StaticOpsRhsG`.
                /// </summary>
                public unsafe Const_StaticOpsRhsG(MR.CS.CSharp.Const_StaticOpsRhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }
            }

            // The copy ctor uses a non-const reference, so an operator with a by-value parameter gets injected into the non-const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsG`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsG : Const_StaticOpsRhsG
            {
                internal unsafe StaticOpsRhsG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsG::StaticOpsRhsG`.
                /// </summary>
                public unsafe StaticOpsRhsG(MR.CS.CSharp.Const_StaticOpsRhsG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsG_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsG::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsG assign(MR.CS.CSharp.Const_StaticOpsRhsG _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsG_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsG._Underlying *__MR_CSharp_StaticOpsRhsG_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsG._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsRhsG_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, StaticOpsRhsG _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsG", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsG(int _1, MR.CS.CSharp.StaticOpsRhsG._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsG(_1, _2._UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsG`/`Const_StaticOpsRhsG` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsG
            {
                public StaticOpsRhsG? Opt;

                public _InOptMut_StaticOpsRhsG() {}
                public _InOptMut_StaticOpsRhsG(StaticOpsRhsG value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsG(StaticOpsRhsG value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsG`/`Const_StaticOpsRhsG` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsG
            {
                public Const_StaticOpsRhsG? Opt;

                public _InOptConst_StaticOpsRhsG() {}
                public _InOptConst_StaticOpsRhsG(Const_StaticOpsRhsG value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsG(Const_StaticOpsRhsG value) {return new(value);}
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsH`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsRhsH : MR.CS.Misc.Object<Const_StaticOpsRhsH>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsRhsH_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsRhsH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsRhsH() {Dispose(false);}

                internal unsafe Const_StaticOpsRhsH(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsRhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsH::StaticOpsRhsH`.
                /// </summary>
                public unsafe Const_StaticOpsRhsH(MR.CS.CSharp.Const_StaticOpsRhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, MR.CS.CSharp.Const_StaticOpsRhsH _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsH", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsH(int _1, MR.CS.CSharp.Const_StaticOpsRhsH._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsH(_1, _2._UnderlyingPtr);
                }
            }

            // The copy ctor uses a non-const reference, but it doesn't matter because the operator takes the parameter by const reference,
            //   so the operator gets injected into the const half.
            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsRhsH`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsRhsH : Const_StaticOpsRhsH
            {
                internal unsafe StaticOpsRhsH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsRhsH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsRhsH::StaticOpsRhsH`.
                /// </summary>
                public unsafe StaticOpsRhsH(MR.CS.CSharp.Const_StaticOpsRhsH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_ConstructFromAnother(MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsRhsH_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsRhsH::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsRhsH assign(MR.CS.CSharp.Const_StaticOpsRhsH _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsRhsH_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsRhsH._Underlying *__MR_CSharp_StaticOpsRhsH_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsRhsH._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsRhsH_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsRhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsH`/`Const_StaticOpsRhsH` directly.
            /// </summary>
            public class _InOptMut_StaticOpsRhsH
            {
                public StaticOpsRhsH? Opt;

                public _InOptMut_StaticOpsRhsH() {}
                public _InOptMut_StaticOpsRhsH(StaticOpsRhsH value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsRhsH(StaticOpsRhsH value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsRhsH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsRhsH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsRhsH`/`Const_StaticOpsRhsH` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsRhsH
            {
                public Const_StaticOpsRhsH? Opt;

                public _InOptConst_StaticOpsRhsH() {}
                public _InOptConst_StaticOpsRhsH(Const_StaticOpsRhsH value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsRhsH(Const_StaticOpsRhsH value) {return new(value);}
            }

            // Other injection cases:
            public enum StaticOpsEnum : int
            {
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsMixedLhs`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsMixedLhs : MR.CS.Misc.Object<Const_StaticOpsMixedLhs>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsMixedLhs_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsMixedLhs_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsMixedLhs() {Dispose(false);}

                internal unsafe Const_StaticOpsMixedLhs(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsMixedLhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                /// </summary>
                public unsafe Const_StaticOpsMixedLhs(MR.CS.CSharp.Const_StaticOpsMixedLhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                /// </summary>
                public Const_StaticOpsMixedLhs(StaticOpsMixedLhs _other) : this((Const_StaticOpsMixedLhs)_other) {}

                // Gets injected into the lhs by default.
                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(Const_StaticOpsMixedLhs _1, MR.CS.CSharp.Const_StaticOpsMixedRhs _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_1, MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_2);
                    return __MR_C_add_MR_CSharp_StaticOpsMixedLhs_MR_CSharp_StaticOpsMixedRhs(_1._UnderlyingPtr, _2._UnderlyingPtr);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsMixedLhs`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsMixedLhs : Const_StaticOpsMixedLhs
            {
                internal unsafe StaticOpsMixedLhs(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsMixedLhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                /// </summary>
                public unsafe StaticOpsMixedLhs(MR.CS.CSharp.Const_StaticOpsMixedLhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedLhs_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedLhs::StaticOpsMixedLhs`.
                /// </summary>
                public StaticOpsMixedLhs(StaticOpsMixedLhs _other) : this((Const_StaticOpsMixedLhs)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsMixedLhs::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsMixedLhs assign(MR.CS.CSharp.Const_StaticOpsMixedLhs _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedLhs_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedLhs._Underlying *__MR_CSharp_StaticOpsMixedLhs_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsMixedLhs._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsMixedLhs_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsMixedLhs` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsMixedLhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedLhs`/`Const_StaticOpsMixedLhs` directly.
            /// </summary>
            public class _InOptMut_StaticOpsMixedLhs
            {
                public StaticOpsMixedLhs? Opt;

                public _InOptMut_StaticOpsMixedLhs() {}
                public _InOptMut_StaticOpsMixedLhs(StaticOpsMixedLhs value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsMixedLhs(StaticOpsMixedLhs value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsMixedLhs` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsMixedLhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedLhs`/`Const_StaticOpsMixedLhs` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsMixedLhs
            {
                public Const_StaticOpsMixedLhs? Opt;

                public _InOptConst_StaticOpsMixedLhs() {}
                public _InOptConst_StaticOpsMixedLhs(Const_StaticOpsMixedLhs value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsMixedLhs(Const_StaticOpsMixedLhs value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsMixedRhs`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StaticOpsMixedRhs : MR.CS.Misc.Object<Const_StaticOpsMixedRhs>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StaticOpsMixedRhs_Destroy(_Underlying *_this);
                    __MR_CSharp_StaticOpsMixedRhs_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StaticOpsMixedRhs() {Dispose(false);}

                internal unsafe Const_StaticOpsMixedRhs(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StaticOpsMixedRhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                /// </summary>
                public unsafe Const_StaticOpsMixedRhs(MR.CS.CSharp.Const_StaticOpsMixedRhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                /// </summary>
                public Const_StaticOpsMixedRhs(StaticOpsMixedRhs _other) : this((Const_StaticOpsMixedRhs)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StaticOpsMixedRhs`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StaticOpsMixedRhs : Const_StaticOpsMixedRhs
            {
                internal unsafe StaticOpsMixedRhs(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StaticOpsMixedRhs() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                /// </summary>
                public unsafe StaticOpsMixedRhs(MR.CS.CSharp.Const_StaticOpsMixedRhs _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StaticOpsMixedRhs_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StaticOpsMixedRhs::StaticOpsMixedRhs`.
                /// </summary>
                public StaticOpsMixedRhs(StaticOpsMixedRhs _other) : this((Const_StaticOpsMixedRhs)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StaticOpsMixedRhs::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StaticOpsMixedRhs assign(MR.CS.CSharp.Const_StaticOpsMixedRhs _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StaticOpsMixedRhs_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StaticOpsMixedRhs._Underlying *__MR_CSharp_StaticOpsMixedRhs_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StaticOpsMixedRhs._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StaticOpsMixedRhs_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsMixedRhs` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StaticOpsMixedRhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedRhs`/`Const_StaticOpsMixedRhs` directly.
            /// </summary>
            public class _InOptMut_StaticOpsMixedRhs
            {
                public StaticOpsMixedRhs? Opt;

                public _InOptMut_StaticOpsMixedRhs() {}
                public _InOptMut_StaticOpsMixedRhs(StaticOpsMixedRhs value) {Opt = value;}
                public static implicit operator _InOptMut_StaticOpsMixedRhs(StaticOpsMixedRhs value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StaticOpsMixedRhs` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StaticOpsMixedRhs`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StaticOpsMixedRhs`/`Const_StaticOpsMixedRhs` to pass it to the function.
            /// </summary>
            public class _InOptConst_StaticOpsMixedRhs
            {
                public Const_StaticOpsMixedRhs? Opt;

                public _InOptConst_StaticOpsMixedRhs() {}
                public _InOptConst_StaticOpsMixedRhs(Const_StaticOpsMixedRhs value) {Opt = value;}
                public static implicit operator _InOptConst_StaticOpsMixedRhs(Const_StaticOpsMixedRhs value) {return new(value);}
            }

            // Check how non-trivial class types are passed by value into operators.
            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivialClassOps`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_NonTrivialClassOps : MR.CS.Misc.Object<Const_NonTrivialClassOps>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonTrivialClassOps_Destroy(_Underlying *_this);
                    __MR_CSharp_NonTrivialClassOps_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonTrivialClassOps() {Dispose(false);}

                internal unsafe Const_NonTrivialClassOps(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_NonTrivialClassOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public unsafe Const_NonTrivialClassOps(MR.CS.CSharp._ByValue_NonTrivialClassOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public Const_NonTrivialClassOps(Const_NonTrivialClassOps _other) : this(new _ByValue_NonTrivialClassOps(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public Const_NonTrivialClassOps(NonTrivialClassOps _other) : this((Const_NonTrivialClassOps)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(Const_NonTrivialClassOps _1, float _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonTrivialClassOps_float", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonTrivialClassOps_float(MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_1, float _2);
                    return __MR_C_add_MR_CSharp_NonTrivialClassOps_float(MR.CS.Misc._PassBy.copy, _1._UnderlyingPtr, _2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(float _1, Const_NonTrivialClassOps _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_float_MR_CSharp_NonTrivialClassOps", ExactSpelling = true)]
                    extern static int __MR_C_add_float_MR_CSharp_NonTrivialClassOps(float _1, MR.CS.Misc._PassBy _2_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_2);
                    return __MR_C_add_float_MR_CSharp_NonTrivialClassOps(_1, MR.CS.Misc._PassBy.copy, _2._UnderlyingPtr);
                }
            }

            // Check how non-trivial class types are passed by value into operators.
            /// <summary>
            /// Generated from class `MR::CSharp::NonTrivialClassOps`.
            /// This is the non-const half of the class.
            /// </summary>
            public class NonTrivialClassOps : Const_NonTrivialClassOps
            {
                internal unsafe NonTrivialClassOps(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe NonTrivialClassOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public unsafe NonTrivialClassOps(MR.CS.CSharp._ByValue_NonTrivialClassOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonTrivialClassOps_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public NonTrivialClassOps(Const_NonTrivialClassOps _other) : this(new _ByValue_NonTrivialClassOps(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonTrivialClassOps::NonTrivialClassOps`.
                /// </summary>
                public NonTrivialClassOps(NonTrivialClassOps _other) : this((Const_NonTrivialClassOps)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::NonTrivialClassOps::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.NonTrivialClassOps assign(MR.CS.CSharp._ByValue_NonTrivialClassOps _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonTrivialClassOps_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonTrivialClassOps._Underlying *__MR_CSharp_NonTrivialClassOps_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.NonTrivialClassOps._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_NonTrivialClassOps_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::NonTrivialClassOps::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.NonTrivialClassOps _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonTrivialClassOps_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonTrivialClassOps_int32_t(MR.CS.CSharp.NonTrivialClassOps._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_NonTrivialClassOps_int32_t(_this._UnderlyingPtr, _1);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `NonTrivialClassOps` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_NonTrivialClassOps
            {
                internal readonly Const_NonTrivialClassOps? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_NonTrivialClassOps() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_NonTrivialClassOps(Const_NonTrivialClassOps new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_NonTrivialClassOps(Const_NonTrivialClassOps arg) {return new(arg);}
                public _ByValue_NonTrivialClassOps(MR.CS.Misc._Moved<NonTrivialClassOps> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_NonTrivialClassOps(MR.CS.Misc._Moved<NonTrivialClassOps> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivialClassOps` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonTrivialClassOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` directly.
            /// </summary>
            public class _InOptMut_NonTrivialClassOps
            {
                public NonTrivialClassOps? Opt;

                public _InOptMut_NonTrivialClassOps() {}
                public _InOptMut_NonTrivialClassOps(NonTrivialClassOps value) {Opt = value;}
                public static implicit operator _InOptMut_NonTrivialClassOps(NonTrivialClassOps value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonTrivialClassOps` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonTrivialClassOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonTrivialClassOps`/`Const_NonTrivialClassOps` to pass it to the function.
            /// </summary>
            public class _InOptConst_NonTrivialClassOps
            {
                public Const_NonTrivialClassOps? Opt;

                public _InOptConst_NonTrivialClassOps() {}
                public _InOptConst_NonTrivialClassOps(Const_NonTrivialClassOps value) {Opt = value;}
                public static implicit operator _InOptConst_NonTrivialClassOps(Const_NonTrivialClassOps value) {return new(value);}
            }

            // The class is non-copyable, so operators with by-value parameters fail to inject.
            /// <summary>
            /// Generated from class `MR::CSharp::NonCopyableClassByValueOps`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_NonCopyableClassByValueOps : MR.CS.Misc.Object<Const_NonCopyableClassByValueOps>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NonCopyableClassByValueOps_Destroy(_Underlying *_this);
                    __MR_CSharp_NonCopyableClassByValueOps_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NonCopyableClassByValueOps() {Dispose(false);}

                internal unsafe Const_NonCopyableClassByValueOps(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_NonCopyableClassByValueOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonCopyableClassByValueOps::NonCopyableClassByValueOps`.
                /// </summary>
                public unsafe Const_NonCopyableClassByValueOps(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(Const_NonCopyableClassByValueOps _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int32_t(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_1, int _2);
                    return __MR_C_add_MR_CSharp_NonCopyableClassByValueOps_int32_t(_1._UnderlyingPtr, _2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator+`.
                /// </summary>
                public static unsafe int operator+(int _1, Const_NonCopyableClassByValueOps _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_NonCopyableClassByValueOps", ExactSpelling = true)]
                    extern static int __MR_C_add_int32_t_MR_CSharp_NonCopyableClassByValueOps(int _1, MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_2);
                    return __MR_C_add_int32_t_MR_CSharp_NonCopyableClassByValueOps(_1, _2._UnderlyingPtr);
                }
            }

            // The class is non-copyable, so operators with by-value parameters fail to inject.
            /// <summary>
            /// Generated from class `MR::CSharp::NonCopyableClassByValueOps`.
            /// This is the non-const half of the class.
            /// </summary>
            public class NonCopyableClassByValueOps : Const_NonCopyableClassByValueOps
            {
                internal unsafe NonCopyableClassByValueOps(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe NonCopyableClassByValueOps() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NonCopyableClassByValueOps::NonCopyableClassByValueOps`.
                /// </summary>
                public unsafe NonCopyableClassByValueOps(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NonCopyableClassByValueOps_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::NonCopyableClassByValueOps::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.NonCopyableClassByValueOps assign(MR.CS.CSharp.Const_NonCopyableClassByValueOps _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *__MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NonCopyableClassByValueOps._Underlying *_other);
                    MR.CS.CSharp.NonCopyableClassByValueOps __ret;
                    __ret = new(__MR_CSharp_NonCopyableClassByValueOps_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `NonCopyableClassByValueOps` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NonCopyableClassByValueOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonCopyableClassByValueOps`/`Const_NonCopyableClassByValueOps` directly.
            /// </summary>
            public class _InOptMut_NonCopyableClassByValueOps
            {
                public NonCopyableClassByValueOps? Opt;

                public _InOptMut_NonCopyableClassByValueOps() {}
                public _InOptMut_NonCopyableClassByValueOps(NonCopyableClassByValueOps value) {Opt = value;}
                public static implicit operator _InOptMut_NonCopyableClassByValueOps(NonCopyableClassByValueOps value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NonCopyableClassByValueOps` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NonCopyableClassByValueOps`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NonCopyableClassByValueOps`/`Const_NonCopyableClassByValueOps` to pass it to the function.
            /// </summary>
            public class _InOptConst_NonCopyableClassByValueOps
            {
                public Const_NonCopyableClassByValueOps? Opt;

                public _InOptConst_NonCopyableClassByValueOps() {}
                public _InOptConst_NonCopyableClassByValueOps(Const_NonCopyableClassByValueOps value) {Opt = value;}
                public static implicit operator _InOptConst_NonCopyableClassByValueOps(Const_NonCopyableClassByValueOps value) {return new(value);}
            }

            // Test the call operator, since it can have an unusual amount of arguments.
            // Not testing `[]` here to be able to run the tests on older C++.
            /// <summary>
            /// Generated from class `MR::CSharp::CallOp`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_CallOp : MR.CS.Misc.Object<Const_CallOp>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_CallOp_Destroy(_Underlying *_this);
                    __MR_CSharp_CallOp_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_CallOp() {Dispose(false);}

                internal unsafe Const_CallOp(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_CallOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_CallOp_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                /// </summary>
                public unsafe Const_CallOp(MR.CS.CSharp.Const_CallOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_ConstructFromAnother(MR.CS.CSharp.CallOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_CallOp_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                /// </summary>
                public Const_CallOp(CallOp _other) : this((Const_CallOp)_other) {}
            }

            // Test the call operator, since it can have an unusual amount of arguments.
            // Not testing `[]` here to be able to run the tests on older C++.
            /// <summary>
            /// Generated from class `MR::CSharp::CallOp`.
            /// This is the non-const half of the class.
            /// </summary>
            public class CallOp : Const_CallOp
            {
                internal unsafe CallOp(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe CallOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_CallOp_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                /// </summary>
                public unsafe CallOp(MR.CS.CSharp.Const_CallOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_ConstructFromAnother(MR.CS.CSharp.CallOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_CallOp_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::CallOp::CallOp`.
                /// </summary>
                public CallOp(CallOp _other) : this((Const_CallOp)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::CallOp::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.CallOp assign(MR.CS.CSharp.Const_CallOp _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.CallOp._Underlying *__MR_CSharp_CallOp_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.CallOp._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_CallOp_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::CallOp::operator()`.
                /// </summary>
                public unsafe void call()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_call_0", ExactSpelling = true)]
                    extern static void __MR_CSharp_CallOp_call_0(_Underlying *_this);
                    __MR_CSharp_CallOp_call_0(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::CallOp::operator()`.
                /// </summary>
                public unsafe int call(int _1, int _2, int _3)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_CallOp_call_3", ExactSpelling = true)]
                    extern static int __MR_CSharp_CallOp_call_3(_Underlying *_this, int _1, int _2, int _3);
                    return __MR_CSharp_CallOp_call_3(_UnderlyingPtr, _1, _2, _3);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `CallOp` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_CallOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `CallOp`/`Const_CallOp` directly.
            /// </summary>
            public class _InOptMut_CallOp
            {
                public CallOp? Opt;

                public _InOptMut_CallOp() {}
                public _InOptMut_CallOp(CallOp value) {Opt = value;}
                public static implicit operator _InOptMut_CallOp(CallOp value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `CallOp` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_CallOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `CallOp`/`Const_CallOp` to pass it to the function.
            /// </summary>
            public class _InOptConst_CallOp
            {
                public Const_CallOp? Opt;

                public _InOptConst_CallOp() {}
                public _InOptConst_CallOp(Const_CallOp value) {Opt = value;}
                public static implicit operator _InOptConst_CallOp(Const_CallOp value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TestOpsA : MR.CS.Misc.Object<Const_TestOpsA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsA_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsA() {Dispose(false);}

                internal unsafe Const_TestOpsA(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                /// </summary>
                public unsafe Const_TestOpsA(MR.CS.CSharp.Const_TestOpsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsA._Underlying *__MR_CSharp_TestOpsA_ConstructFromAnother(MR.CS.CSharp.TestOpsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                /// </summary>
                public Const_TestOpsA(TestOpsA _other) : this((Const_TestOpsA)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TestOpsA : Const_TestOpsA
            {
                internal unsafe TestOpsA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                /// </summary>
                public unsafe TestOpsA(MR.CS.CSharp.Const_TestOpsA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsA._Underlying *__MR_CSharp_TestOpsA_ConstructFromAnother(MR.CS.CSharp.TestOpsA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsA::TestOpsA`.
                /// </summary>
                public TestOpsA(TestOpsA _other) : this((Const_TestOpsA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator=`.
                /// </summary>
                public unsafe int assign(MR.CS.CSharp.Const_TestOpsA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_AssignFromAnother", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return __MR_CSharp_TestOpsA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_add_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_neg_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_sub_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_sub_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator*`.
                /// </summary>
                public unsafe int deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_deref_MR_CSharp_TestOpsA(_Underlying *_this);
                    return __MR_C_deref_MR_CSharp_TestOpsA(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator*`.
                /// </summary>
                public static unsafe int operator*(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_mul_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator/`.
                /// </summary>
                public static unsafe int operator/(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_div_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator%`.
                /// </summary>
                public static unsafe int operator%(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_mod_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_mod_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator^`.
                /// </summary>
                public static unsafe int operator^(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_xor_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_xor_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator&`.
                /// </summary>
                public unsafe int addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_addressof_MR_CSharp_TestOpsA(_Underlying *_this);
                    return __MR_C_addressof_MR_CSharp_TestOpsA(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator&`.
                /// </summary>
                public static unsafe int operator&(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_bitand_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_bitand_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator|`.
                /// </summary>
                public static unsafe int operator|(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_bitor_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_bitor_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator~`.
                /// </summary>
                public static unsafe int operator~(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_compl_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_compl_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator!`.
                /// </summary>
                public static unsafe int operator!(MR.CS.CSharp.TestOpsA _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_not_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this);
                    return __MR_C_not_MR_CSharp_TestOpsA(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator+=`.
                /// </summary>
                public unsafe int addAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_add_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_add_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_add_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator-=`.
                /// </summary>
                public unsafe int subAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_sub_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_sub_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_sub_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator*=`.
                /// </summary>
                public unsafe int mulAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_mul_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_mul_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_mul_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator/=`.
                /// </summary>
                public unsafe int divAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_div_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_div_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_div_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator%=`.
                /// </summary>
                public unsafe int modAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_mod_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_mod_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_mod_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator^=`.
                /// </summary>
                public unsafe int xorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_xor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_xor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_xor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator&=`.
                /// </summary>
                public unsafe int bitandAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_bitand_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_bitand_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_bitand_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator|=`.
                /// </summary>
                public unsafe int bitorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_bitor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_bitor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_bitor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator<<`.
                /// </summary>
                public static unsafe int operator<<(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_lshift_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_lshift_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator>>`.
                /// </summary>
                public static unsafe int operator>>(MR.CS.CSharp.TestOpsA _this, MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_rshift_MR_CSharp_TestOpsA(MR.CS.CSharp.TestOpsA._Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_rshift_MR_CSharp_TestOpsA(_this._UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator<<=`.
                /// </summary>
                public unsafe int lshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_lshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_lshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_lshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator>>=`.
                /// </summary>
                public unsafe int rshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_rshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_rshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_rshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator<=>`.
                /// </summary>
                public unsafe int compareThreeWay(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_compare_three_way_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_compare_three_way_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator&&`.
                /// </summary>
                public unsafe int and(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_and_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_and_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator||`.
                /// </summary>
                public unsafe int or(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_or_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_or_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator,`.
                /// </summary>
                public unsafe int comma(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static int __MR_C_comma_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_C_comma_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator->*`.
                /// </summary>
                public unsafe int arrowStar(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_arrow_star", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_arrow_star(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_arrow_star(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator->`.
                /// </summary>
                public unsafe int arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_arrow", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_arrow(_Underlying *_this);
                    return __MR_CSharp_TestOpsA_arrow(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator()`.
                /// </summary>
                public unsafe int call(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_call", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsA_call(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    return __MR_CSharp_TestOpsA_call(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsA::operator[]`.
                /// </summary>
                public unsafe int this[MR.CS.CSharp.Const_TestOpsA _1]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsA_index", ExactSpelling = true)]
                        extern static int __MR_CSharp_TestOpsA_index(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                        return __MR_CSharp_TestOpsA_index(_UnderlyingPtr, _1._UnderlyingPtr);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsA`/`Const_TestOpsA` directly.
            /// </summary>
            public class _InOptMut_TestOpsA
            {
                public TestOpsA? Opt;

                public _InOptMut_TestOpsA() {}
                public _InOptMut_TestOpsA(TestOpsA value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsA(TestOpsA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsA`/`Const_TestOpsA` to pass it to the function.
            /// </summary>
            public class _InOptConst_TestOpsA
            {
                public Const_TestOpsA? Opt;

                public _InOptConst_TestOpsA() {}
                public _InOptConst_TestOpsA(Const_TestOpsA value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsA(Const_TestOpsA value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TestOpsB : MR.CS.Misc.Object<Const_TestOpsB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsB_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsB() {Dispose(false);}

                internal unsafe Const_TestOpsB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public unsafe Const_TestOpsB(MR.CS.CSharp._ByValue_TestOpsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsB._Underlying *__MR_CSharp_TestOpsB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public Const_TestOpsB(Const_TestOpsB _other) : this(new _ByValue_TestOpsB(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public Const_TestOpsB(TestOpsB _other) : this((Const_TestOpsB)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TestOpsB : Const_TestOpsB
            {
                internal unsafe TestOpsB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public unsafe TestOpsB(MR.CS.CSharp._ByValue_TestOpsB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsB._Underlying *__MR_CSharp_TestOpsB_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsB_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public TestOpsB(Const_TestOpsB _other) : this(new _ByValue_TestOpsB(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsB::TestOpsB`.
                /// </summary>
                public TestOpsB(TestOpsB _other) : this((Const_TestOpsB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator=`.
                /// </summary>
                public unsafe int assign(MR.CS.CSharp._ByValue_TestOpsB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_AssignFromAnother", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return __MR_CSharp_TestOpsB_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_add_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_neg_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_sub_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_sub_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator*`.
                /// </summary>
                public unsafe int deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_deref_MR_CSharp_TestOpsB(_Underlying *_this);
                    return __MR_C_deref_MR_CSharp_TestOpsB(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator*`.
                /// </summary>
                public static unsafe int operator*(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_mul_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator/`.
                /// </summary>
                public static unsafe int operator/(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_div_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator%`.
                /// </summary>
                public static unsafe int operator%(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_mod_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_mod_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator^`.
                /// </summary>
                public static unsafe int operator^(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_xor_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_xor_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator&`.
                /// </summary>
                public unsafe int addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_addressof_MR_CSharp_TestOpsB(_Underlying *_this);
                    return __MR_C_addressof_MR_CSharp_TestOpsB(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator&`.
                /// </summary>
                public static unsafe int operator&(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_bitand_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_bitand_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator|`.
                /// </summary>
                public static unsafe int operator|(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_bitor_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_bitor_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator~`.
                /// </summary>
                public static unsafe int operator~(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_compl_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_compl_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator!`.
                /// </summary>
                public static unsafe int operator!(MR.CS.CSharp.TestOpsB _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_not_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this);
                    return __MR_C_not_MR_CSharp_TestOpsB(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator+=`.
                /// </summary>
                public unsafe int addAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_add_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_add_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_add_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator-=`.
                /// </summary>
                public unsafe int subAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_sub_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_sub_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_sub_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator*=`.
                /// </summary>
                public unsafe int mulAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_mul_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_mul_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_mul_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator/=`.
                /// </summary>
                public unsafe int divAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_div_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_div_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_div_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator%=`.
                /// </summary>
                public unsafe int modAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_mod_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_mod_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_mod_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator^=`.
                /// </summary>
                public unsafe int xorAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_xor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_xor_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_xor_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator&=`.
                /// </summary>
                public unsafe int bitandAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_bitand_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_bitand_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_bitand_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator|=`.
                /// </summary>
                public unsafe int bitorAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_bitor_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_bitor_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_bitor_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator<<`.
                /// </summary>
                public static unsafe int operator<<(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_lshift_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_lshift_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator>>`.
                /// </summary>
                public static unsafe int operator>>(MR.CS.CSharp.TestOpsB _this, MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_rshift_MR_CSharp_TestOpsB(MR.CS.CSharp.TestOpsB._Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_rshift_MR_CSharp_TestOpsB(_this._UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator<<=`.
                /// </summary>
                public unsafe int lshiftAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_lshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_lshift_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_lshift_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator>>=`.
                /// </summary>
                public unsafe int rshiftAssign(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_rshift_assign", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_rshift_assign(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_rshift_assign(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator<=>`.
                /// </summary>
                public unsafe int compareThreeWay(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_compare_three_way_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_compare_three_way_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator&&`.
                /// </summary>
                public unsafe int and(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_and_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_and_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator||`.
                /// </summary>
                public unsafe int or(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_or_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_or_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator,`.
                /// </summary>
                public unsafe int comma(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsB", ExactSpelling = true)]
                    extern static int __MR_C_comma_MR_CSharp_TestOpsB(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_C_comma_MR_CSharp_TestOpsB(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator->*`.
                /// </summary>
                public unsafe int arrowStar(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_arrow_star", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_arrow_star(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_arrow_star(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator->`.
                /// </summary>
                public unsafe int arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_arrow", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_arrow(_Underlying *_this);
                    return __MR_CSharp_TestOpsB_arrow(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator()`.
                /// </summary>
                public unsafe int call(MR.CS.CSharp._ByValue_TestOpsB _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_call", ExactSpelling = true)]
                    extern static int __MR_CSharp_TestOpsB_call(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                    return __MR_CSharp_TestOpsB_call(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsB::operator[]`.
                /// </summary>
                public unsafe int this[MR.CS.CSharp._ByValue_TestOpsB _1]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsB_index", ExactSpelling = true)]
                        extern static int __MR_CSharp_TestOpsB_index(_Underlying *_this, MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.TestOpsB._Underlying *_1);
                        return __MR_CSharp_TestOpsB_index(_UnderlyingPtr, _1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null);
                    }
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `TestOpsB` by value.
            /// Usage:
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` to copy it into the function.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_TestOpsB
            {
                internal readonly Const_TestOpsB? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_TestOpsB(Const_TestOpsB new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_TestOpsB(Const_TestOpsB arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` directly.
            /// </summary>
            public class _InOptMut_TestOpsB
            {
                public TestOpsB? Opt;

                public _InOptMut_TestOpsB() {}
                public _InOptMut_TestOpsB(TestOpsB value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsB(TestOpsB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsB`/`Const_TestOpsB` to pass it to the function.
            /// </summary>
            public class _InOptConst_TestOpsB
            {
                public Const_TestOpsB? Opt;

                public _InOptConst_TestOpsB() {}
                public _InOptConst_TestOpsB(Const_TestOpsB value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsB(Const_TestOpsB value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_TestOpsC : MR.CS.Misc.Object<Const_TestOpsC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_Destroy(_Underlying *_this);
                    __MR_CSharp_TestOpsC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_TestOpsC() {Dispose(false);}

                internal unsafe Const_TestOpsC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                /// </summary>
                public unsafe Const_TestOpsC(MR.CS.CSharp.Const_TestOpsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_ConstructFromAnother(MR.CS.CSharp.TestOpsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                /// </summary>
                public Const_TestOpsC(TestOpsC _other) : this((Const_TestOpsC)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::TestOpsC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class TestOpsC : Const_TestOpsC
            {
                internal unsafe TestOpsC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                /// </summary>
                public unsafe TestOpsC(MR.CS.CSharp.Const_TestOpsC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_ConstructFromAnother(MR.CS.CSharp.TestOpsC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_TestOpsC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::TestOpsC::TestOpsC`.
                /// </summary>
                public TestOpsC(TestOpsC _other) : this((Const_TestOpsC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.TestOpsC assign(MR.CS.CSharp.Const_TestOpsC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.TestOpsC._Underlying *__MR_CSharp_TestOpsC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.TestOpsC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_TestOpsC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator+`.
                /// </summary>
                public unsafe void add()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_pos_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_pos_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator+`.
                /// </summary>
                public unsafe void add(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_add_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator-`.
                /// </summary>
                public unsafe void sub()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_neg_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_neg_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator-`.
                /// </summary>
                public unsafe void sub(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_sub_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator*`.
                /// </summary>
                public unsafe void deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_deref_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_deref_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator*`.
                /// </summary>
                public unsafe void mul(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_mul_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator/`.
                /// </summary>
                public unsafe void div(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_div_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator%`.
                /// </summary>
                public unsafe void mod(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_mod_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator^`.
                /// </summary>
                public unsafe void xor(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_xor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator&`.
                /// </summary>
                public unsafe void addressOf()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_addressof_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_addressof_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_addressof_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator&`.
                /// </summary>
                public unsafe void bitand(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_bitand_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator|`.
                /// </summary>
                public unsafe void bitor(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_bitor_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator~`.
                /// </summary>
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_compl_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator!`.
                /// </summary>
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_TestOpsC", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_TestOpsC(_Underlying *_this);
                    __MR_C_not_MR_CSharp_TestOpsC(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator=`.
                /// </summary>
                public unsafe void assign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator+=`.
                /// </summary>
                public unsafe void addAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_add_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_add_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_add_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator-=`.
                /// </summary>
                public unsafe void subAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_sub_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_sub_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_sub_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator*=`.
                /// </summary>
                public unsafe void mulAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_mul_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_mul_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_mul_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator/=`.
                /// </summary>
                public unsafe void divAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_div_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_div_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_div_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator%=`.
                /// </summary>
                public unsafe void modAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_mod_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_mod_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_mod_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator^=`.
                /// </summary>
                public unsafe void xorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_xor_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_xor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_xor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator&=`.
                /// </summary>
                public unsafe void bitandAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_bitand_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_bitand_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_bitand_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator|=`.
                /// </summary>
                public unsafe void bitorAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_bitor_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_bitor_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_bitor_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator<<`.
                /// </summary>
                public unsafe void lshift(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_lshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator>>`.
                /// </summary>
                public unsafe void rshift(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_rshift_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator<<=`.
                /// </summary>
                public unsafe void lshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_lshift_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_lshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_lshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator>>=`.
                /// </summary>
                public unsafe void rshiftAssign(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_rshift_assign", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_rshift_assign(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_rshift_assign(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator<=>`.
                /// </summary>
                public unsafe void compareThreeWay(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_compare_three_way_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator&&`.
                /// </summary>
                public unsafe void and(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_and_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator||`.
                /// </summary>
                public unsafe void or(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_or_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator,`.
                /// </summary>
                public unsafe void comma(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA", ExactSpelling = true)]
                    extern static void __MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_C_comma_MR_CSharp_TestOpsC_MR_CSharp_TestOpsA(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator->*`.
                /// </summary>
                public unsafe void arrowStar(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_arrow_star", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_arrow_star(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_arrow_star(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator->`.
                /// </summary>
                public unsafe void arrow()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_arrow", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_arrow(_Underlying *_this);
                    __MR_CSharp_TestOpsC_arrow(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator()`.
                /// </summary>
                public unsafe void call(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_call", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_call(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_call(_UnderlyingPtr, _1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::TestOpsC::operator[]`.
                /// </summary>
                public unsafe void index(MR.CS.CSharp.Const_TestOpsA _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_TestOpsC_index", ExactSpelling = true)]
                    extern static void __MR_CSharp_TestOpsC_index(_Underlying *_this, MR.CS.CSharp.TestOpsA._Underlying *_1);
                    __MR_CSharp_TestOpsC_index(_UnderlyingPtr, _1._UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_TestOpsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsC`/`Const_TestOpsC` directly.
            /// </summary>
            public class _InOptMut_TestOpsC
            {
                public TestOpsC? Opt;

                public _InOptMut_TestOpsC() {}
                public _InOptMut_TestOpsC(TestOpsC value) {Opt = value;}
                public static implicit operator _InOptMut_TestOpsC(TestOpsC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `TestOpsC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_TestOpsC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `TestOpsC`/`Const_TestOpsC` to pass it to the function.
            /// </summary>
            public class _InOptConst_TestOpsC
            {
                public Const_TestOpsC? Opt;

                public _InOptConst_TestOpsC() {}
                public _InOptConst_TestOpsC(Const_TestOpsC value) {Opt = value;}
                public static implicit operator _InOptConst_TestOpsC(Const_TestOpsC value) {return new(value);}
            }

            // Subscription operator.
            /// <summary>
            /// Generated from class `MR::CSharp::IndexerA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IndexerA : MR.CS.Misc.Object<Const_IndexerA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerA_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerA() {Dispose(false);}

                public unsafe int x => *__ref_storage_x;
                private protected unsafe int *__ref_storage_x;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // x (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_Get_x", ExactSpelling = true)]
                        extern static int *__MR_CSharp_IndexerA_Get_x(MR.CS.CSharp.Const_IndexerA._Underlying *_this);
                        this.__ref_storage_x = __MR_CSharp_IndexerA_Get_x(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IndexerA(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IndexerA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::IndexerA` elementwise.
                /// </summary>
                public unsafe Const_IndexerA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFrom(x);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                /// </summary>
                public unsafe Const_IndexerA(MR.CS.CSharp.Const_IndexerA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFromAnother(MR.CS.CSharp.IndexerA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                /// </summary>
                public Const_IndexerA(IndexerA _other) : this((Const_IndexerA)_other) {}
            }

            // Subscription operator.
            /// <summary>
            /// Generated from class `MR::CSharp::IndexerA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IndexerA : Const_IndexerA
            {
                public new unsafe ref int x => ref *__ref_storage_x;

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IndexerA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IndexerA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::IndexerA` elementwise.
                /// </summary>
                public unsafe IndexerA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFrom(x);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                /// </summary>
                public unsafe IndexerA(MR.CS.CSharp.Const_IndexerA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_ConstructFromAnother(MR.CS.CSharp.IndexerA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerA::IndexerA`.
                /// </summary>
                public IndexerA(IndexerA _other) : this((Const_IndexerA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IndexerA assign(MR.CS.CSharp.Const_IndexerA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IndexerA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerA::operator[]`.
                /// </summary>
                public unsafe ref int this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerA_index", ExactSpelling = true)]
                        extern static int *__MR_CSharp_IndexerA_index(_Underlying *_this, int i);
                        return ref *__MR_CSharp_IndexerA_index(_UnderlyingPtr, i);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerA`/`Const_IndexerA` directly.
            /// </summary>
            public class _InOptMut_IndexerA
            {
                public IndexerA? Opt;

                public _InOptMut_IndexerA() {}
                public _InOptMut_IndexerA(IndexerA value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerA(IndexerA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerA`/`Const_IndexerA` to pass it to the function.
            /// </summary>
            public class _InOptConst_IndexerA
            {
                public Const_IndexerA? Opt;

                public _InOptConst_IndexerA() {}
                public _InOptConst_IndexerA(Const_IndexerA value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerA(Const_IndexerA value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::IndexerB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IndexerB : MR.CS.Misc.Object<Const_IndexerB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerB_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerB() {Dispose(false);}

                public unsafe MR.CS.CSharp.Const_IndexerA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_Get_a(MR.CS.CSharp.Const_IndexerB._Underlying *_this);
                        this.a = new(__MR_CSharp_IndexerB_Get_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IndexerB(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IndexerB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::IndexerB` elementwise.
                /// </summary>
                public unsafe Const_IndexerB(MR.CS.CSharp.Const_IndexerA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFrom(MR.CS.CSharp.IndexerA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                /// </summary>
                public unsafe Const_IndexerB(MR.CS.CSharp.Const_IndexerB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFromAnother(MR.CS.CSharp.IndexerB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                /// </summary>
                public Const_IndexerB(IndexerB _other) : this((Const_IndexerB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                /// </summary>
                public unsafe MR.CS.CSharp.Const_IndexerA this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_1", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_1(_Underlying *_this, int i);
                        return new(__MR_CSharp_IndexerB_index_1(_UnderlyingPtr, i), is_owning: false);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                /// </summary>
                public unsafe MR.CS.CSharp.Const_IndexerA this[int i, int j]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_2", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_2(_Underlying *_this, int i, int j);
                        return new(__MR_CSharp_IndexerB_index_2(_UnderlyingPtr, i, j), is_owning: false);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerB::operator[]`.
                /// </summary>
                public unsafe MR.CS.CSharp.Const_IndexerA index()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_index_0", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_IndexerA._Underlying *__MR_CSharp_IndexerB_index_0(_Underlying *_this);
                    return new(__MR_CSharp_IndexerB_index_0(_UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::IndexerB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IndexerB : Const_IndexerB
            {
                public new unsafe MR.CS.CSharp.IndexerA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IndexerA._Underlying *__MR_CSharp_IndexerB_GetMutable_a(MR.CS.CSharp.IndexerB._Underlying *_this);
                        this.a = new(__MR_CSharp_IndexerB_GetMutable_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IndexerB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IndexerB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::IndexerB` elementwise.
                /// </summary>
                public unsafe IndexerB(MR.CS.CSharp.Const_IndexerA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFrom(MR.CS.CSharp.IndexerA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                /// </summary>
                public unsafe IndexerB(MR.CS.CSharp.Const_IndexerB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_ConstructFromAnother(MR.CS.CSharp.IndexerB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerB::IndexerB`.
                /// </summary>
                public IndexerB(IndexerB _other) : this((Const_IndexerB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IndexerB assign(MR.CS.CSharp.Const_IndexerB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerB._Underlying *__MR_CSharp_IndexerB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IndexerB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerB`/`Const_IndexerB` directly.
            /// </summary>
            public class _InOptMut_IndexerB
            {
                public IndexerB? Opt;

                public _InOptMut_IndexerB() {}
                public _InOptMut_IndexerB(IndexerB value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerB(IndexerB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerB`/`Const_IndexerB` to pass it to the function.
            /// </summary>
            public class _InOptConst_IndexerB
            {
                public Const_IndexerB? Opt;

                public _InOptConst_IndexerB() {}
                public _InOptConst_IndexerB(Const_IndexerB value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerB(Const_IndexerB value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::IndexerC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IndexerC : MR.CS.Misc.Object<Const_IndexerC>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IndexerC_Destroy(_Underlying *_this);
                    __MR_CSharp_IndexerC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IndexerC() {Dispose(false);}

                internal unsafe Const_IndexerC(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IndexerC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                /// </summary>
                public unsafe Const_IndexerC(MR.CS.CSharp.Const_IndexerC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_ConstructFromAnother(MR.CS.CSharp.IndexerC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                /// </summary>
                public Const_IndexerC(IndexerC _other) : this((Const_IndexerC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerC::operator[]`.
                /// </summary>
                public unsafe float this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_index", ExactSpelling = true)]
                        extern static float __MR_CSharp_IndexerC_index(_Underlying *_this, int i);
                        return __MR_CSharp_IndexerC_index(_UnderlyingPtr, i);
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::IndexerC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IndexerC : Const_IndexerC
            {
                internal unsafe IndexerC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IndexerC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IndexerC_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                /// </summary>
                public unsafe IndexerC(MR.CS.CSharp.Const_IndexerC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_ConstructFromAnother(MR.CS.CSharp.IndexerC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IndexerC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IndexerC::IndexerC`.
                /// </summary>
                public IndexerC(IndexerC _other) : this((Const_IndexerC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IndexerC assign(MR.CS.CSharp.Const_IndexerC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IndexerC._Underlying *__MR_CSharp_IndexerC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IndexerC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IndexerC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IndexerC::operator[]`.
                /// </summary>
                public unsafe new int this[int i]
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IndexerC_index_mut", ExactSpelling = true)]
                        extern static int __MR_CSharp_IndexerC_index_mut(_Underlying *_this, int i);
                        return __MR_CSharp_IndexerC_index_mut(_UnderlyingPtr, i);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IndexerC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerC`/`Const_IndexerC` directly.
            /// </summary>
            public class _InOptMut_IndexerC
            {
                public IndexerC? Opt;

                public _InOptMut_IndexerC() {}
                public _InOptMut_IndexerC(IndexerC value) {Opt = value;}
                public static implicit operator _InOptMut_IndexerC(IndexerC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IndexerC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IndexerC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IndexerC`/`Const_IndexerC` to pass it to the function.
            /// </summary>
            public class _InOptConst_IndexerC
            {
                public Const_IndexerC? Opt;

                public _InOptConst_IndexerC() {}
                public _InOptConst_IndexerC(Const_IndexerC value) {Opt = value;}
                public static implicit operator _InOptConst_IndexerC(Const_IndexerC value) {return new(value);}
            }

            // Conversion operators. We preserve explicit-ness.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvOp`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvOp : MR.CS.Misc.Object<Const_ConvOp>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvOp_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvOp_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvOp() {Dispose(false);}

                internal unsafe Const_ConvOp(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ConvOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOp_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                /// </summary>
                public unsafe Const_ConvOp(MR.CS.CSharp.Const_ConvOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_ConstructFromAnother(MR.CS.CSharp.ConvOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOp_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                /// </summary>
                public Const_ConvOp(ConvOp _other) : this((Const_ConvOp)_other) {}
            }

            // Conversion operators. We preserve explicit-ness.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvOp`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvOp : Const_ConvOp
            {
                internal unsafe ConvOp(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ConvOp() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOp_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                /// </summary>
                public unsafe ConvOp(MR.CS.CSharp.Const_ConvOp _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_ConstructFromAnother(MR.CS.CSharp.ConvOp._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOp_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOp::ConvOp`.
                /// </summary>
                public ConvOp(ConvOp _other) : this((Const_ConvOp)_other) {}

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::ConvOp::operator int32_t`.
                /// </summary>
                public static unsafe implicit operator int(MR.CS.CSharp.ConvOp _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConvertTo_int32_t", ExactSpelling = true)]
                    extern static int __MR_CSharp_ConvOp_ConvertTo_int32_t(MR.CS.CSharp.ConvOp._Underlying *_this);
                    return __MR_CSharp_ConvOp_ConvertTo_int32_t(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::ConvOp::operator float`.
                /// </summary>
                public static unsafe explicit operator float(MR.CS.CSharp.ConvOp _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_ConvertTo_float", ExactSpelling = true)]
                    extern static float __MR_CSharp_ConvOp_ConvertTo_float(MR.CS.CSharp.ConvOp._Underlying *_this);
                    return __MR_CSharp_ConvOp_ConvertTo_float(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConvOp::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvOp assign(MR.CS.CSharp.Const_ConvOp _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOp_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOp._Underlying *__MR_CSharp_ConvOp_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvOp._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_ConvOp_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvOp` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOp`/`Const_ConvOp` directly.
            /// </summary>
            public class _InOptMut_ConvOp
            {
                public ConvOp? Opt;

                public _InOptMut_ConvOp() {}
                public _InOptMut_ConvOp(ConvOp value) {Opt = value;}
                public static implicit operator _InOptMut_ConvOp(ConvOp value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvOp` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvOp`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOp`/`Const_ConvOp` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvOp
            {
                public Const_ConvOp? Opt;

                public _InOptConst_ConvOp() {}
                public _InOptConst_ConvOp(Const_ConvOp value) {Opt = value;}
                public static implicit operator _InOptConst_ConvOp(Const_ConvOp value) {return new(value);}
            }

            // Conversion operators to references.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvOpToRef`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvOpToRef : MR.CS.Misc.Object<Const_ConvOpToRef>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvOpToRef_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvOpToRef_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvOpToRef() {Dispose(false);}

                internal unsafe Const_ConvOpToRef(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ConvOpToRef() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                /// </summary>
                public unsafe Const_ConvOpToRef(MR.CS.CSharp.Const_ConvOpToRef _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_ConstructFromAnother(MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                /// </summary>
                public Const_ConvOpToRef(ConvOpToRef _other) : this((Const_ConvOpToRef)_other) {}
            }

            // Conversion operators to references.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvOpToRef`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvOpToRef : Const_ConvOpToRef
            {
                internal unsafe ConvOpToRef(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ConvOpToRef() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                /// </summary>
                public unsafe ConvOpToRef(MR.CS.CSharp.Const_ConvOpToRef _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_ConstructFromAnother(MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvOpToRef_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvOpToRef::ConvOpToRef`.
                /// </summary>
                public ConvOpToRef(ConvOpToRef _other) : this((Const_ConvOpToRef)_other) {}

                // Not to a reference.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator int32_t`.
                /// </summary>
                public static unsafe implicit operator int(MR.CS.CSharp.ConvOpToRef _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_int32_t", ExactSpelling = true)]
                    extern static int __MR_CSharp_ConvOpToRef_ConvertTo_int32_t(MR.CS.CSharp.ConvOpToRef._Underlying *_this);
                    return __MR_CSharp_ConvOpToRef_ConvertTo_int32_t(_this._UnderlyingPtr);
                }

                // To a reference.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator float &`.
                /// </summary>
                public unsafe ref float convertTo_FloatRef()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_float_ref", ExactSpelling = true)]
                    extern static float *__MR_CSharp_ConvOpToRef_ConvertTo_float_ref(_Underlying *_this);
                    return ref *__MR_CSharp_ConvOpToRef_ConvertTo_float_ref(_UnderlyingPtr);
                }

                // To a reference, explicit.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::ConvOpToRef::operator uint16_t &`.
                /// </summary>
                public unsafe ref ushort convertTo_Uint16TRef()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_ConvertTo_uint16_t_ref", ExactSpelling = true)]
                    extern static ushort *__MR_CSharp_ConvOpToRef_ConvertTo_uint16_t_ref(_Underlying *_this);
                    return ref *__MR_CSharp_ConvOpToRef_ConvertTo_uint16_t_ref(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConvOpToRef::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvOpToRef assign(MR.CS.CSharp.Const_ConvOpToRef _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvOpToRef_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvOpToRef._Underlying *__MR_CSharp_ConvOpToRef_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvOpToRef._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_ConvOpToRef_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvOpToRef` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvOpToRef`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOpToRef`/`Const_ConvOpToRef` directly.
            /// </summary>
            public class _InOptMut_ConvOpToRef
            {
                public ConvOpToRef? Opt;

                public _InOptMut_ConvOpToRef() {}
                public _InOptMut_ConvOpToRef(ConvOpToRef value) {Opt = value;}
                public static implicit operator _InOptMut_ConvOpToRef(ConvOpToRef value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvOpToRef` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvOpToRef`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvOpToRef`/`Const_ConvOpToRef` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvOpToRef
            {
                public Const_ConvOpToRef? Opt;

                public _InOptConst_ConvOpToRef() {}
                public _InOptConst_ConvOpToRef(Const_ConvOpToRef value) {Opt = value;}
                public static implicit operator _InOptConst_ConvOpToRef(Const_ConvOpToRef value) {return new(value);}
            }

            // Conversions to string-like types.
            // Those create the additional `operator string` to convert directly to a C# string, and `override string ToString()` to override the method of the implicit base `object`.
            /// <summary>
            /// Generated from class `MR::CSharp::StringConvString`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StringConvString : MR.CS.Misc.Object<Const_StringConvString>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvString_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvString_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvString() {Dispose(false);}

                internal unsafe Const_StringConvString(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StringConvString() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvString_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                /// </summary>
                public unsafe Const_StringConvString(MR.CS.CSharp.Const_StringConvString _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_ConstructFromAnother(MR.CS.CSharp.StringConvString._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvString_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                /// </summary>
                public Const_StringConvString(StringConvString _other) : this((Const_StringConvString)_other) {}
            }

            // Conversions to string-like types.
            // Those create the additional `operator string` to convert directly to a C# string, and `override string ToString()` to override the method of the implicit base `object`.
            /// <summary>
            /// Generated from class `MR::CSharp::StringConvString`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StringConvString : Const_StringConvString
            {
                internal unsafe StringConvString(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StringConvString() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvString_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                /// </summary>
                public unsafe StringConvString(MR.CS.CSharp.Const_StringConvString _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_ConstructFromAnother(MR.CS.CSharp.StringConvString._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvString_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvString::StringConvString`.
                /// </summary>
                public StringConvString(StringConvString _other) : this((Const_StringConvString)_other) {}

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                /// </summary>
                public static unsafe implicit operator MR.CS.Std.String(MR.CS.CSharp.StringConvString _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_ConvertTo_std_string", ExactSpelling = true)]
                    extern static MR.CS.Std.String._Underlying *__MR_CSharp_StringConvString_ConvertTo_std_string(MR.CS.CSharp.StringConvString._Underlying *_this);
                    return new(__MR_CSharp_StringConvString_ConvertTo_std_string(_this._UnderlyingPtr), is_owning: true);
                }

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                /// </summary>
                public static implicit operator string(MR.CS.CSharp.StringConvString _this) {return (MR.CS.Std.String)_this;}

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvString::operator std::string`.
                /// </summary>
                public override string ToString() {return (string)this;}

                /// <summary>
                /// Generated from method `MR::CSharp::StringConvString::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StringConvString assign(MR.CS.CSharp.Const_StringConvString _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvString_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvString._Underlying *__MR_CSharp_StringConvString_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvString._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StringConvString_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvString` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvString`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvString`/`Const_StringConvString` directly.
            /// </summary>
            public class _InOptMut_StringConvString
            {
                public StringConvString? Opt;

                public _InOptMut_StringConvString() {}
                public _InOptMut_StringConvString(StringConvString value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvString(StringConvString value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvString` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvString`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvString`/`Const_StringConvString` to pass it to the function.
            /// </summary>
            public class _InOptConst_StringConvString
            {
                public Const_StringConvString? Opt;

                public _InOptConst_StringConvString() {}
                public _InOptConst_StringConvString(Const_StringConvString value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvString(Const_StringConvString value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StringConvStringView`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StringConvStringView : MR.CS.Misc.Object<Const_StringConvStringView>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvStringView_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvStringView_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvStringView() {Dispose(false);}

                internal unsafe Const_StringConvStringView(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StringConvStringView() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                /// </summary>
                public unsafe Const_StringConvStringView(MR.CS.CSharp.Const_StringConvStringView _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_ConstructFromAnother(MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                /// </summary>
                public Const_StringConvStringView(StringConvStringView _other) : this((Const_StringConvStringView)_other) {}

                // Mark this `explicit` and `const` for a change.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                /// </summary>
                public static unsafe explicit operator MR.CS.Std.StringView(MR.CS.CSharp.Const_StringConvStringView _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConvertTo_std_string_view", ExactSpelling = true)]
                    extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_StringConvStringView_ConvertTo_std_string_view(MR.CS.CSharp.Const_StringConvStringView._Underlying *_this);
                    return new(__MR_CSharp_StringConvStringView_ConvertTo_std_string_view(_this._UnderlyingPtr), is_owning: true);
                }

                // Mark this `explicit` and `const` for a change.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                /// </summary>
                public static explicit operator string(MR.CS.CSharp.Const_StringConvStringView _this) {return (MR.CS.Std.StringView)_this;}

                // Mark this `explicit` and `const` for a change.
                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvStringView::operator std::string_view`.
                /// </summary>
                public override string ToString() {return (string)this;}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StringConvStringView`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StringConvStringView : Const_StringConvStringView
            {
                internal unsafe StringConvStringView(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StringConvStringView() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                /// </summary>
                public unsafe StringConvStringView(MR.CS.CSharp.Const_StringConvStringView _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_ConstructFromAnother(MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvStringView_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvStringView::StringConvStringView`.
                /// </summary>
                public StringConvStringView(StringConvStringView _other) : this((Const_StringConvStringView)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::StringConvStringView::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StringConvStringView assign(MR.CS.CSharp.Const_StringConvStringView _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvStringView_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvStringView._Underlying *__MR_CSharp_StringConvStringView_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvStringView._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StringConvStringView_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvStringView` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvStringView`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvStringView`/`Const_StringConvStringView` directly.
            /// </summary>
            public class _InOptMut_StringConvStringView
            {
                public StringConvStringView? Opt;

                public _InOptMut_StringConvStringView() {}
                public _InOptMut_StringConvStringView(StringConvStringView value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvStringView(StringConvStringView value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvStringView` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvStringView`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvStringView`/`Const_StringConvStringView` to pass it to the function.
            /// </summary>
            public class _InOptConst_StringConvStringView
            {
                public Const_StringConvStringView? Opt;

                public _InOptConst_StringConvStringView() {}
                public _InOptConst_StringConvStringView(Const_StringConvStringView value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvStringView(Const_StringConvStringView value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StringConvFsPath`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_StringConvFsPath : MR.CS.Misc.Object<Const_StringConvFsPath>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_StringConvFsPath_Destroy(_Underlying *_this);
                    __MR_CSharp_StringConvFsPath_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_StringConvFsPath() {Dispose(false);}

                internal unsafe Const_StringConvFsPath(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_StringConvFsPath() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                /// </summary>
                public unsafe Const_StringConvFsPath(MR.CS.CSharp.Const_StringConvFsPath _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_ConstructFromAnother(MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                /// </summary>
                public Const_StringConvFsPath(StringConvFsPath _other) : this((Const_StringConvFsPath)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::StringConvFsPath`.
            /// This is the non-const half of the class.
            /// </summary>
            public class StringConvFsPath : Const_StringConvFsPath
            {
                internal unsafe StringConvFsPath(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe StringConvFsPath() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                /// </summary>
                public unsafe StringConvFsPath(MR.CS.CSharp.Const_StringConvFsPath _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_ConstructFromAnother(MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_StringConvFsPath_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::StringConvFsPath::StringConvFsPath`.
                /// </summary>
                public StringConvFsPath(StringConvFsPath _other) : this((Const_StringConvFsPath)_other) {}

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                /// </summary>
                public static unsafe implicit operator MR.CS.Std.Filesystem.Path(MR.CS.CSharp.StringConvFsPath _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path", ExactSpelling = true)]
                    extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path(MR.CS.CSharp.StringConvFsPath._Underlying *_this);
                    return new(__MR_CSharp_StringConvFsPath_ConvertTo_std_filesystem_path(_this._UnderlyingPtr), is_owning: true);
                }

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                /// </summary>
                public static implicit operator string(MR.CS.CSharp.StringConvFsPath _this) {return (MR.CS.Std.Filesystem.Path)_this;}

                /// <summary>
                /// Generated from conversion operator `MR::CSharp::StringConvFsPath::operator std::filesystem::path`.
                /// </summary>
                public override string ToString() {return (string)this;}

                /// <summary>
                /// Generated from method `MR::CSharp::StringConvFsPath::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.StringConvFsPath assign(MR.CS.CSharp.Const_StringConvFsPath _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_StringConvFsPath_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.StringConvFsPath._Underlying *__MR_CSharp_StringConvFsPath_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.StringConvFsPath._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_StringConvFsPath_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvFsPath` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_StringConvFsPath`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvFsPath`/`Const_StringConvFsPath` directly.
            /// </summary>
            public class _InOptMut_StringConvFsPath
            {
                public StringConvFsPath? Opt;

                public _InOptMut_StringConvFsPath() {}
                public _InOptMut_StringConvFsPath(StringConvFsPath value) {Opt = value;}
                public static implicit operator _InOptMut_StringConvFsPath(StringConvFsPath value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `StringConvFsPath` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_StringConvFsPath`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `StringConvFsPath`/`Const_StringConvFsPath` to pass it to the function.
            /// </summary>
            public class _InOptConst_StringConvFsPath
            {
                public Const_StringConvFsPath? Opt;

                public _InOptConst_StringConvFsPath() {}
                public _InOptConst_StringConvFsPath(Const_StringConvFsPath value) {Opt = value;}
                public static implicit operator _InOptConst_StringConvFsPath(Const_StringConvFsPath value) {return new(value);}
            }

            // Conversion constructors. Right now we only provide conversion operators for implicit ones,
            //   because I have no idea when the explicit ones could be useful.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtor`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtor : MR.CS.Misc.Object<Const_ConvCtor>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtor_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtor_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtor() {Dispose(false);}

                internal unsafe Const_ConvCtor(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ConvCtor() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe Const_ConvCtor(MR.CS.CSharp.Const_ConvCtor _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_ConstructFromAnother(MR.CS.CSharp.ConvCtor._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public Const_ConvCtor(ConvCtor _other) : this((Const_ConvCtor)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe Const_ConvCtor(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_int32_t(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_int32_t(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtor(int _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe Const_ConvCtor(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int32_t(int _1, int _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int32_t(_1, _2);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// Parameter `_2` defaults to `42`.
                /// </summary>
                public unsafe Const_ConvCtor(short _1, int? _2 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int16_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int16_t(short _1, int *_2);
                    int __deref__2 = _2.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int16_t(_1, _2.HasValue ? &__deref__2 : null);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// Parameter `_2` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtor(short _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe Const_ConvCtor(float _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_float(float _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_float(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe Const_ConvCtor(float _1, float _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_float(float _1, float _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_float(_1, _2);
                }
            }

            // Conversion constructors. Right now we only provide conversion operators for implicit ones,
            //   because I have no idea when the explicit ones could be useful.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtor`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtor : Const_ConvCtor
            {
                internal unsafe ConvCtor(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ConvCtor() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe ConvCtor(MR.CS.CSharp.Const_ConvCtor _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_ConstructFromAnother(MR.CS.CSharp.ConvCtor._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public ConvCtor(ConvCtor _other) : this((Const_ConvCtor)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe ConvCtor(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_int32_t(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_int32_t(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public static unsafe implicit operator ConvCtor(int _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe ConvCtor(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int32_t(int _1, int _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int32_t(_1, _2);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// Parameter `_2` defaults to `42`.
                /// </summary>
                public unsafe ConvCtor(short _1, int? _2 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_int16_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_int16_t(short _1, int *_2);
                    int __deref__2 = _2.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_int16_t(_1, _2.HasValue ? &__deref__2 : null);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// Parameter `_2` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator ConvCtor(short _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe ConvCtor(float _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_1_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_1_float(float _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_1_float(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public unsafe ConvCtor(float _1, float _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_Construct_2_float", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_Construct_2_float(float _1, float _2);
                    _UnderlyingPtr = __MR_CSharp_ConvCtor_Construct_2_float(_1, _2);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtor::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtor assign(MR.CS.CSharp.Const_ConvCtor _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtor_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtor._Underlying *__MR_CSharp_ConvCtor_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtor._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_ConvCtor_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtor` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtor`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtor`/`Const_ConvCtor` directly.
            /// </summary>
            public class _InOptMut_ConvCtor
            {
                public ConvCtor? Opt;

                public _InOptMut_ConvCtor() {}
                public _InOptMut_ConvCtor(ConvCtor value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtor(ConvCtor value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtor` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtor`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtor`/`Const_ConvCtor` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtor
            {
                public Const_ConvCtor? Opt;

                public _InOptConst_ConvCtor() {}
                public _InOptConst_ConvCtor(Const_ConvCtor value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtor(Const_ConvCtor value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtor(int _1) {return new Const_ConvCtor(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtor::ConvCtor`.
                /// Parameter `_2` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtor(short _1) {return new Const_ConvCtor(_1);}
            }

            // Test that the default argument of the parameter of a converting constructor is stripped when rewriting it as a conversion operator.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorWithDefArg`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtorWithDefArg : MR.CS.Misc.Object<Const_ConvCtorWithDefArg>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorWithDefArg_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorWithDefArg_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorWithDefArg() {Dispose(false);}

                internal unsafe Const_ConvCtorWithDefArg(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                /// </summary>
                public unsafe Const_ConvCtorWithDefArg(int? _1 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_Construct(int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_Construct(_1.HasValue ? &__deref__1 : null);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtorWithDefArg(int? _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// </summary>
                public unsafe Const_ConvCtorWithDefArg(MR.CS.CSharp.Const_ConvCtorWithDefArg _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// </summary>
                public Const_ConvCtorWithDefArg(ConvCtorWithDefArg _other) : this((Const_ConvCtorWithDefArg)_other) {}
            }

            // Test that the default argument of the parameter of a converting constructor is stripped when rewriting it as a conversion operator.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorWithDefArg`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtorWithDefArg : Const_ConvCtorWithDefArg
            {
                internal unsafe ConvCtorWithDefArg(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                /// </summary>
                public unsafe ConvCtorWithDefArg(int? _1 = null) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_Construct(int *_1);
                    int __deref__1 = _1.GetValueOrDefault();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_Construct(_1.HasValue ? &__deref__1 : null);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator ConvCtorWithDefArg(int? _1) {return new(_1);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// </summary>
                public unsafe ConvCtorWithDefArg(MR.CS.CSharp.Const_ConvCtorWithDefArg _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorWithDefArg_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// </summary>
                public ConvCtorWithDefArg(ConvCtorWithDefArg _other) : this((Const_ConvCtorWithDefArg)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtorWithDefArg::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtorWithDefArg assign(MR.CS.CSharp.Const_ConvCtorWithDefArg _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorWithDefArg_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorWithDefArg._Underlying *__MR_CSharp_ConvCtorWithDefArg_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtorWithDefArg._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_ConvCtorWithDefArg_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorWithDefArg` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorWithDefArg`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorWithDefArg`/`Const_ConvCtorWithDefArg` directly.
            /// </summary>
            public class _InOptMut_ConvCtorWithDefArg
            {
                public ConvCtorWithDefArg? Opt;

                public _InOptMut_ConvCtorWithDefArg() {}
                public _InOptMut_ConvCtorWithDefArg(ConvCtorWithDefArg value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorWithDefArg(ConvCtorWithDefArg value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorWithDefArg` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorWithDefArg`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorWithDefArg`/`Const_ConvCtorWithDefArg` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtorWithDefArg
            {
                public Const_ConvCtorWithDefArg? Opt;

                public _InOptConst_ConvCtorWithDefArg() {}
                public _InOptConst_ConvCtorWithDefArg(Const_ConvCtorWithDefArg value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorWithDefArg(Const_ConvCtorWithDefArg value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorWithDefArg::ConvCtorWithDefArg`.
                /// Parameter `_1` defaults to `42`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorWithDefArg(int? _1) {return new Const_ConvCtorWithDefArg(_1);}
            }

            // A non-trivial move-only class with a converting ctor.
            // Here we test that our converting constructors injected into `_ByValue_...` don't attempt to copy the class.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorNonTrivialRestricted`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtorNonTrivialRestricted : MR.CS.Misc.Object<Const_ConvCtorNonTrivialRestricted>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorNonTrivialRestricted_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorNonTrivialRestricted_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorNonTrivialRestricted() {Dispose(false);}

                internal unsafe Const_ConvCtorNonTrivialRestricted(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public unsafe Const_ConvCtorNonTrivialRestricted(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public unsafe Const_ConvCtorNonTrivialRestricted(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtorNonTrivialRestricted(int _1) {return new(_1);}
            }

            // A non-trivial move-only class with a converting ctor.
            // Here we test that our converting constructors injected into `_ByValue_...` don't attempt to copy the class.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorNonTrivialRestricted`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtorNonTrivialRestricted : Const_ConvCtorNonTrivialRestricted
            {
                internal unsafe ConvCtorNonTrivialRestricted(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public unsafe ConvCtorNonTrivialRestricted(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public unsafe ConvCtorNonTrivialRestricted(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivialRestricted_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public static unsafe implicit operator ConvCtorNonTrivialRestricted(int _1) {return new(_1);}

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtorNonTrivialRestricted::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtorNonTrivialRestricted assign(MR.CS.CSharp._ByValue_ConvCtorNonTrivialRestricted _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *__MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivialRestricted._Underlying *_other);
                    MR.CS.CSharp.ConvCtorNonTrivialRestricted __ret;
                    __ret = new(__MR_CSharp_ConvCtorNonTrivialRestricted_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `ConvCtorNonTrivialRestricted` by value.
            /// Usage:
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_ConvCtorNonTrivialRestricted
            {
                internal readonly Const_ConvCtorNonTrivialRestricted? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorNonTrivialRestricted(MR.CS.Misc._Moved<ConvCtorNonTrivialRestricted> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ConvCtorNonTrivialRestricted(MR.CS.Misc._Moved<ConvCtorNonTrivialRestricted> arg) {return new(arg);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public static unsafe implicit operator _ByValue_ConvCtorNonTrivialRestricted(int _1) {return new MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivialRestricted>(_1);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorNonTrivialRestricted` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorNonTrivialRestricted`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivialRestricted`/`Const_ConvCtorNonTrivialRestricted` directly.
            /// </summary>
            public class _InOptMut_ConvCtorNonTrivialRestricted
            {
                public ConvCtorNonTrivialRestricted? Opt;

                public _InOptMut_ConvCtorNonTrivialRestricted() {}
                public _InOptMut_ConvCtorNonTrivialRestricted(ConvCtorNonTrivialRestricted value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorNonTrivialRestricted(ConvCtorNonTrivialRestricted value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorNonTrivialRestricted` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorNonTrivialRestricted`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivialRestricted`/`Const_ConvCtorNonTrivialRestricted` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtorNonTrivialRestricted
            {
                public Const_ConvCtorNonTrivialRestricted? Opt;

                public _InOptConst_ConvCtorNonTrivialRestricted() {}
                public _InOptConst_ConvCtorNonTrivialRestricted(Const_ConvCtorNonTrivialRestricted value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorNonTrivialRestricted(Const_ConvCtorNonTrivialRestricted value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivialRestricted::ConvCtorNonTrivialRestricted`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorNonTrivialRestricted(int _1) {return new Const_ConvCtorNonTrivialRestricted(_1);}
            }

            // A converting ctor in an exposed struct.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_ConvCtorExposed : MR.CS.Misc.Object<ConstBox_ConvCtorExposed>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly ConvCtorExposed _Ref => ref *(ConvCtorExposed *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_ConvCtorExposed() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_ConvCtorExposed(ConvCtorExposed other) : this(new ConstBox_ConvCtorExposed((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_ConvCtorExposed` has this conversion, `Box_ConvCtorExposed` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_ConvCtorExposed(ConvCtorExposed other) {return new(other);}

                internal unsafe ConstBox_ConvCtorExposed(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_ConvCtorExposed(ConstBox_ConvCtorExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConvCtorExposed *)_UnderlyingPtr = *(MR.CS.CSharp.ConvCtorExposed *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public unsafe ConstBox_ConvCtorExposed(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConvCtorExposed *)_UnderlyingPtr = __MR_CSharp_ConvCtorExposed_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public static unsafe implicit operator ConstBox_ConvCtorExposed(int _1) {return new(_1);}
            }

            // A converting ctor in an exposed struct.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_ConvCtorExposed : ConstBox_ConvCtorExposed
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref ConvCtorExposed _Ref => ref *(ConvCtorExposed *)_UnderlyingPtr;

                public new ref int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_ConvCtorExposed(ConvCtorExposed other) : this(new ConstBox_ConvCtorExposed((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_ConvCtorExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_ConvCtorExposed(ConstBox_ConvCtorExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConvCtorExposed *)_UnderlyingPtr = *(MR.CS.CSharp.ConvCtorExposed *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_ConvCtorExposed _other) {_Ref = _other._Ref;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public unsafe Box_ConvCtorExposed(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConvCtorExposed *)_UnderlyingPtr = __MR_CSharp_ConvCtorExposed_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public static unsafe implicit operator Box_ConvCtorExposed(int _1) {return new(_1);}
            }

            // A converting ctor in an exposed struct.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorExposed`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ConvCtorExposed
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator ConvCtorExposed(ConstBox_ConvCtorExposed other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public ConvCtorExposed(ConvCtorExposed _other) {this = _other;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public unsafe ConvCtorExposed(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorExposed_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorExposed __MR_CSharp_ConvCtorExposed_Construct(int _1);
                    this = __MR_CSharp_ConvCtorExposed_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public static unsafe implicit operator ConvCtorExposed(int _1) {return new(_1);}
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_ConvCtorExposed` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_ConvCtorExposed`/`ConstBox_ConvCtorExposed` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_ConvCtorExposed
            {
                public readonly bool HasValue;
                internal readonly ConvCtorExposed Object;
                public ConvCtorExposed Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ConvCtorExposed() {HasValue = false;}
                public _InOpt_ConvCtorExposed(ConvCtorExposed new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ConvCtorExposed(ConvCtorExposed new_value) {return new(new_value);}
                public _InOpt_ConvCtorExposed(ConstBox_ConvCtorExposed new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ConvCtorExposed(ConstBox_ConvCtorExposed new_value) {return new(new_value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public static unsafe implicit operator _InOpt_ConvCtorExposed(int _1) {return new ConstBox_ConvCtorExposed(_1);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ConvCtorExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ConvCtorExposed`/`ConstBox_ConvCtorExposed` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ConvCtorExposed`.
            /// </summary>
            public class _InOptMut_ConvCtorExposed
            {
                public Box_ConvCtorExposed? Opt;

                public _InOptMut_ConvCtorExposed() {}
                public _InOptMut_ConvCtorExposed(Box_ConvCtorExposed value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorExposed(Box_ConvCtorExposed value) {return new(value);}
                public unsafe _InOptMut_ConvCtorExposed(ref ConvCtorExposed value)
                {
                    fixed (ConvCtorExposed *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ConvCtorExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ConvCtorExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ConvCtorExposed`/`ConstBox_ConvCtorExposed` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ConvCtorExposed`.
            /// </summary>
            public class _InOptConst_ConvCtorExposed
            {
                public ConstBox_ConvCtorExposed? Opt;

                public _InOptConst_ConvCtorExposed() {}
                public _InOptConst_ConvCtorExposed(ConstBox_ConvCtorExposed value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorExposed(ConstBox_ConvCtorExposed value) {return new(value);}
                public unsafe _InOptConst_ConvCtorExposed(ref readonly ConvCtorExposed value)
                {
                    fixed (ConvCtorExposed *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ConvCtorExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorExposed::ConvCtorExposed`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorExposed(int _1) {return new ConstBox_ConvCtorExposed(_1);}
            }

            // A sad class that's copyable but not movable.
            // This can often happen if you have a user-provided destructor.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorCopyButNoMove`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtorCopyButNoMove : MR.CS.Misc.Object<Const_ConvCtorCopyButNoMove>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorCopyButNoMove_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorCopyButNoMove_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorCopyButNoMove() {Dispose(false);}

                internal unsafe Const_ConvCtorCopyButNoMove(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public unsafe Const_ConvCtorCopyButNoMove(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public Const_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove _other) : this(new _ByValue_ConvCtorCopyButNoMove(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public Const_ConvCtorCopyButNoMove(ConvCtorCopyButNoMove _other) : this((Const_ConvCtorCopyButNoMove)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public unsafe Const_ConvCtorCopyButNoMove(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtorCopyButNoMove(int _1) {return new(_1);}
            }

            // A sad class that's copyable but not movable.
            // This can often happen if you have a user-provided destructor.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorCopyButNoMove`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtorCopyButNoMove : Const_ConvCtorCopyButNoMove
            {
                internal unsafe ConvCtorCopyButNoMove(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public unsafe ConvCtorCopyButNoMove(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove _other) : this(new _ByValue_ConvCtorCopyButNoMove(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public ConvCtorCopyButNoMove(ConvCtorCopyButNoMove _other) : this((Const_ConvCtorCopyButNoMove)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public unsafe ConvCtorCopyButNoMove(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorCopyButNoMove_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public static unsafe implicit operator ConvCtorCopyButNoMove(int _1) {return new(_1);}

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtorCopyButNoMove::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtorCopyButNoMove assign(MR.CS.CSharp._ByValue_ConvCtorCopyButNoMove _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *__MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorCopyButNoMove._Underlying *_other);
                    MR.CS.CSharp.ConvCtorCopyButNoMove __ret;
                    __ret = new(__MR_CSharp_ConvCtorCopyButNoMove_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `ConvCtorCopyButNoMove` by value.
            /// Usage:
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` to copy it into the function.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_ConvCtorCopyButNoMove
            {
                internal readonly Const_ConvCtorCopyButNoMove? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove arg) {return new(arg);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public static unsafe implicit operator _ByValue_ConvCtorCopyButNoMove(int _1) {return new MR.CS.CSharp.ConvCtorCopyButNoMove(_1);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorCopyButNoMove` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorCopyButNoMove`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` directly.
            /// </summary>
            public class _InOptMut_ConvCtorCopyButNoMove
            {
                public ConvCtorCopyButNoMove? Opt;

                public _InOptMut_ConvCtorCopyButNoMove() {}
                public _InOptMut_ConvCtorCopyButNoMove(ConvCtorCopyButNoMove value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorCopyButNoMove(ConvCtorCopyButNoMove value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorCopyButNoMove` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorCopyButNoMove`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorCopyButNoMove`/`Const_ConvCtorCopyButNoMove` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtorCopyButNoMove
            {
                public Const_ConvCtorCopyButNoMove? Opt;

                public _InOptConst_ConvCtorCopyButNoMove() {}
                public _InOptConst_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorCopyButNoMove(Const_ConvCtorCopyButNoMove value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorCopyButNoMove::ConvCtorCopyButNoMove`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorCopyButNoMove(int _1) {return new Const_ConvCtorCopyButNoMove(_1);}
            }

            // Test how a trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorTrivial`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtorTrivial : MR.CS.Misc.Object<Const_ConvCtorTrivial>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorTrivial() {Dispose(false);}

                internal unsafe Const_ConvCtorTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ConvCtorTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public unsafe Const_ConvCtorTrivial(MR.CS.CSharp.Const_ConvCtorTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_ConstructFromAnother(MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public Const_ConvCtorTrivial(ConvCtorTrivial _other) : this((Const_ConvCtorTrivial)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public unsafe Const_ConvCtorTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtorTrivial(int _1) {return new(_1);}
            }

            // Test how a trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorTrivial`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtorTrivial : Const_ConvCtorTrivial
            {
                internal unsafe ConvCtorTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ConvCtorTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public unsafe ConvCtorTrivial(MR.CS.CSharp.Const_ConvCtorTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_ConstructFromAnother(MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public ConvCtorTrivial(ConvCtorTrivial _other) : this((Const_ConvCtorTrivial)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public unsafe ConvCtorTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorTrivial_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public static unsafe implicit operator ConvCtorTrivial(int _1) {return new(_1);}

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtorTrivial::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtorTrivial assign(MR.CS.CSharp.Const_ConvCtorTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_ConvCtorTrivial_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.ConvCtorTrivial._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_ConvCtorTrivial_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorTrivial`/`Const_ConvCtorTrivial` directly.
            /// </summary>
            public class _InOptMut_ConvCtorTrivial
            {
                public ConvCtorTrivial? Opt;

                public _InOptMut_ConvCtorTrivial() {}
                public _InOptMut_ConvCtorTrivial(ConvCtorTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorTrivial(ConvCtorTrivial value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorTrivial`/`Const_ConvCtorTrivial` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtorTrivial
            {
                public Const_ConvCtorTrivial? Opt;

                public _InOptConst_ConvCtorTrivial() {}
                public _InOptConst_ConvCtorTrivial(Const_ConvCtorTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorTrivial(Const_ConvCtorTrivial value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorTrivial::ConvCtorTrivial`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorTrivial(int _1) {return new Const_ConvCtorTrivial(_1);}
            }

            // Test how a non-trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorNonTrivial`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ConvCtorNonTrivial : MR.CS.Misc.Object<Const_ConvCtorNonTrivial>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConvCtorNonTrivial_Destroy(_Underlying *_this);
                    __MR_CSharp_ConvCtorNonTrivial_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ConvCtorNonTrivial() {Dispose(false);}

                internal unsafe Const_ConvCtorNonTrivial(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ConvCtorNonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public unsafe Const_ConvCtorNonTrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public Const_ConvCtorNonTrivial(Const_ConvCtorNonTrivial _other) : this(new _ByValue_ConvCtorNonTrivial(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public Const_ConvCtorNonTrivial(ConvCtorNonTrivial _other) : this((Const_ConvCtorNonTrivial)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public unsafe Const_ConvCtorNonTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public static unsafe implicit operator Const_ConvCtorNonTrivial(int _1) {return new(_1);}
            }

            // Test how a non-trivial class with a converting constructor gets the additional conversion operators in its parameter passing helpers.
            /// <summary>
            /// Generated from class `MR::CSharp::ConvCtorNonTrivial`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ConvCtorNonTrivial : Const_ConvCtorNonTrivial
            {
                internal unsafe ConvCtorNonTrivial(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ConvCtorNonTrivial() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public unsafe ConvCtorNonTrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public ConvCtorNonTrivial(Const_ConvCtorNonTrivial _other) : this(new _ByValue_ConvCtorNonTrivial(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public ConvCtorNonTrivial(ConvCtorNonTrivial _other) : this((Const_ConvCtorNonTrivial)_other) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public unsafe ConvCtorNonTrivial(int _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_Construct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_Construct(int _1);
                    _UnderlyingPtr = __MR_CSharp_ConvCtorNonTrivial_Construct(_1);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public static unsafe implicit operator ConvCtorNonTrivial(int _1) {return new(_1);}

                /// <summary>
                /// Generated from method `MR::CSharp::ConvCtorNonTrivial::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConvCtorNonTrivial assign(MR.CS.CSharp._ByValue_ConvCtorNonTrivial _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConvCtorNonTrivial_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_ConvCtorNonTrivial_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_ConvCtorNonTrivial_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `ConvCtorNonTrivial` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_ConvCtorNonTrivial
            {
                internal readonly Const_ConvCtorNonTrivial? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ConvCtorNonTrivial() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_ConvCtorNonTrivial(Const_ConvCtorNonTrivial new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ConvCtorNonTrivial(Const_ConvCtorNonTrivial arg) {return new(arg);}
                public _ByValue_ConvCtorNonTrivial(MR.CS.Misc._Moved<ConvCtorNonTrivial> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ConvCtorNonTrivial(MR.CS.Misc._Moved<ConvCtorNonTrivial> arg) {return new(arg);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public static unsafe implicit operator _ByValue_ConvCtorNonTrivial(int _1) {return new MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivial>(_1);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorNonTrivial` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConvCtorNonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` directly.
            /// </summary>
            public class _InOptMut_ConvCtorNonTrivial
            {
                public ConvCtorNonTrivial? Opt;

                public _InOptMut_ConvCtorNonTrivial() {}
                public _InOptMut_ConvCtorNonTrivial(ConvCtorNonTrivial value) {Opt = value;}
                public static implicit operator _InOptMut_ConvCtorNonTrivial(ConvCtorNonTrivial value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ConvCtorNonTrivial` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConvCtorNonTrivial`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ConvCtorNonTrivial`/`Const_ConvCtorNonTrivial` to pass it to the function.
            /// </summary>
            public class _InOptConst_ConvCtorNonTrivial
            {
                public Const_ConvCtorNonTrivial? Opt;

                public _InOptConst_ConvCtorNonTrivial() {}
                public _InOptConst_ConvCtorNonTrivial(Const_ConvCtorNonTrivial value) {Opt = value;}
                public static implicit operator _InOptConst_ConvCtorNonTrivial(Const_ConvCtorNonTrivial value) {return new(value);}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ConvCtorNonTrivial::ConvCtorNonTrivial`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ConvCtorNonTrivial(int _1) {return new Const_ConvCtorNonTrivial(_1);}
            }

            // Exposed structs:
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_ExposedLayout : MR.CS.Misc.Object<ConstBox_ExposedLayout>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly ExposedLayout _Ref => ref *(ExposedLayout *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_ExposedLayout() {Dispose(false);}

                public ref readonly ushort x => ref _Ref.x;

                // This is field `y`!
                public ref readonly int y => ref _Ref.y;

                public ref readonly double z => ref _Ref.z;

                public ref readonly MR.CS.ArrayInt32T3 arr => ref _Ref.arr;

                public bool b => _Ref.b;

                public ref readonly MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_ExposedLayout(ExposedLayout other) : this(new ConstBox_ExposedLayout((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_ExposedLayout` has this conversion, `Box_ExposedLayout` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_ExposedLayout(ExposedLayout other) {return new(other);}

                internal unsafe ConstBox_ExposedLayout(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe ConstBox_ExposedLayout() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_ExposedLayout(ConstBox_ExposedLayout _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    *(MR.CS.CSharp.ExposedLayout *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayout *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::bar`.
                /// </summary>
                public unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_bar(_Underlying *_this);
                    __MR_CSharp_ExposedLayout_bar(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::blah`.
                /// </summary>
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_blah();
                    __MR_CSharp_ExposedLayout_blah();
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                /// </summary>
                public static unsafe Box_ExposedLayout operator++(MR.CS.CSharp.ConstBox_ExposedLayout _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_this);
                    Box_ExposedLayout __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                // Test how returning references to an exposed struct works, since C# overloaded operators can't return `ref`.
                // Note that this operator must be `const` to test this correctly, since we turn non-const operators in exposed structs into functions.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator*`.
                /// </summary>
                public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout> operator*(MR.CS.CSharp.ConstBox_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayout_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_mul_MR_CSharp_ExposedLayout_int32_t(MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_this, int _1);
                    return new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__MR_C_mul_MR_CSharp_ExposedLayout_int32_t(_this._UnderlyingPtr, _1));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                /// </summary>
                public static unsafe MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout> operator+(MR.CS.CSharp.ConstBox_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t(MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_this, int _1);
                    return new(__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t(_this._UnderlyingPtr, _1));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.ConstBox_ExposedLayout _this, MR.CS.CSharp.ConstBox_ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout(MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_this, MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayout(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ConstBox_ExposedLayout _this, MR.CS.CSharp.ConstBox_ExposedLayout _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ConstBox_ExposedLayout _this, MR.CS.CSharp.ConstBox_ExposedLayout _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ConstBox_ExposedLayout _this, MR.CS.CSharp.ConstBox_ExposedLayout _1)
                {
                    return !(_this < _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static unsafe int operator-(int _1, ConstBox_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_sub_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout _2);
                    return __MR_C_sub_int32_t_MR_CSharp_ExposedLayout(_1, _2._Ref);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator%`.
                /// </summary>
                public static unsafe int operator%(int _1, MR.CS.CSharp.ConstBox_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_mod_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_2);
                    return __MR_C_mod_int32_t_MR_CSharp_ExposedLayout(_1, _2._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(_Underlying *_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public static unsafe Box_ExposedLayout operator--(MR.CS.CSharp.ConstBox_ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ConstBox_ExposedLayout._Underlying *_1);
                    Box_ExposedLayout __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }
            }

            // Exposed structs:
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_ExposedLayout : ConstBox_ExposedLayout, System.IEquatable<float>
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref ExposedLayout _Ref => ref *(ExposedLayout *)_UnderlyingPtr;

                public new ref ushort x => ref _Ref.x;

                // This is field `y`!
                public new ref int y => ref _Ref.y;

                public new ref double z => ref _Ref.z;

                public new ref MR.CS.ArrayInt32T3 arr => ref _Ref.arr;

                public new bool b {get => _Ref.b; set => _Ref.b = value;}

                public new ref MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_ExposedLayout(ExposedLayout other) : this(new ConstBox_ExposedLayout((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_ExposedLayout(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe Box_ExposedLayout() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_ExposedLayout(ConstBox_ExposedLayout _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(56);
                    *(MR.CS.CSharp.ExposedLayout *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayout *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_ExposedLayout _other) {_Ref = _other._Ref;}

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_foo(_Underlying *_this);
                    __MR_CSharp_ExposedLayout_foo(_UnderlyingPtr);
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(_Underlying *_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.Box_ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t(MR.CS.CSharp.Box_ExposedLayout._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t(_this._UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.Box_ExposedLayout _this, float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayout_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayout_float(MR.CS.CSharp.Box_ExposedLayout._Underlying *_this, float _1);
                    return __MR_C_equal_MR_CSharp_ExposedLayout_float(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Box_ExposedLayout _this, float _1)
                {
                    return !(_this == _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                /// </summary>
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout_char(_Underlying *_this, byte _1);
                    return __MR_C_less_MR_CSharp_ExposedLayout_char(_UnderlyingPtr, _1) != 0;
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator/`.
                /// </summary>
                public static unsafe int operator/(int _1, MR.CS.CSharp.Box_ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_div_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.Box_ExposedLayout._Underlying *_2);
                    return __MR_C_div_int32_t_MR_CSharp_ExposedLayout(_1, _2._UnderlyingPtr);
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this == (float)other;
                    return false;
                }
            }

            // Exposed structs:
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayout`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 56)]
            public struct ExposedLayout : System.IEquatable<float>
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public ushort x;

                // This is field `y`!
                [System.Runtime.InteropServices.FieldOffset(4)]
                public int y;

                [System.Runtime.InteropServices.FieldOffset(8)]
                public double z;

                [System.Runtime.InteropServices.FieldOffset(16)]
                public MR.CS.ArrayInt32T3 arr;

                public bool b {get => __storage_b != 0; set => __storage_b = value ? (byte)1 : (byte)0;}
                [System.Runtime.InteropServices.FieldOffset(28)]
                byte __storage_b;

                [System.Runtime.InteropServices.FieldOffset(29)]
                public MR.CS.ArrayBool4_5 ba;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator ExposedLayout(ConstBox_ExposedLayout other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public ExposedLayout(ExposedLayout _other) {this = _other;}

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_foo(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayout_foo(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::bar`.
                /// </summary>
                public readonly unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_bar(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayout_bar(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::blah`.
                /// </summary>
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayout_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayout_blah();
                    __MR_CSharp_ExposedLayout_blah();
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *_this);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        __MR_C_incr_MR_CSharp_ExposedLayout(__ptr__this);
                    }
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator++`.
                /// </summary>
                public unsafe ExposedLayout incr(MR.CS.CSharp.ExposedLayout _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayout(ExposedLayout *_this);
                    ExposedLayout __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayout(&__this_copy);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                /// </summary>
                public unsafe int add(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_add_MR_CSharp_ExposedLayout_ref_int32_t(__ptr__this, _1);
                    }
                }

                // Test how returning references to an exposed struct works, since C# overloaded operators can't return `ref`.
                // Note that this operator must be `const` to test this correctly, since we turn non-const operators in exposed structs into functions.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator*`.
                /// </summary>
                public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout> operator*(MR.CS.CSharp.ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayout_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_mul_MR_CSharp_ExposedLayout_int32_t(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    return new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__MR_C_mul_MR_CSharp_ExposedLayout_int32_t(&_this, _1));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator+`.
                /// </summary>
                public static unsafe MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout> operator+(MR.CS.CSharp.ExposedLayout _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t(MR.CS.CSharp.ExposedLayout *_this, int _1);
                    return new(__MR_C_add_const_MR_CSharp_ExposedLayout_ref_int32_t(&_this, _1));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *_this, MR.CS.CSharp.ExposedLayout *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayout(&_this, &_1) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ExposedLayout _this, MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this < _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator==`.
                /// </summary>
                public unsafe bool equal(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayout_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayout_float(MR.CS.CSharp.ExposedLayout *_this, float _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayout_float(__ptr__this, _1) != 0;
                    }
                }

                public unsafe bool notEqual(float _1)
                {
                    return !this.equal(_1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayout::operator<`.
                /// </summary>
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayout_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayout_char(MR.CS.CSharp.ExposedLayout *_this, byte _1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__this = &this)
                    {
                        return __MR_C_less_MR_CSharp_ExposedLayout_char(__ptr__this, _1) != 0;
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static int operator-(int _1, MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_sub_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout _2);
                    return __MR_C_sub_int32_t_MR_CSharp_ExposedLayout(_1, _2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator/`.
                /// </summary>
                public static unsafe int div(int _1, ref MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_div_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout *_2);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__2 = &_2)
                    {
                        return __MR_C_div_int32_t_MR_CSharp_ExposedLayout(_1, __ptr__2);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator%`.
                /// </summary>
                public static unsafe int operator%(int _1, MR.CS.CSharp.ExposedLayout _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int32_t_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static int __MR_C_mod_int32_t_MR_CSharp_ExposedLayout(int _1, MR.CS.CSharp.ExposedLayout *_2);
                    return __MR_C_mod_int32_t_MR_CSharp_ExposedLayout(_1, &_2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout _1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(this);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public static ExposedLayout operator--(MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout _1);
                    ExposedLayout __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayout(__this_copy);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this.equal(_1);
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this.Equals((float)other);
                    return false;
                }
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_ExposedLayout` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_ExposedLayout`/`ConstBox_ExposedLayout` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_ExposedLayout
            {
                public readonly bool HasValue;
                internal readonly ExposedLayout Object;
                public ExposedLayout Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayout() {HasValue = false;}
                public _InOpt_ExposedLayout(ExposedLayout new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayout(ExposedLayout new_value) {return new(new_value);}
                public _InOpt_ExposedLayout(ConstBox_ExposedLayout new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayout(ConstBox_ExposedLayout new_value) {return new(new_value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayout` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayout`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayout`/`ConstBox_ExposedLayout` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayout`.
            /// </summary>
            public class _InOptMut_ExposedLayout
            {
                public Box_ExposedLayout? Opt;

                public _InOptMut_ExposedLayout() {}
                public _InOptMut_ExposedLayout(Box_ExposedLayout value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayout(Box_ExposedLayout value) {return new(value);}
                public unsafe _InOptMut_ExposedLayout(ref ExposedLayout value)
                {
                    fixed (ExposedLayout *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayout._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayout` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayout`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayout`/`ConstBox_ExposedLayout` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayout`.
            /// </summary>
            public class _InOptConst_ExposedLayout
            {
                public ConstBox_ExposedLayout? Opt;

                public _InOptConst_ExposedLayout() {}
                public _InOptConst_ExposedLayout(ConstBox_ExposedLayout value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayout(ConstBox_ExposedLayout value) {return new(value);}
                public unsafe _InOptConst_ExposedLayout(ref readonly ExposedLayout value)
                {
                    fixed (ExposedLayout *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayout._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            // This one is backed by a shared pointer.
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_ExposedLayoutSh : MR.CS.Misc.SharedObject<ConstBox_ExposedLayoutSh>, System.IDisposable, System.IEquatable<MR.CS.CSharp.ExposedLayout>, System.IEquatable<MR.CS.CSharp.ConstBox_ExposedLayoutSh>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.
                internal struct _UnderlyingShared {} // Represents the underlying shared pointer C++ type.

                internal unsafe _UnderlyingShared *_UnderlyingSharedPtr;
                internal unsafe _Underlying *_UnderlyingPtr
                {
                    get
                    {
                        System.Diagnostics.Trace.Assert(_SharedPtrIsNotNull, "Internal error: This object holds a null shared pointer.");
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get", ExactSpelling = true)]
                        extern static _Underlying *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get(_UnderlyingSharedPtr);
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is owning or not.
                /// </summary>
                public override unsafe bool _IsOwning
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_use_count", ExactSpelling = true)]
                        extern static int __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_use_count(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_use_count(_UnderlyingSharedPtr) > 0;
                    }
                }

                /// <summary>
                /// Check if the underlying shared pointer is non-null.
                /// If this returns null, calling any member other than `.Assign()` on this object will assert.
                /// </summary>
                private unsafe bool _SharedPtrIsNotNull
                {
                    get
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get", ExactSpelling = true)]
                        extern static void *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get(_UnderlyingShared *_this);
                        return __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_get(_UnderlyingSharedPtr) is not null;
                    }
                }

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly ExposedLayoutSh _Ref => ref *(ExposedLayoutSh *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingSharedPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy", ExactSpelling = true)]
                    extern static void __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy(_UnderlyingShared *_this);
                    __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Destroy(_UnderlyingSharedPtr);
                    _UnderlyingSharedPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_ExposedLayoutSh() {Dispose(false);}

                public ref readonly ushort x => ref _Ref.x;

                // This is field `y`!
                public ref readonly int y => ref _Ref.y;

                public ref readonly double z => ref _Ref.z;

                public ref readonly MR.CS.ArrayInt32T3 arr => ref _Ref.arr;

                public bool b => _Ref.b;

                public ref readonly MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_ExposedLayoutSh(ExposedLayoutSh other) : this(new ConstBox_ExposedLayoutSh((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_ExposedLayoutSh` has this conversion, `Box_ExposedLayoutSh` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_ExposedLayoutSh(ExposedLayoutSh other) {return new(other);}

                internal unsafe ConstBox_ExposedLayoutSh(_Underlying *ptr, bool is_owning) : base(true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(_Underlying *other);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning(_Underlying *other);
                    if (is_owning)
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(ptr);
                    else
                        _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructNonOwning(ptr);
                }

                internal unsafe ConstBox_ExposedLayoutSh(_UnderlyingShared *shared_ptr, bool is_owning) : base(is_owning) {_UnderlyingSharedPtr = shared_ptr;}

                internal static unsafe Box_ExposedLayoutSh _MakeAliasing(MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing(MR.CS.Misc._PassBy ownership_pass_by, MR.CS.Std.Const_SharedPtr_ConstVoid._Underlying *ownership, _Underlying *ptr);
                    return new(__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_ConstructAliasing(MR.CS.Misc._PassBy.copy, ownership, ptr), is_owning: true);
                }

                private protected unsafe void _LateMakeShared(_Underlying *ptr)
                {
                    System.Diagnostics.Trace.Assert(_IsOwningVal == true);
                    System.Diagnostics.Trace.Assert(_UnderlyingSharedPtr is null);
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct", ExactSpelling = true)]
                    extern static _UnderlyingShared *__MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(_Underlying *other);
                    _UnderlyingSharedPtr = __MR_C_std_shared_ptr_MR_CSharp_ExposedLayoutSh_Construct(ptr);
                }

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe ConstBox_ExposedLayoutSh() : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_ExposedLayoutSh(ConstBox_ExposedLayoutSh _other) : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    *(MR.CS.CSharp.ExposedLayoutSh *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayoutSh *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::bar`.
                /// </summary>
                public unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_bar(_Underlying *_this);
                    __MR_CSharp_ExposedLayoutSh_bar(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::blah`.
                /// </summary>
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_blah();
                    __MR_CSharp_ExposedLayoutSh_blah();
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                /// </summary>
                public static unsafe Box_ExposedLayoutSh operator++(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_this);
                    Box_ExposedLayoutSh __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator*`.
                /// </summary>
                public static unsafe int operator*(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_this, int _1);
                    return __MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t(_this._UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    return !(_this < _1);
                }

                // While we're at it, test comparison against another exposed struct, since this is apparently non-trivial.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.ExposedLayout *_1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__1 = &_1)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(_this._UnderlyingPtr, __ptr__1) != 0;
                    }
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this == _1);
                }

                // And against itself, too.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_this, MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh(_this._UnderlyingPtr, _1._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ConstBox_ExposedLayoutSh _this, MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    return !(_this == _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static unsafe int operator-(int _1, ConstBox_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh _2);
                    return __MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh(_1, _2._Ref);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator%`.
                /// </summary>
                public static unsafe int operator%(int _1, MR.CS.CSharp.ConstBox_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_2);
                    return __MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh(_1, _2._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public unsafe void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(_Underlying *_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public static unsafe Box_ExposedLayoutSh operator--(MR.CS.CSharp.ConstBox_ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ConstBox_ExposedLayoutSh._Underlying *_1);
                    Box_ExposedLayoutSh __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(__this_copy._UnderlyingPtr);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.ExposedLayout _1)
                {
                    return this == (MR.CS.CSharp.ExposedLayout)_1;
                }

                public bool Equals(MR.CS.CSharp.ConstBox_ExposedLayoutSh? _1)
                {
                    if (_1 is null)
                        return false;
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.ExposedLayout)
                        return this == (MR.CS.CSharp.ExposedLayout)other;
                    if (other is MR.CS.CSharp.ConstBox_ExposedLayoutSh)
                        return this == (MR.CS.CSharp.ConstBox_ExposedLayoutSh)other;
                    return false;
                }
            }

            // This one is backed by a shared pointer.
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_ExposedLayoutSh : ConstBox_ExposedLayoutSh, System.IEquatable<float>
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref ExposedLayoutSh _Ref => ref *(ExposedLayoutSh *)_UnderlyingPtr;

                public new ref ushort x => ref _Ref.x;

                // This is field `y`!
                public new ref int y => ref _Ref.y;

                public new ref double z => ref _Ref.z;

                public new ref MR.CS.ArrayInt32T3 arr => ref _Ref.arr;

                public new bool b {get => _Ref.b; set => _Ref.b = value;}

                public new ref MR.CS.ArrayBool4_5 ba => ref _Ref.ba;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_ExposedLayoutSh(ExposedLayoutSh other) : this(new ConstBox_ExposedLayoutSh((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_ExposedLayoutSh(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                internal unsafe Box_ExposedLayoutSh(_UnderlyingShared *shared_ptr, bool is_owning) : base(shared_ptr, is_owning) {}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe Box_ExposedLayoutSh() : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 56, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_ExposedLayoutSh(ConstBox_ExposedLayoutSh _other) : this(shared_ptr: null, is_owning: true)
                {
                    _LateMakeShared((_Underlying *)MR.CS.Misc._Alloc(56));
                    *(MR.CS.CSharp.ExposedLayoutSh *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayoutSh *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_ExposedLayoutSh _other) {_Ref = _other._Ref;}

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_foo(_Underlying *_this);
                    __MR_CSharp_ExposedLayoutSh_foo(_UnderlyingPtr);
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(_Underlying *_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.Box_ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t(MR.CS.CSharp.Box_ExposedLayoutSh._Underlying *_this, int _1);
                    return __MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t(_this._UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.Box_ExposedLayoutSh _this, float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(MR.CS.CSharp.Box_ExposedLayoutSh._Underlying *_this, float _1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(_this._UnderlyingPtr, _1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.Box_ExposedLayoutSh _this, float _1)
                {
                    return !(_this == _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                /// </summary>
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh_char(_Underlying *_this, byte _1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh_char(_UnderlyingPtr, _1) != 0;
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator/`.
                /// </summary>
                public static unsafe int operator/(int _1, MR.CS.CSharp.Box_ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.Box_ExposedLayoutSh._Underlying *_2);
                    return __MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh(_1, _2._UnderlyingPtr);
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this == (float)other;
                    return base.Equals(other);
                }
            }

            // This one is backed by a shared pointer.
            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutSh`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 56)]
            public struct ExposedLayoutSh : System.IEquatable<float>, System.IEquatable<MR.CS.CSharp.ExposedLayout>, System.IEquatable<MR.CS.CSharp.ExposedLayoutSh>
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public ushort x;

                // This is field `y`!
                [System.Runtime.InteropServices.FieldOffset(4)]
                public int y;

                [System.Runtime.InteropServices.FieldOffset(8)]
                public double z;

                [System.Runtime.InteropServices.FieldOffset(16)]
                public MR.CS.ArrayInt32T3 arr;

                public bool b {get => __storage_b != 0; set => __storage_b = value ? (byte)1 : (byte)0;}
                [System.Runtime.InteropServices.FieldOffset(28)]
                byte __storage_b;

                [System.Runtime.InteropServices.FieldOffset(29)]
                public MR.CS.ArrayBool4_5 ba;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator ExposedLayoutSh(ConstBox_ExposedLayoutSh other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public ExposedLayoutSh(ExposedLayoutSh _other) {this = _other;}

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::foo`.
                /// </summary>
                public unsafe void foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_foo", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_foo(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayoutSh_foo(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::bar`.
                /// </summary>
                public readonly unsafe void bar()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_bar(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_CSharp_ExposedLayoutSh_bar(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::blah`.
                /// </summary>
                public static void blah()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutSh_blah", ExactSpelling = true)]
                    extern static void __MR_CSharp_ExposedLayoutSh_blah();
                    __MR_CSharp_ExposedLayoutSh_blah();
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                /// </summary>
                public unsafe void incr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        __MR_C_incr_MR_CSharp_ExposedLayoutSh(__ptr__this);
                    }
                }

                // Try some jank operators.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator++`.
                /// </summary>
                public unsafe ExposedLayoutSh incr(MR.CS.CSharp.ExposedLayoutSh _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_incr_MR_CSharp_ExposedLayoutSh(ExposedLayoutSh *_this);
                    ExposedLayoutSh __this_copy = new(_this);
                    __MR_C_incr_MR_CSharp_ExposedLayoutSh(&__this_copy);
                    return __this_copy;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator+`.
                /// </summary>
                public unsafe int add(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t(MR.CS.CSharp.ExposedLayoutSh *_this, int _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_add_MR_CSharp_ExposedLayoutSh_int32_t(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator*`.
                /// </summary>
                public static unsafe int operator*(MR.CS.CSharp.ExposedLayoutSh _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t(MR.CS.CSharp.ExposedLayoutSh *_this, int _1);
                    return __MR_C_mul_MR_CSharp_ExposedLayoutSh_int32_t(&_this, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                /// </summary>
                public static unsafe bool operator<(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayoutSh *_1);
                    return __MR_C_less_MR_CSharp_ExposedLayoutSh(&_this, &_1) != 0;
                }

                public static unsafe bool operator>(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return _1 < _this;
                }

                public static unsafe bool operator<=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_1 < _this);
                }

                public static unsafe bool operator>=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_this < _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public unsafe bool equal(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_float", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(MR.CS.CSharp.ExposedLayoutSh *_this, float _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_float(__ptr__this, _1) != 0;
                    }
                }

                public unsafe bool notEqual(float _1)
                {
                    return !this.equal(_1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator<`.
                /// </summary>
                public unsafe bool less(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_less_MR_CSharp_ExposedLayoutSh_char", ExactSpelling = true)]
                    extern static byte __MR_C_less_MR_CSharp_ExposedLayoutSh_char(MR.CS.CSharp.ExposedLayoutSh *_this, byte _1);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__this = &this)
                    {
                        return __MR_C_less_MR_CSharp_ExposedLayoutSh_char(__ptr__this, _1) != 0;
                    }
                }

                // While we're at it, test comparison against another exposed struct, since this is apparently non-trivial.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayout *_1);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr__1 = &_1)
                    {
                        return __MR_C_equal_MR_CSharp_ExposedLayoutSh_MR_CSharp_ExposedLayout(&_this, __ptr__1) != 0;
                    }
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutSh _this, in MR.CS.CSharp.ExposedLayout _1)
                {
                    return !(_this == _1);
                }

                // And against itself, too.
                /// <summary>
                /// Generated from method `MR::CSharp::ExposedLayoutSh::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *_this, MR.CS.CSharp.ExposedLayoutSh *_1);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutSh(&_this, &_1) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutSh _this, MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return !(_this == _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static int operator-(int _1, MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh _2);
                    return __MR_C_sub_int32_t_MR_CSharp_ExposedLayoutSh(_1, _2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator/`.
                /// </summary>
                public static unsafe int div(int _1, ref MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh *_2);
                    fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr__2 = &_2)
                    {
                        return __MR_C_div_int32_t_MR_CSharp_ExposedLayoutSh(_1, __ptr__2);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator%`.
                /// </summary>
                public static unsafe int operator%(int _1, MR.CS.CSharp.ExposedLayoutSh _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static int __MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh(int _1, MR.CS.CSharp.ExposedLayoutSh *_2);
                    return __MR_C_mod_int32_t_MR_CSharp_ExposedLayoutSh(_1, &_2);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public void decr()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh _1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(this);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator--`.
                /// </summary>
                public static ExposedLayoutSh operator--(MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_decr_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                    extern static void __MR_C_decr_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh _1);
                    ExposedLayoutSh __this_copy = new(_1);
                    __MR_C_decr_MR_CSharp_ExposedLayoutSh(__this_copy);
                    return __this_copy;
                }

                // IEquatable:

                public bool Equals(float _1)
                {
                    return this.equal(_1);
                }

                public bool Equals(MR.CS.CSharp.ExposedLayout _1)
                {
                    return this == (MR.CS.CSharp.ExposedLayout)_1;
                }

                public bool Equals(MR.CS.CSharp.ExposedLayoutSh _1)
                {
                    return this == _1;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is float)
                        return this.Equals((float)other);
                    if (other is MR.CS.CSharp.ExposedLayout)
                        return this == (MR.CS.CSharp.ExposedLayout)other;
                    if (other is MR.CS.CSharp.ExposedLayoutSh)
                        return this == (MR.CS.CSharp.ExposedLayoutSh)other;
                    return false;
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `Box_ExposedLayoutSh` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `Box_ExposedLayoutSh`/`ConstBox_ExposedLayoutSh` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValueShared_ExposedLayoutSh
            {
                internal readonly ConstBox_ExposedLayoutSh? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValueShared_ExposedLayoutSh() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValueShared_ExposedLayoutSh(ConstBox_ExposedLayoutSh new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValueShared_ExposedLayoutSh(ConstBox_ExposedLayoutSh arg) {return new(arg);}
                public _ByValueShared_ExposedLayoutSh(MR.CS.Misc._Moved<Box_ExposedLayoutSh> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValueShared_ExposedLayoutSh(MR.CS.Misc._Moved<Box_ExposedLayoutSh> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_ExposedLayoutSh` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_ExposedLayoutSh`/`ConstBox_ExposedLayoutSh` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_ExposedLayoutSh
            {
                public readonly bool HasValue;
                internal readonly ExposedLayoutSh Object;
                public ExposedLayoutSh Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayoutSh() {HasValue = false;}
                public _InOpt_ExposedLayoutSh(ExposedLayoutSh new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayoutSh(ExposedLayoutSh new_value) {return new(new_value);}
                public _InOpt_ExposedLayoutSh(ConstBox_ExposedLayoutSh new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayoutSh(ConstBox_ExposedLayoutSh new_value) {return new(new_value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayoutSh` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayoutSh`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayoutSh`/`ConstBox_ExposedLayoutSh` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutSh`.
            /// </summary>
            public class _InOptMut_ExposedLayoutSh
            {
                public Box_ExposedLayoutSh? Opt;

                public _InOptMut_ExposedLayoutSh() {}
                public _InOptMut_ExposedLayoutSh(Box_ExposedLayoutSh value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayoutSh(Box_ExposedLayoutSh value) {return new(value);}
                public unsafe _InOptMut_ExposedLayoutSh(ref ExposedLayoutSh value)
                {
                    fixed (ExposedLayoutSh *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayoutSh._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayoutSh` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayoutSh`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayoutSh`/`ConstBox_ExposedLayoutSh` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutSh`.
            /// </summary>
            public class _InOptConst_ExposedLayoutSh
            {
                public ConstBox_ExposedLayoutSh? Opt;

                public _InOptConst_ExposedLayoutSh() {}
                public _InOptConst_ExposedLayoutSh(ConstBox_ExposedLayoutSh value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayoutSh(ConstBox_ExposedLayoutSh value) {return new(value);}
                public unsafe _InOptConst_ExposedLayoutSh(ref readonly ExposedLayoutSh value)
                {
                    fixed (ExposedLayoutSh *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayoutSh._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_ExposedLayoutB : MR.CS.Misc.Object<ConstBox_ExposedLayoutB>, System.IDisposable, System.IEquatable<MR.CS.CSharp.ConstBox_ExposedLayoutB>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly ExposedLayoutB _Ref => ref *(ExposedLayoutB *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_ExposedLayoutB() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_ExposedLayoutB(ExposedLayoutB other) : this(new ConstBox_ExposedLayoutB((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_ExposedLayoutB` has this conversion, `Box_ExposedLayoutB` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_ExposedLayoutB(ExposedLayoutB other) {return new(other);}

                internal unsafe ConstBox_ExposedLayoutB(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_ExposedLayoutB(ConstBox_ExposedLayoutB _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayoutB *)_other._UnderlyingPtr;
                }

                // Some random ctor.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe ConstBox_ExposedLayoutB(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_2", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_2(int _1, int _2);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = __MR_CSharp_ExposedLayoutB_Construct_2(_1, _2);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe ConstBox_ExposedLayoutB(MR.CS.CSharp.Const_A _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_1", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_1(MR.CS.CSharp.Const_A._Underlying *_1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = __MR_CSharp_ExposedLayoutB_Construct_1(_1._UnderlyingPtr);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public static unsafe implicit operator ConstBox_ExposedLayoutB(MR.CS.CSharp.Const_A _1) {return new(_1);}

                // And try an equality comparison!
                /// <summary>
                /// Generated from function `MR::CSharp::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ConstBox_ExposedLayoutB _1, MR.CS.CSharp.ConstBox_ExposedLayoutB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutB", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutB(MR.CS.CSharp.ConstBox_ExposedLayoutB._Underlying *_1, MR.CS.CSharp.ConstBox_ExposedLayoutB._Underlying *_2);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutB(_1._UnderlyingPtr, _2._UnderlyingPtr) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ConstBox_ExposedLayoutB _1, MR.CS.CSharp.ConstBox_ExposedLayoutB _2)
                {
                    return !(_1 == _2);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.ConstBox_ExposedLayoutB? _2)
                {
                    if (_2 is null)
                        return false;
                    return this == _2;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.ConstBox_ExposedLayoutB)
                        return this == (MR.CS.CSharp.ConstBox_ExposedLayoutB)other;
                    return false;
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_ExposedLayoutB : ConstBox_ExposedLayoutB
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref ExposedLayoutB _Ref => ref *(ExposedLayoutB *)_UnderlyingPtr;

                public new ref int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_ExposedLayoutB(ExposedLayoutB other) : this(new ConstBox_ExposedLayoutB((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_ExposedLayoutB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_ExposedLayoutB(ConstBox_ExposedLayoutB _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = *(MR.CS.CSharp.ExposedLayoutB *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_ExposedLayoutB _other) {_Ref = _other._Ref;}

                // Some random ctor.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe Box_ExposedLayoutB(int _1, int _2) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_2", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_2(int _1, int _2);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = __MR_CSharp_ExposedLayoutB_Construct_2(_1, _2);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe Box_ExposedLayoutB(MR.CS.CSharp.Const_A _1) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_1", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_1(MR.CS.CSharp.Const_A._Underlying *_1);
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ExposedLayoutB *)_UnderlyingPtr = __MR_CSharp_ExposedLayoutB_Construct_1(_1._UnderlyingPtr);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public static unsafe implicit operator Box_ExposedLayoutB(MR.CS.CSharp.Const_A _1) {return new(_1);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ExposedLayoutB`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ExposedLayoutB : System.IEquatable<MR.CS.CSharp.ExposedLayoutB>
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator ExposedLayoutB(ConstBox_ExposedLayoutB other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public ExposedLayoutB(ExposedLayoutB _other) {this = _other;}

                // Some random ctor.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe ExposedLayoutB(int _1, int _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_2", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_2(int _1, int _2);
                    this = __MR_CSharp_ExposedLayoutB_Construct_2(_1, _2);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public unsafe ExposedLayoutB(MR.CS.CSharp.Const_A _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ExposedLayoutB_Construct_1", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayoutB __MR_CSharp_ExposedLayoutB_Construct_1(MR.CS.CSharp.Const_A._Underlying *_1);
                    this = __MR_CSharp_ExposedLayoutB_Construct_1(_1._UnderlyingPtr);
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public static unsafe implicit operator ExposedLayoutB(MR.CS.CSharp.Const_A _1) {return new(_1);}

                // And try an equality comparison!
                /// <summary>
                /// Generated from function `MR::CSharp::operator==`.
                /// </summary>
                public static unsafe bool operator==(MR.CS.CSharp.ExposedLayoutB _1, MR.CS.CSharp.ExposedLayoutB _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_ExposedLayoutB", ExactSpelling = true)]
                    extern static byte __MR_C_equal_MR_CSharp_ExposedLayoutB(MR.CS.CSharp.ExposedLayoutB *_1, MR.CS.CSharp.ExposedLayoutB *_2);
                    return __MR_C_equal_MR_CSharp_ExposedLayoutB(&_1, &_2) != 0;
                }

                public static unsafe bool operator!=(MR.CS.CSharp.ExposedLayoutB _1, MR.CS.CSharp.ExposedLayoutB _2)
                {
                    return !(_1 == _2);
                }

                // IEquatable:

                public bool Equals(MR.CS.CSharp.ExposedLayoutB _2)
                {
                    return this == _2;
                }

                public override bool Equals(object? other)
                {
                    if (other is null)
                        return false;
                    if (other is MR.CS.CSharp.ExposedLayoutB)
                        return this == (MR.CS.CSharp.ExposedLayoutB)other;
                    return false;
                }
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_ExposedLayoutB` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_ExposedLayoutB`/`ConstBox_ExposedLayoutB` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_ExposedLayoutB
            {
                public readonly bool HasValue;
                internal readonly ExposedLayoutB Object;
                public ExposedLayoutB Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ExposedLayoutB() {HasValue = false;}
                public _InOpt_ExposedLayoutB(ExposedLayoutB new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ExposedLayoutB(ExposedLayoutB new_value) {return new(new_value);}
                public _InOpt_ExposedLayoutB(ConstBox_ExposedLayoutB new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ExposedLayoutB(ConstBox_ExposedLayoutB new_value) {return new(new_value);}

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public static unsafe implicit operator _InOpt_ExposedLayoutB(MR.CS.CSharp.Const_A _1) {return new ConstBox_ExposedLayoutB(_1);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayoutB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ExposedLayoutB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayoutB`/`ConstBox_ExposedLayoutB` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutB`.
            /// </summary>
            public class _InOptMut_ExposedLayoutB
            {
                public Box_ExposedLayoutB? Opt;

                public _InOptMut_ExposedLayoutB() {}
                public _InOptMut_ExposedLayoutB(Box_ExposedLayoutB value) {Opt = value;}
                public static implicit operator _InOptMut_ExposedLayoutB(Box_ExposedLayoutB value) {return new(value);}
                public unsafe _InOptMut_ExposedLayoutB(ref ExposedLayoutB value)
                {
                    fixed (ExposedLayoutB *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayoutB._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ExposedLayoutB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ExposedLayoutB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ExposedLayoutB`/`ConstBox_ExposedLayoutB` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ExposedLayoutB`.
            /// </summary>
            public class _InOptConst_ExposedLayoutB
            {
                public ConstBox_ExposedLayoutB? Opt;

                public _InOptConst_ExposedLayoutB() {}
                public _InOptConst_ExposedLayoutB(ConstBox_ExposedLayoutB value) {Opt = value;}
                public static implicit operator _InOptConst_ExposedLayoutB(ConstBox_ExposedLayoutB value) {return new(value);}
                public unsafe _InOptConst_ExposedLayoutB(ref readonly ExposedLayoutB value)
                {
                    fixed (ExposedLayoutB *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ExposedLayoutB._Underlying *)value_ptr, is_owning: false);
                    }
                }

                // This gets a lifetime annotation from `--infer-lifetime-constructors`, but it should be a no-op in an exposed struct.
                /// <summary>
                /// Generated from constructor `MR::CSharp::ExposedLayoutB::ExposedLayoutB`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_ExposedLayoutB(MR.CS.CSharp.Const_A _1) {return new ConstBox_ExposedLayoutB(_1);}
            }

            // Test various array members.
            /// <summary>
            /// Generated from class `MR::CSharp::ArrayMembers`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ArrayMembers : MR.CS.Misc.Object<Const_ArrayMembers>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ArrayMembers_Destroy(_Underlying *_this);
                    __MR_CSharp_ArrayMembers_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ArrayMembers() {Dispose(false);}

                public unsafe int i => *__ref_storage_i;
                private protected unsafe int *__ref_storage_i;

                public unsafe ref MR.CS.ArrayInt32T2 ia => ref *(__array_storage_ia);
                private protected unsafe MR.CS.ArrayInt32T2 *__array_storage_ia;

                public unsafe ref MR.CS.ArrayInt32T3_4 iaa => ref *(__array_storage_iaa);
                private protected unsafe MR.CS.ArrayInt32T3_4 *__array_storage_iaa;

                public unsafe int ci => *__ref_storage_ci;
                private protected unsafe int *__ref_storage_ci;

                public unsafe ref readonly MR.CS.ConstArrayInt32T2 cia => ref *(__array_storage_cia);
                private protected unsafe MR.CS.ConstArrayInt32T2 *__array_storage_cia;

                public unsafe ref readonly MR.CS.ConstArrayInt32T3_4 ciaa => ref *(__array_storage_ciaa);
                private protected unsafe MR.CS.ConstArrayInt32T3_4 *__array_storage_ciaa;

                public unsafe MR.CS.Std.Const_String s {get; private protected set;}

                public unsafe MR.CS.Std.ArrayString2 sa {get; private protected set;}

                // std::string saa[3][4]; // The C generator doesn't support those yet. We'd need to expose them as flat arrays, with N size getters, I think?
                public unsafe MR.CS.Std.Const_String cs {get; private protected set;}

                public unsafe MR.CS.Std.ConstArrayString2 csa {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // i (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_i", ExactSpelling = true)]
                        extern static int *__MR_CSharp_ArrayMembers_Get_i(MR.CS.CSharp.Const_ArrayMembers._Underlying *_this);
                        this.__ref_storage_i = __MR_CSharp_ArrayMembers_Get_i(_UnderlyingPtr);
                    }

                    { // ia (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ia", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T2 *__MR_CSharp_ArrayMembers_Get_ia(_Underlying *_this);
                        this.__array_storage_ia = __MR_CSharp_ArrayMembers_Get_ia(_UnderlyingPtr);
                    }

                    { // iaa (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_iaa", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3_4 *__MR_CSharp_ArrayMembers_Get_iaa(_Underlying *_this);
                        this.__array_storage_iaa = __MR_CSharp_ArrayMembers_Get_iaa(_UnderlyingPtr);
                    }

                    { // ci (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ci", ExactSpelling = true)]
                        extern static int *__MR_CSharp_ArrayMembers_Get_ci(MR.CS.CSharp.Const_ArrayMembers._Underlying *_this);
                        this.__ref_storage_ci = __MR_CSharp_ArrayMembers_Get_ci(_UnderlyingPtr);
                    }

                    { // cia (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_cia", ExactSpelling = true)]
                        extern static MR.CS.ConstArrayInt32T2 *__MR_CSharp_ArrayMembers_Get_cia(_Underlying *_this);
                        this.__array_storage_cia = __MR_CSharp_ArrayMembers_Get_cia(_UnderlyingPtr);
                    }

                    { // ciaa (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_ciaa", ExactSpelling = true)]
                        extern static MR.CS.ConstArrayInt32T3_4 *__MR_CSharp_ArrayMembers_Get_ciaa(_Underlying *_this);
                        this.__array_storage_ciaa = __MR_CSharp_ArrayMembers_Get_ciaa(_UnderlyingPtr);
                    }

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_s", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_s(MR.CS.CSharp.Const_ArrayMembers._Underlying *_this);
                        this.s = new(__MR_CSharp_ArrayMembers_Get_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }

                    { // sa (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_Get_sa(_Underlying *_this);
                        this.sa = new(__MR_CSharp_ArrayMembers_Get_sa(_UnderlyingPtr));
                    }

                    { // cs
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_cs", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_cs(MR.CS.CSharp.Const_ArrayMembers._Underlying *_this);
                        this.cs = new(__MR_CSharp_ArrayMembers_Get_cs(_UnderlyingPtr), is_owning: false);
                        this.cs._KeepAliveEnclosingObject = this;
                    }

                    { // csa (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_Get_csa", ExactSpelling = true)]
                        extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_ArrayMembers_Get_csa(_Underlying *_this);
                        this.csa = new(__MR_CSharp_ArrayMembers_Get_csa(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_ArrayMembers(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_ArrayMembers() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public unsafe Const_ArrayMembers(MR.CS.CSharp._ByValue_ArrayMembers _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ArrayMembers._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public Const_ArrayMembers(Const_ArrayMembers _other) : this(new _ByValue_ArrayMembers(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public Const_ArrayMembers(ArrayMembers _other) : this((Const_ArrayMembers)_other) {}
            }

            // Test various array members.
            /// <summary>
            /// Generated from class `MR::CSharp::ArrayMembers`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ArrayMembers : Const_ArrayMembers
            {
                public new unsafe ref int i => ref *__ref_storage_i;

                new public unsafe ref MR.CS.ArrayInt32T2 ia => ref *(__array_storage_ia);

                new public unsafe ref MR.CS.ArrayInt32T3_4 iaa => ref *(__array_storage_iaa);

                public new unsafe MR.CS.Std.String s {get; private protected set;}

                new public unsafe MR.CS.Std.ArrayString2 sa {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // s
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_s", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_GetMutable_s(MR.CS.CSharp.ArrayMembers._Underlying *_this);
                        this.s = new(__MR_CSharp_ArrayMembers_GetMutable_s(_UnderlyingPtr), is_owning: false);
                        this.s._KeepAliveEnclosingObject = this;
                    }

                    { // sa (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_GetMutable_sa", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_ArrayMembers_GetMutable_sa(_Underlying *_this);
                        this.sa = new(__MR_CSharp_ArrayMembers_GetMutable_sa(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe ArrayMembers(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe ArrayMembers() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public unsafe ArrayMembers(MR.CS.CSharp._ByValue_ArrayMembers _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ArrayMembers_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ArrayMembers._Underlying *__MR_CSharp_ArrayMembers_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.ArrayMembers._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ArrayMembers_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public ArrayMembers(Const_ArrayMembers _other) : this(new _ByValue_ArrayMembers(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::ArrayMembers::ArrayMembers`.
                /// </summary>
                public ArrayMembers(ArrayMembers _other) : this((Const_ArrayMembers)_other) {}
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `ArrayMembers` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_ArrayMembers
            {
                internal readonly Const_ArrayMembers? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_ArrayMembers() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_ArrayMembers(Const_ArrayMembers new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_ArrayMembers(Const_ArrayMembers arg) {return new(arg);}
                public _ByValue_ArrayMembers(MR.CS.Misc._Moved<ArrayMembers> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_ArrayMembers(MR.CS.Misc._Moved<ArrayMembers> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ArrayMembers` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ArrayMembers`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` directly.
            /// </summary>
            public class _InOptMut_ArrayMembers
            {
                public ArrayMembers? Opt;

                public _InOptMut_ArrayMembers() {}
                public _InOptMut_ArrayMembers(ArrayMembers value) {Opt = value;}
                public static implicit operator _InOptMut_ArrayMembers(ArrayMembers value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ArrayMembers` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ArrayMembers`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ArrayMembers`/`Const_ArrayMembers` to pass it to the function.
            /// </summary>
            public class _InOptConst_ArrayMembers
            {
                public Const_ArrayMembers? Opt;

                public _InOptConst_ArrayMembers() {}
                public _InOptConst_ArrayMembers(Const_ArrayMembers value) {Opt = value;}
                public static implicit operator _InOptConst_ArrayMembers(Const_ArrayMembers value) {return new(value);}
            }

            // Members having the same name as the exposed class, after rewriting.
            /// <summary>
            /// Generated from class `MR::CSharp::NameConflicts`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_NameConflicts : MR.CS.Misc.Object<Const_NameConflicts>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflicts_Destroy(_Underlying *_this);
                    __MR_CSharp_NameConflicts_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_NameConflicts() {Dispose(false);}

                public unsafe int nameConflicts => *__ref_storage_nameConflicts;
                private protected unsafe int *__ref_storage_nameConflicts;

                public unsafe MR.CS.CSharp.NameConflicts.Const_A a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // nameConflicts (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Get_name_conflicts", ExactSpelling = true)]
                        extern static int *__MR_CSharp_NameConflicts_Get_name_conflicts(MR.CS.CSharp.Const_NameConflicts._Underlying *_this);
                        this.__ref_storage_nameConflicts = __MR_CSharp_NameConflicts_Get_name_conflicts(_UnderlyingPtr);
                    }

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.Const_A._Underlying *__MR_CSharp_NameConflicts_Get_a(MR.CS.CSharp.Const_NameConflicts._Underlying *_this);
                        this.a = new(__MR_CSharp_NameConflicts_Get_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_NameConflicts(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_NameConflicts() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::NameConflicts` elementwise.
                /// </summary>
                public unsafe Const_NameConflicts(int name_conflicts, MR.CS.CSharp.NameConflicts.Const_A a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFrom(int name_conflicts, MR.CS.CSharp.NameConflicts.A._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFrom(name_conflicts, a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                /// </summary>
                public unsafe Const_NameConflicts(MR.CS.CSharp.Const_NameConflicts _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFromAnother(MR.CS.CSharp.NameConflicts._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                /// </summary>
                public Const_NameConflicts(NameConflicts _other) : this((Const_NameConflicts)_other) {}

                /// <summary>
                /// Generated from class `MR::CSharp::NameConflicts::A`.
                /// This is the const half of the class.
                /// </summary>
                public class Const_A : MR.CS.Misc.Object<Const_A>, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_NameConflicts_A_Destroy(_Underlying *_this);
                        __MR_CSharp_NameConflicts_A_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_A() {Dispose(false);}

                    internal unsafe Const_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Const_A() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_DefaultConstruct();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    /// </summary>
                    public unsafe Const_A(MR.CS.CSharp.NameConflicts.Const_A _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_ConstructFromAnother(MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    /// </summary>
                    public Const_A(A _other) : this((Const_A)_other) {}
                }

                /// <summary>
                /// Generated from class `MR::CSharp::NameConflicts::A`.
                /// This is the non-const half of the class.
                /// </summary>
                public class A : Const_A
                {
                    internal unsafe A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe A() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_DefaultConstruct();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    /// </summary>
                    public unsafe A(MR.CS.CSharp.NameConflicts.Const_A _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_ConstructFromAnother(MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_NameConflicts_A_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::NameConflicts::A::A`.
                    /// </summary>
                    public A(A _other) : this((Const_A)_other) {}

                    /// <summary>
                    /// Generated from method `MR::CSharp::NameConflicts::A::operator=`.
                    /// </summary>
                    public unsafe MR.CS.CSharp.NameConflicts.A assign(MR.CS.CSharp.NameConflicts.Const_A _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_A_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_A_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NameConflicts.A._Underlying *_other);
                        _DiscardKeepAlive();
                        _KeepAlive(_other);
                        return new(__MR_CSharp_NameConflicts_A_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }
                }

                /// <summary>
                /// This is used for optional parameters of class `A` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `A`/`Const_A` directly.
                /// </summary>
                public class _InOptMut_A
                {
                    public A? Opt;

                    public _InOptMut_A() {}
                    public _InOptMut_A(A value) {Opt = value;}
                    public static implicit operator _InOptMut_A(A value) {return new(value);}
                }

                /// <summary>
                /// This is used for optional parameters of class `A` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `A`/`Const_A` to pass it to the function.
                /// </summary>
                public class _InOptConst_A
                {
                    public Const_A? Opt;

                    public _InOptConst_A() {}
                    public _InOptConst_A(Const_A value) {Opt = value;}
                    public static implicit operator _InOptConst_A(Const_A value) {return new(value);}
                }
            }

            // Members having the same name as the exposed class, after rewriting.
            /// <summary>
            /// Generated from class `MR::CSharp::NameConflicts`.
            /// This is the non-const half of the class.
            /// </summary>
            public class NameConflicts : Const_NameConflicts
            {
                public new unsafe ref int nameConflicts => ref *__ref_storage_nameConflicts;

                public new unsafe MR.CS.CSharp.NameConflicts.A a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.NameConflicts.A._Underlying *__MR_CSharp_NameConflicts_GetMutable_a(MR.CS.CSharp.NameConflicts._Underlying *_this);
                        this.a = new(__MR_CSharp_NameConflicts_GetMutable_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe NameConflicts(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe NameConflicts() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::NameConflicts` elementwise.
                /// </summary>
                public unsafe NameConflicts(int name_conflicts, MR.CS.CSharp.NameConflicts.Const_A a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFrom(int name_conflicts, MR.CS.CSharp.NameConflicts.A._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFrom(name_conflicts, a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                /// </summary>
                public unsafe NameConflicts(MR.CS.CSharp.Const_NameConflicts _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_ConstructFromAnother(MR.CS.CSharp.NameConflicts._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_NameConflicts_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::NameConflicts::NameConflicts`.
                /// </summary>
                public NameConflicts(NameConflicts _other) : this((Const_NameConflicts)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::NameConflicts::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.NameConflicts assign(MR.CS.CSharp.Const_NameConflicts _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.NameConflicts._Underlying *__MR_CSharp_NameConflicts_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.NameConflicts._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_NameConflicts_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::NameConflicts::name_Conflicts`.
                /// </summary>
                public unsafe void nameConflicts_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflicts_name_Conflicts", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflicts_name_Conflicts(_Underlying *_this);
                    __MR_CSharp_NameConflicts_name_Conflicts(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `NameConflicts` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NameConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NameConflicts`/`Const_NameConflicts` directly.
            /// </summary>
            public class _InOptMut_NameConflicts
            {
                public NameConflicts? Opt;

                public _InOptMut_NameConflicts() {}
                public _InOptMut_NameConflicts(NameConflicts value) {Opt = value;}
                public static implicit operator _InOptMut_NameConflicts(NameConflicts value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `NameConflicts` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NameConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `NameConflicts`/`Const_NameConflicts` to pass it to the function.
            /// </summary>
            public class _InOptConst_NameConflicts
            {
                public Const_NameConflicts? Opt;

                public _InOptConst_NameConflicts() {}
                public _InOptConst_NameConflicts(Const_NameConflicts value) {Opt = value;}
                public static implicit operator _InOptConst_NameConflicts(Const_NameConflicts value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_NameConflictsExposed : MR.CS.Misc.Object<ConstBox_NameConflictsExposed>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly NameConflictsExposed _Ref => ref *(NameConflictsExposed *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_NameConflictsExposed() {Dispose(false);}

                public ref readonly int nameConflictsExposed => ref _Ref.nameConflictsExposed;

                public ref readonly MR.CS.CSharp.NameConflictsExposed.A a => ref _Ref.a;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_NameConflictsExposed(NameConflictsExposed other) : this(new ConstBox_NameConflictsExposed((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_NameConflictsExposed` has this conversion, `Box_NameConflictsExposed` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_NameConflictsExposed(NameConflictsExposed other) {return new(other);}

                internal unsafe ConstBox_NameConflictsExposed(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe ConstBox_NameConflictsExposed() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 8, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_NameConflictsExposed(ConstBox_NameConflictsExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    *(MR.CS.CSharp.NameConflictsExposed *)_UnderlyingPtr = *(MR.CS.CSharp.NameConflictsExposed *)_other._UnderlyingPtr;
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_NameConflictsExposed : ConstBox_NameConflictsExposed
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref NameConflictsExposed _Ref => ref *(NameConflictsExposed *)_UnderlyingPtr;

                public new ref int nameConflictsExposed => ref _Ref.nameConflictsExposed;

                public new ref MR.CS.CSharp.NameConflictsExposed.A a => ref _Ref.a;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_NameConflictsExposed(NameConflictsExposed other) : this(new ConstBox_NameConflictsExposed((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_NameConflictsExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe Box_NameConflictsExposed() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 8, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_NameConflictsExposed(ConstBox_NameConflictsExposed _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(8);
                    *(MR.CS.CSharp.NameConflictsExposed *)_UnderlyingPtr = *(MR.CS.CSharp.NameConflictsExposed *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_NameConflictsExposed _other) {_Ref = _other._Ref;}

                /// <summary>
                /// Generated from method `MR::CSharp::NameConflictsExposed::name_Conflicts_exposed`.
                /// </summary>
                public unsafe void nameConflictsExposed_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflictsExposed_name_Conflicts_exposed", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(_Underlying *_this);
                    __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::NameConflictsExposed`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 8)]
            public struct NameConflictsExposed
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public int nameConflictsExposed;

                [System.Runtime.InteropServices.FieldOffset(4)]
                public MR.CS.CSharp.NameConflictsExposed.A a;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator NameConflictsExposed(ConstBox_NameConflictsExposed other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public NameConflictsExposed(NameConflictsExposed _other) {this = _other;}

                /// <summary>
                /// Generated from method `MR::CSharp::NameConflictsExposed::name_Conflicts_exposed`.
                /// </summary>
                public unsafe void nameConflictsExposed_()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_NameConflictsExposed_name_Conflicts_exposed", ExactSpelling = true)]
                    extern static void __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(MR.CS.CSharp.NameConflictsExposed *_this);
                    fixed (MR.CS.CSharp.NameConflictsExposed *__ptr__this = &this)
                    {
                        __MR_CSharp_NameConflictsExposed_name_Conflicts_exposed(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the const reference to the struct.
                /// </summary>
                public class ConstBox_A : MR.CS.Misc.Object<ConstBox_A>, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    /// <summary>
                    /// Get the underlying struct.
                    /// </summary>
                    public unsafe ref readonly A _Ref => ref *(A *)_UnderlyingPtr;

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        MR.CS.Misc._Free((void *)_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~ConstBox_A() {Dispose(false);}

                    public ref readonly int x => ref _Ref.x;

                    /// <summary>
                    /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                    /// </summary>
                    public unsafe ConstBox_A(A other) : this(new ConstBox_A((_Underlying *)&other, is_owning: false)) {}
                    /// <summary>
                    /// Convert from a struct by copying it. Note that only `ConstBox_A` has this conversion, `Box_A` intentionally doesn't.
                    /// </summary>
                    public static implicit operator ConstBox_A(A other) {return new(other);}

                    internal unsafe ConstBox_A(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                    /// <summary>
                    /// Generated default constructor.
                    /// </summary>
                    public unsafe ConstBox_A() : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                    }

                    /// <summary>
                    /// Generated copy constructor.
                    /// </summary>
                    public unsafe ConstBox_A(ConstBox_A _other) : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        *(MR.CS.CSharp.NameConflictsExposed.A *)_UnderlyingPtr = *(MR.CS.CSharp.NameConflictsExposed.A *)_other._UnderlyingPtr;
                    }
                }

                /// <summary>
                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the non-const reference to the struct.
                /// </summary>
                public class Box_A : ConstBox_A
                {
                    /// <summary>
                    /// Get the underlying struct.
                    /// </summary>
                    public unsafe new ref A _Ref => ref *(A *)_UnderlyingPtr;

                    public new ref int x => ref _Ref.x;

                    /// <summary>
                    /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                    /// </summary>
                    public unsafe Box_A(A other) : this(new ConstBox_A((_Underlying *)&other, is_owning: false)) {}

                    internal unsafe Box_A(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                    /// <summary>
                    /// Generated default constructor.
                    /// </summary>
                    public unsafe Box_A() : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                    }

                    /// <summary>
                    /// Generated copy constructor.
                    /// </summary>
                    public unsafe Box_A(ConstBox_A _other) : this(null, is_owning: true)
                    {
                        _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                        *(MR.CS.CSharp.NameConflictsExposed.A *)_UnderlyingPtr = *(MR.CS.CSharp.NameConflictsExposed.A *)_other._UnderlyingPtr;
                    }

                    /// <summary>
                    /// Generated copy assignment.
                    /// </summary>
                    public void Assign(ConstBox_A _other) {_Ref = _other._Ref;}
                }

                /// <summary>
                /// Generated from class `MR::CSharp::NameConflictsExposed::A`.
                /// This is the by-value version of the struct.
                /// </summary>
                [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
                public struct A
                {
                    [System.Runtime.InteropServices.FieldOffset(0)]
                    public int x;

                    /// <summary>
                    /// Copy contents from a wrapper class to this struct.
                    /// </summary>
                    public static implicit operator A(ConstBox_A other) => other._Ref;

                    /// <summary>
                    /// Generated copy constructor.
                    /// </summary>
                    public A(A _other) {this = _other;}
                }

                /// <summary>
                /// This is used as a function parameter when passing `Box_A` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
                /// Usage:
                /// * Pass an instance of `Box_A`/`ConstBox_A` to copy it into the function.
                /// * Pass `null` to use the default argument
                /// </summary>
                public readonly ref struct _InOpt_A
                {
                    public readonly bool HasValue;
                    internal readonly A Object;
                    public A Value{
                        get
                        {
                            System.Diagnostics.Trace.Assert(HasValue);
                            return Object;
                        }
                    }

                    public _InOpt_A() {HasValue = false;}
                    public _InOpt_A(A new_value) {HasValue = true; Object = new_value;}
                    public static implicit operator _InOpt_A(A new_value) {return new(new_value);}
                    public _InOpt_A(ConstBox_A new_value) {HasValue = true; Object = new_value._Ref;}
                    public static implicit operator _InOpt_A(ConstBox_A new_value) {return new(new_value);}
                }

                /// <summary>
                /// This is used for optional parameters of class `Box_A` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Box_A`/`ConstBox_A` directly.
                /// * Pass `new(ref ...)` to pass a reference to `A`.
                /// </summary>
                public class _InOptMut_A
                {
                    public Box_A? Opt;

                    public _InOptMut_A() {}
                    public _InOptMut_A(Box_A value) {Opt = value;}
                    public static implicit operator _InOptMut_A(Box_A value) {return new(value);}
                    public unsafe _InOptMut_A(ref A value)
                    {
                        fixed (A *value_ptr = &value)
                        {
                            Opt = new((ConstBox_A._Underlying *)value_ptr, is_owning: false);
                        }
                    }
                }

                /// <summary>
                /// This is used for optional parameters of class `Box_A` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_A`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Box_A`/`ConstBox_A` to pass it to the function.
                /// * Pass `new(ref ...)` to pass a reference to `A`.
                /// </summary>
                public class _InOptConst_A
                {
                    public ConstBox_A? Opt;

                    public _InOptConst_A() {}
                    public _InOptConst_A(ConstBox_A value) {Opt = value;}
                    public static implicit operator _InOptConst_A(ConstBox_A value) {return new(value);}
                    public unsafe _InOptConst_A(ref readonly A value)
                    {
                        fixed (A *value_ptr = &value)
                        {
                            Opt = new((ConstBox_A._Underlying *)value_ptr, is_owning: false);
                        }
                    }
                }
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_NameConflictsExposed` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_NameConflictsExposed`/`ConstBox_NameConflictsExposed` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_NameConflictsExposed
            {
                public readonly bool HasValue;
                internal readonly NameConflictsExposed Object;
                public NameConflictsExposed Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_NameConflictsExposed() {HasValue = false;}
                public _InOpt_NameConflictsExposed(NameConflictsExposed new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_NameConflictsExposed(NameConflictsExposed new_value) {return new(new_value);}
                public _InOpt_NameConflictsExposed(ConstBox_NameConflictsExposed new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_NameConflictsExposed(ConstBox_NameConflictsExposed new_value) {return new(new_value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_NameConflictsExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_NameConflictsExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_NameConflictsExposed`/`ConstBox_NameConflictsExposed` directly.
            /// * Pass `new(ref ...)` to pass a reference to `NameConflictsExposed`.
            /// </summary>
            public class _InOptMut_NameConflictsExposed
            {
                public Box_NameConflictsExposed? Opt;

                public _InOptMut_NameConflictsExposed() {}
                public _InOptMut_NameConflictsExposed(Box_NameConflictsExposed value) {Opt = value;}
                public static implicit operator _InOptMut_NameConflictsExposed(Box_NameConflictsExposed value) {return new(value);}
                public unsafe _InOptMut_NameConflictsExposed(ref NameConflictsExposed value)
                {
                    fixed (NameConflictsExposed *value_ptr = &value)
                    {
                        Opt = new((ConstBox_NameConflictsExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_NameConflictsExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_NameConflictsExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_NameConflictsExposed`/`ConstBox_NameConflictsExposed` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `NameConflictsExposed`.
            /// </summary>
            public class _InOptConst_NameConflictsExposed
            {
                public ConstBox_NameConflictsExposed? Opt;

                public _InOptConst_NameConflictsExposed() {}
                public _InOptConst_NameConflictsExposed(ConstBox_NameConflictsExposed value) {Opt = value;}
                public static implicit operator _InOptConst_NameConflictsExposed(ConstBox_NameConflictsExposed value) {return new(value);}
                public unsafe _InOptConst_NameConflictsExposed(ref readonly NameConflictsExposed value)
                {
                    fixed (NameConflictsExposed *value_ptr = &value)
                    {
                        Opt = new((ConstBox_NameConflictsExposed._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::AmbiguousTemplates`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_AmbiguousTemplates : MR.CS.Misc.Object<Const_AmbiguousTemplates>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_Destroy(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_AmbiguousTemplates() {Dispose(false);}

                internal unsafe Const_AmbiguousTemplates(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_AmbiguousTemplates() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                /// </summary>
                public unsafe Const_AmbiguousTemplates(MR.CS.CSharp.Const_AmbiguousTemplates _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_ConstructFromAnother(MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                /// </summary>
                public Const_AmbiguousTemplates(AmbiguousTemplates _other) : this((Const_AmbiguousTemplates)_other) {}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::AmbiguousTemplates`.
            /// This is the non-const half of the class.
            /// </summary>
            public class AmbiguousTemplates : Const_AmbiguousTemplates
            {
                internal unsafe AmbiguousTemplates(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe AmbiguousTemplates() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_DefaultConstruct();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                /// </summary>
                public unsafe AmbiguousTemplates(MR.CS.CSharp.Const_AmbiguousTemplates _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_ConstructFromAnother(MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_AmbiguousTemplates_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::AmbiguousTemplates::AmbiguousTemplates`.
                /// </summary>
                public AmbiguousTemplates(AmbiguousTemplates _other) : this((Const_AmbiguousTemplates)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.AmbiguousTemplates assign(MR.CS.CSharp.Const_AmbiguousTemplates _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.AmbiguousTemplates._Underlying *__MR_CSharp_AmbiguousTemplates_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.AmbiguousTemplates._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_AmbiguousTemplates_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_a<int32_t>`.
                /// </summary>
                public unsafe void templateA(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_a_int32_t", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_a_int32_t(_Underlying *_this, int _1);
                    __MR_CSharp_AmbiguousTemplates_template_a_int32_t(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_a<float>`.
                /// </summary>
                public unsafe void templateA(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_a_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_a_float(_Underlying *_this, float _1);
                    __MR_CSharp_AmbiguousTemplates_template_a_float(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_b<int32_t>`.
                /// </summary>
                public unsafe int templateB_Int32T()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_b_int32_t", ExactSpelling = true)]
                    extern static int __MR_CSharp_AmbiguousTemplates_template_b_int32_t(_Underlying *_this);
                    return __MR_CSharp_AmbiguousTemplates_template_b_int32_t(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_b<float>`.
                /// </summary>
                public unsafe float templateB_Float()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_b_float", ExactSpelling = true)]
                    extern static float __MR_CSharp_AmbiguousTemplates_template_b_float(_Underlying *_this);
                    return __MR_CSharp_AmbiguousTemplates_template_b_float(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_c<int32_t>`.
                /// </summary>
                public unsafe void templateC_Int32T()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_c_int32_t", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_c_int32_t(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_template_c_int32_t(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::template_c<float>`.
                /// </summary>
                public unsafe void templateC_Float()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_template_c_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_template_c_float(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_template_c_float(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::AmbiguousTemplates::instantiate`.
                /// </summary>
                public unsafe void instantiate()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_AmbiguousTemplates_instantiate", ExactSpelling = true)]
                    extern static void __MR_CSharp_AmbiguousTemplates_instantiate(_Underlying *_this);
                    __MR_CSharp_AmbiguousTemplates_instantiate(_UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `AmbiguousTemplates` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_AmbiguousTemplates`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `AmbiguousTemplates`/`Const_AmbiguousTemplates` directly.
            /// </summary>
            public class _InOptMut_AmbiguousTemplates
            {
                public AmbiguousTemplates? Opt;

                public _InOptMut_AmbiguousTemplates() {}
                public _InOptMut_AmbiguousTemplates(AmbiguousTemplates value) {Opt = value;}
                public static implicit operator _InOptMut_AmbiguousTemplates(AmbiguousTemplates value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `AmbiguousTemplates` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_AmbiguousTemplates`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `AmbiguousTemplates`/`Const_AmbiguousTemplates` to pass it to the function.
            /// </summary>
            public class _InOptConst_AmbiguousTemplates
            {
                public Const_AmbiguousTemplates? Opt;

                public _InOptConst_AmbiguousTemplates() {}
                public _InOptConst_AmbiguousTemplates(Const_AmbiguousTemplates value) {Opt = value;}
                public static implicit operator _InOptConst_AmbiguousTemplates(Const_AmbiguousTemplates value) {return new(value);}
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// <summary>
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the const reference to the struct.
            /// </summary>
            public class ConstBox_ConstNonconstConflicts : MR.CS.Misc.Object<ConstBox_ConstNonconstConflicts>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe ref readonly ConstNonconstConflicts _Ref => ref *(ConstNonconstConflicts *)_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    MR.CS.Misc._Free((void *)_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~ConstBox_ConstNonconstConflicts() {Dispose(false);}

                public ref readonly int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe ConstBox_ConstNonconstConflicts(ConstNonconstConflicts other) : this(new ConstBox_ConstNonconstConflicts((_Underlying *)&other, is_owning: false)) {}
                /// <summary>
                /// Convert from a struct by copying it. Note that only `ConstBox_ConstNonconstConflicts` has this conversion, `Box_ConstNonconstConflicts` intentionally doesn't.
                /// </summary>
                public static implicit operator ConstBox_ConstNonconstConflicts(ConstNonconstConflicts other) {return new(other);}

                internal unsafe ConstBox_ConstNonconstConflicts(_Underlying *ptr, bool is_owning) : base(is_owning) {_UnderlyingPtr = ptr;}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe ConstBox_ConstNonconstConflicts() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe ConstBox_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConstNonconstConflicts *)_UnderlyingPtr = *(MR.CS.CSharp.ConstNonconstConflicts *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe void foo(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_float(_Underlying *_this, float _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_float(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_char(_Underlying *_this, byte _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_char(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.ConstBox_ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstBox_ConstNonconstConflicts._Underlying *_this);
                    return __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(_this._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                /// </summary>
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_this);
                    __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                /// </summary>
                public static unsafe int operator/(MR.CS.CSharp.ConstBox_ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t(MR.CS.CSharp.ConstBox_ConstNonconstConflicts._Underlying *_this, int _1);
                    return __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t(_this._UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.ConstBox_ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstBox_ConstNonconstConflicts._Underlying *_1);
                    return __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(_1._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator!`.
                /// </summary>
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_1);
                    __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator&`.
                /// </summary>
                public static unsafe int operator&(int _1, MR.CS.CSharp.ConstBox_ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.ConstBox_ConstNonconstConflicts._Underlying *_2);
                    return __MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref(_1, _2._UnderlyingPtr);
                }
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// <summary>
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the non-const reference to the struct.
            /// </summary>
            public class Box_ConstNonconstConflicts : ConstBox_ConstNonconstConflicts
            {
                /// <summary>
                /// Get the underlying struct.
                /// </summary>
                public unsafe new ref ConstNonconstConflicts _Ref => ref *(ConstNonconstConflicts *)_UnderlyingPtr;

                public new ref int x => ref _Ref.x;

                /// <summary>
                /// Make a copy of a struct. (Even though we initially pass `is_owning: false`, we then use the copy constructor to produce an owning instance.)
                /// </summary>
                public unsafe Box_ConstNonconstConflicts(ConstNonconstConflicts other) : this(new ConstBox_ConstNonconstConflicts((_Underlying *)&other, is_owning: false)) {}

                internal unsafe Box_ConstNonconstConflicts(_Underlying *ptr, bool is_owning) : base(ptr, is_owning) {}

                /// <summary>
                /// Generated default constructor.
                /// </summary>
                public unsafe Box_ConstNonconstConflicts() : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    System.Runtime.InteropServices.NativeMemory.Fill(_UnderlyingPtr, 4, 0);
                }

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public unsafe Box_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts _other) : this(null, is_owning: true)
                {
                    _UnderlyingPtr = (_Underlying *)MR.CS.Misc._Alloc(4);
                    *(MR.CS.CSharp.ConstNonconstConflicts *)_UnderlyingPtr = *(MR.CS.CSharp.ConstNonconstConflicts *)_other._UnderlyingPtr;
                }

                /// <summary>
                /// Generated copy assignment.
                /// </summary>
                public void Assign(ConstBox_ConstNonconstConflicts _other) {_Ref = _other._Ref;}

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe void foo(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t(_Underlying *_this, int _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe new void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_mut_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_mut_char(_Underlying *_this, byte _1);
                    __MR_CSharp_ConstNonconstConflicts_foo_mut_char(_UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.Box_ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Box_ConstNonconstConflicts._Underlying *_this);
                    return __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(_this._UnderlyingPtr);
                }

                // Since this returns void, it gets rewritten into a method.
                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                /// </summary>
                public unsafe new void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_this);
                    __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                /// </summary>
                public static unsafe int operator/(MR.CS.CSharp.Box_ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t(MR.CS.CSharp.Box_ConstNonconstConflicts._Underlying *_this, int _1);
                    return __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t(_this._UnderlyingPtr, _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.Box_ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.Box_ConstNonconstConflicts._Underlying *_1);
                    return __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(_1._UnderlyingPtr);
                }

                // Since this returns void, it gets rewritten into a method.
                /// <summary>
                /// Generated from function `MR::CSharp::operator!`.
                /// </summary>
                public unsafe new void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(_Underlying *_1);
                    __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator&`.
                /// </summary>
                public static unsafe int operator&(int _1, MR.CS.CSharp.Box_ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.Box_ConstNonconstConflicts._Underlying *_2);
                    return __MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref(_1, _2._UnderlyingPtr);
                }
            }

            // Test that we don't produce the const and non-const overloads of the same function under the same name in C#, as that would be a compilation error in C#.
            /// <summary>
            /// Generated from class `MR::CSharp::ConstNonconstConflicts`.
            /// This is the by-value version of the struct.
            /// </summary>
            [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit, Size = 4)]
            public struct ConstNonconstConflicts
            {
                [System.Runtime.InteropServices.FieldOffset(0)]
                public int x;

                /// <summary>
                /// Copy contents from a wrapper class to this struct.
                /// </summary>
                public static implicit operator ConstNonconstConflicts(ConstBox_ConstNonconstConflicts other) => other._Ref;

                /// <summary>
                /// Generated copy constructor.
                /// </summary>
                public ConstNonconstConflicts(ConstNonconstConflicts _other) {this = _other;}

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe void foo(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_mut_int32_t(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public readonly unsafe void foo(float _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_float", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_float(MR.CS.CSharp.ConstNonconstConflicts *_this, float _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_float(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public unsafe void foo(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_mut_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_mut_char(MR.CS.CSharp.ConstNonconstConflicts *_this, byte _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_mut_char(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::foo`.
                /// </summary>
                public readonly unsafe void foo_Const(byte _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ConstNonconstConflicts_foo_char", ExactSpelling = true)]
                    extern static void __MR_CSharp_ConstNonconstConflicts_foo_char(MR.CS.CSharp.ConstNonconstConflicts *_this, byte _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_CSharp_ConstNonconstConflicts_foo_char(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                /// </summary>
                public unsafe int add()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        return __MR_C_pos_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator+`.
                /// </summary>
                public static unsafe int operator+(MR.CS.CSharp.ConstNonconstConflicts _this)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    return __MR_C_pos_const_MR_CSharp_ConstNonconstConflicts_ref(&_this);
                }

                // Since this returns void, it gets rewritten into a method.
                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                /// </summary>
                public unsafe void compl()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_C_compl_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator~`.
                /// </summary>
                public readonly unsafe void compl_Const()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_this);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        __MR_C_compl_const_MR_CSharp_ConstNonconstConflicts_ref(__ptr__this);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                /// </summary>
                public unsafe int div(int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__this = &this)
                    {
                        return __MR_C_div_MR_CSharp_ConstNonconstConflicts_ref_int32_t(__ptr__this, _1);
                    }
                }

                /// <summary>
                /// Generated from method `MR::CSharp::ConstNonconstConflicts::operator/`.
                /// </summary>
                public static unsafe int operator/(MR.CS.CSharp.ConstNonconstConflicts _this, int _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t", ExactSpelling = true)]
                    extern static int __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t(MR.CS.CSharp.ConstNonconstConflicts *_this, int _1);
                    return __MR_C_div_const_MR_CSharp_ConstNonconstConflicts_ref_int32_t(&_this, _1);
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public unsafe int sub()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        return __MR_C_neg_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator-`.
                /// </summary>
                public static unsafe int operator-(MR.CS.CSharp.ConstNonconstConflicts _1)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    return __MR_C_neg_const_MR_CSharp_ConstNonconstConflicts_ref(&_1);
                }

                // Since this returns void, it gets rewritten into a method.
                /// <summary>
                /// Generated from function `MR::CSharp::operator!`.
                /// </summary>
                public unsafe void not()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        __MR_C_not_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator!`.
                /// </summary>
                public readonly unsafe void not_Const()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static void __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(MR.CS.CSharp.ConstNonconstConflicts *_1);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__1 = &this)
                    {
                        __MR_C_not_const_MR_CSharp_ConstNonconstConflicts_ref(__ptr__1);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator&`.
                /// </summary>
                public static unsafe int bitand(int _1, ref MR.CS.CSharp.ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.ConstNonconstConflicts *_2);
                    fixed (MR.CS.CSharp.ConstNonconstConflicts *__ptr__2 = &_2)
                    {
                        return __MR_C_bitand_int32_t_MR_CSharp_ConstNonconstConflicts_ref(_1, __ptr__2);
                    }
                }

                /// <summary>
                /// Generated from function `MR::CSharp::operator&`.
                /// </summary>
                public static unsafe int operator&(int _1, MR.CS.CSharp.ConstNonconstConflicts _2)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref", ExactSpelling = true)]
                    extern static int __MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref(int _1, MR.CS.CSharp.ConstNonconstConflicts *_2);
                    return __MR_C_bitand_int32_t_const_MR_CSharp_ConstNonconstConflicts_ref(_1, &_2);
                }
            }

            /// <summary>
            /// This is used as a function parameter when passing `Box_ConstNonconstConflicts` by value with a default argument, since trying to use `?` instead seems to prevent us from taking its address.
            /// Usage:
            /// * Pass an instance of `Box_ConstNonconstConflicts`/`ConstBox_ConstNonconstConflicts` to copy it into the function.
            /// * Pass `null` to use the default argument
            /// </summary>
            public readonly ref struct _InOpt_ConstNonconstConflicts
            {
                public readonly bool HasValue;
                internal readonly ConstNonconstConflicts Object;
                public ConstNonconstConflicts Value{
                    get
                    {
                        System.Diagnostics.Trace.Assert(HasValue);
                        return Object;
                    }
                }

                public _InOpt_ConstNonconstConflicts() {HasValue = false;}
                public _InOpt_ConstNonconstConflicts(ConstNonconstConflicts new_value) {HasValue = true; Object = new_value;}
                public static implicit operator _InOpt_ConstNonconstConflicts(ConstNonconstConflicts new_value) {return new(new_value);}
                public _InOpt_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts new_value) {HasValue = true; Object = new_value._Ref;}
                public static implicit operator _InOpt_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts new_value) {return new(new_value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ConstNonconstConflicts` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ConstNonconstConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ConstNonconstConflicts`/`ConstBox_ConstNonconstConflicts` directly.
            /// * Pass `new(ref ...)` to pass a reference to `ConstNonconstConflicts`.
            /// </summary>
            public class _InOptMut_ConstNonconstConflicts
            {
                public Box_ConstNonconstConflicts? Opt;

                public _InOptMut_ConstNonconstConflicts() {}
                public _InOptMut_ConstNonconstConflicts(Box_ConstNonconstConflicts value) {Opt = value;}
                public static implicit operator _InOptMut_ConstNonconstConflicts(Box_ConstNonconstConflicts value) {return new(value);}
                public unsafe _InOptMut_ConstNonconstConflicts(ref ConstNonconstConflicts value)
                {
                    fixed (ConstNonconstConflicts *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ConstNonconstConflicts._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `Box_ConstNonconstConflicts` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ConstNonconstConflicts`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `Box_ConstNonconstConflicts`/`ConstBox_ConstNonconstConflicts` to pass it to the function.
            /// * Pass `new(ref ...)` to pass a reference to `ConstNonconstConflicts`.
            /// </summary>
            public class _InOptConst_ConstNonconstConflicts
            {
                public ConstBox_ConstNonconstConflicts? Opt;

                public _InOptConst_ConstNonconstConflicts() {}
                public _InOptConst_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts value) {Opt = value;}
                public static implicit operator _InOptConst_ConstNonconstConflicts(ConstBox_ConstNonconstConflicts value) {return new(value);}
                public unsafe _InOptConst_ConstNonconstConflicts(ref readonly ConstNonconstConflicts value)
                {
                    fixed (ConstNonconstConflicts *value_ptr = &value)
                    {
                        Opt = new((ConstBox_ConstNonconstConflicts._Underlying *)value_ptr, is_owning: false);
                    }
                }
            }

            // Class fields of pointer types:
            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersClass`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ClassMemberPointersClass : MR.CS.Misc.Object<Const_ClassMemberPointersClass>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersClass_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersClass_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersClass() {Dispose(false);}

                public static unsafe MR.CS.CSharp.A? Sa
                {
                    get
                    {
                        MR.CS.CSharp.A? value = null;
                        if (*__ptr_storage_Sa is not null)
                            value = new(*__ptr_storage_Sa, is_owning: false);
                        return value;
                    }
                }
                private protected static unsafe MR.CS.CSharp.A._Underlying **__ptr_storage_Sa;

                public static unsafe MR.CS.CSharp.Const_A? Sb
                {
                    get
                    {
                        MR.CS.CSharp.Const_A? value = null;
                        if (*__ptr_storage_Sb is not null)
                            value = new(*__ptr_storage_Sb, is_owning: false);
                        return value;
                    }
                }
                private protected static unsafe MR.CS.CSharp.Const_A._Underlying **__ptr_storage_Sb;

                public static unsafe MR.CS.CSharp.A Sc {get; private protected set;}

                public static unsafe MR.CS.CSharp.Const_A Sd {get; private protected set;}

                public unsafe MR.CS.CSharp.A? a
                {
                    get
                    {
                        MR.CS.CSharp.A? value = null;
                        if (*__ptr_storage_a is not null)
                        {
                            value = new(*__ptr_storage_a, is_owning: false);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe MR.CS.CSharp.A._Underlying **__ptr_storage_a;

                public unsafe MR.CS.CSharp.Const_A? b
                {
                    get
                    {
                        MR.CS.CSharp.Const_A? value = null;
                        if (*__ptr_storage_b is not null)
                        {
                            value = new(*__ptr_storage_b, is_owning: false);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe MR.CS.CSharp.Const_A._Underlying **__ptr_storage_b;

                public unsafe MR.CS.CSharp.A c {get; private protected set;}

                public unsafe MR.CS.CSharp.Const_A d {get; private protected set;}

                unsafe static Const_ClassMemberPointersClass()
                {
                    { // Sa (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_sa();
                        Const_ClassMemberPointersClass.__ptr_storage_Sa = __MR_CSharp_ClassMemberPointersClass_Get_sa();
                    }

                    { // Sb (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sb", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_sb();
                        Const_ClassMemberPointersClass.__ptr_storage_Sb = __MR_CSharp_ClassMemberPointersClass_Get_sb();
                    }

                    { // Sc
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sc", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_sc();
                        Const_ClassMemberPointersClass.Sc = new(__MR_CSharp_ClassMemberPointersClass_Get_sc(), is_owning: false);
                    }

                    { // Sd
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_sd", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_sd();
                        Const_ClassMemberPointersClass.Sd = new(__MR_CSharp_ClassMemberPointersClass_Get_sd(), is_owning: false);
                    }
                }

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_a(Const_ClassMemberPointersClass._Underlying *_this);
                        this.__ptr_storage_a = __MR_CSharp_ClassMemberPointersClass_Get_a(_UnderlyingPtr);
                    }

                    { // b (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying **__MR_CSharp_ClassMemberPointersClass_Get_b(Const_ClassMemberPointersClass._Underlying *_this);
                        this.__ptr_storage_b = __MR_CSharp_ClassMemberPointersClass_Get_b(_UnderlyingPtr);
                    }

                    { // c
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_c", ExactSpelling = true)]
                        extern static MR.CS.CSharp.A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_c(MR.CS.CSharp.Const_ClassMemberPointersClass._Underlying *_this);
                        this.c = new(__MR_CSharp_ClassMemberPointersClass_Get_c(_UnderlyingPtr), is_owning: false);
                        this.c._KeepAliveEnclosingObject = this;
                    }

                    { // d
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_Get_d", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_A._Underlying *__MR_CSharp_ClassMemberPointersClass_Get_d(MR.CS.CSharp.Const_ClassMemberPointersClass._Underlying *_this);
                        this.d = new(__MR_CSharp_ClassMemberPointersClass_Get_d(_UnderlyingPtr), is_owning: false);
                        this.d._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_ClassMemberPointersClass(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                /// </summary>
                public unsafe Const_ClassMemberPointersClass(MR.CS.CSharp.Const_ClassMemberPointersClass _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersClass._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                /// </summary>
                public Const_ClassMemberPointersClass(ClassMemberPointersClass _other) : this((Const_ClassMemberPointersClass)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersClass` elementwise.
                /// </summary>
                public unsafe Const_ClassMemberPointersClass(MR.CS.CSharp.A? a, MR.CS.CSharp.Const_A? b, MR.CS.CSharp.A c, MR.CS.CSharp.Const_A d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFrom(MR.CS.CSharp.A._Underlying *a, MR.CS.CSharp.Const_A._Underlying *b, MR.CS.CSharp.A._Underlying *c, MR.CS.CSharp.Const_A._Underlying *d);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFrom(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c._UnderlyingPtr, d._UnderlyingPtr);
                    if (a is not null) _KeepAlive(a);
                    if (b is not null) _KeepAlive(b);
                    _KeepAlive(c);
                    _KeepAlive(d);
                    _FinalizeFields();
                }
            }

            // Class fields of pointer types:
            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersClass`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ClassMemberPointersClass : Const_ClassMemberPointersClass
            {
                public new unsafe MR.CS.CSharp.A? a
                {
                    get => base.a;
                    set
                    {
                        _DiscardKeepAlive("a");
                        if (value is not null)
                            _KeepAlive(value, "a");
                        *__ptr_storage_a = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.CSharp.Const_A? b
                {
                    get => base.b;
                    set
                    {
                        _DiscardKeepAlive("b");
                        if (value is not null)
                            _KeepAlive(value, "b");
                        *__ptr_storage_b = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe ClassMemberPointersClass(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                /// </summary>
                public unsafe ClassMemberPointersClass(MR.CS.CSharp.Const_ClassMemberPointersClass _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersClass._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersClass::ClassMemberPointersClass`.
                /// </summary>
                public ClassMemberPointersClass(ClassMemberPointersClass _other) : this((Const_ClassMemberPointersClass)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersClass` elementwise.
                /// </summary>
                public unsafe ClassMemberPointersClass(MR.CS.CSharp.A? a, MR.CS.CSharp.Const_A? b, MR.CS.CSharp.A c, MR.CS.CSharp.Const_A d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersClass_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersClass._Underlying *__MR_CSharp_ClassMemberPointersClass_ConstructFrom(MR.CS.CSharp.A._Underlying *a, MR.CS.CSharp.Const_A._Underlying *b, MR.CS.CSharp.A._Underlying *c, MR.CS.CSharp.Const_A._Underlying *d);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersClass_ConstructFrom(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c._UnderlyingPtr, d._UnderlyingPtr);
                    if (a is not null) _KeepAlive(a);
                    if (b is not null) _KeepAlive(b);
                    _KeepAlive(c);
                    _KeepAlive(d);
                    _FinalizeFields();
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersClass` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersClass`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersClass`/`Const_ClassMemberPointersClass` directly.
            /// </summary>
            public class _InOptMut_ClassMemberPointersClass
            {
                public ClassMemberPointersClass? Opt;

                public _InOptMut_ClassMemberPointersClass() {}
                public _InOptMut_ClassMemberPointersClass(ClassMemberPointersClass value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersClass(ClassMemberPointersClass value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersClass` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersClass`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersClass`/`Const_ClassMemberPointersClass` to pass it to the function.
            /// </summary>
            public class _InOptConst_ClassMemberPointersClass
            {
                public Const_ClassMemberPointersClass? Opt;

                public _InOptConst_ClassMemberPointersClass() {}
                public _InOptConst_ClassMemberPointersClass(Const_ClassMemberPointersClass value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersClass(Const_ClassMemberPointersClass value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersExposed`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ClassMemberPointersExposed : MR.CS.Misc.Object<Const_ClassMemberPointersExposed>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersExposed_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersExposed_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersExposed() {Dispose(false);}

                public static unsafe MR.CS.CSharp.Box_ExposedLayout? Sa
                {
                    get
                    {
                        MR.CS.CSharp.Box_ExposedLayout? value = null;
                        if (*__ptr_storage_Sa is not null)
                            value = new(*__ptr_storage_Sa, is_owning: false);
                        return value;
                    }
                }
                private protected static unsafe MR.CS.CSharp.Box_ExposedLayout._Underlying **__ptr_storage_Sa;

                public static unsafe MR.CS.CSharp.ConstBox_ExposedLayout? Sb
                {
                    get
                    {
                        MR.CS.CSharp.ConstBox_ExposedLayout? value = null;
                        if (*__ptr_storage_Sb is not null)
                            value = new(*__ptr_storage_Sb, is_owning: false);
                        return value;
                    }
                }
                private protected static unsafe MR.CS.CSharp.ConstBox_ExposedLayout._Underlying **__ptr_storage_Sb;

                public static unsafe ref MR.CS.CSharp.ExposedLayout Sc => ref *__ref_storage_Sc;
                private protected static unsafe MR.CS.CSharp.ExposedLayout *__ref_storage_Sc;

                public static unsafe ref readonly MR.CS.CSharp.ExposedLayout Sd => ref *__ref_storage_Sd;
                private protected static unsafe MR.CS.CSharp.ExposedLayout *__ref_storage_Sd;

                public unsafe MR.CS.CSharp.Box_ExposedLayout? a
                {
                    get
                    {
                        MR.CS.CSharp.Box_ExposedLayout? value = null;
                        if (*__ptr_storage_a is not null)
                        {
                            value = new(*__ptr_storage_a, is_owning: false);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe MR.CS.CSharp.Box_ExposedLayout._Underlying **__ptr_storage_a;

                public unsafe MR.CS.CSharp.ConstBox_ExposedLayout? b
                {
                    get
                    {
                        MR.CS.CSharp.ConstBox_ExposedLayout? value = null;
                        if (*__ptr_storage_b is not null)
                        {
                            value = new(*__ptr_storage_b, is_owning: false);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe MR.CS.CSharp.ConstBox_ExposedLayout._Underlying **__ptr_storage_b;

                public unsafe ref MR.CS.CSharp.ExposedLayout c => ref *__ref_storage_c;
                private protected unsafe MR.CS.CSharp.ExposedLayout *__ref_storage_c;

                public unsafe ref readonly MR.CS.CSharp.ExposedLayout d => ref *__ref_storage_d;
                private protected unsafe MR.CS.CSharp.ExposedLayout *__ref_storage_d;

                unsafe static Const_ClassMemberPointersExposed()
                {
                    { // Sa (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sa", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Box_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_sa();
                        Const_ClassMemberPointersExposed.__ptr_storage_Sa = __MR_CSharp_ClassMemberPointersExposed_Get_sa();
                    }

                    { // Sb (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sb", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ConstBox_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_sb();
                        Const_ClassMemberPointersExposed.__ptr_storage_Sb = __MR_CSharp_ClassMemberPointersExposed_Get_sb();
                    }

                    { // Sc (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sc", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_sc();
                        Const_ClassMemberPointersExposed.__ref_storage_Sc = __MR_CSharp_ClassMemberPointersExposed_Get_sc();
                    }

                    { // Sd (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_sd", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_sd();
                        Const_ClassMemberPointersExposed.__ref_storage_Sd = __MR_CSharp_ClassMemberPointersExposed_Get_sd();
                    }
                }

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Box_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_a(Const_ClassMemberPointersExposed._Underlying *_this);
                        this.__ptr_storage_a = __MR_CSharp_ClassMemberPointersExposed_Get_a(_UnderlyingPtr);
                    }

                    { // b (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_b", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ConstBox_ExposedLayout._Underlying **__MR_CSharp_ClassMemberPointersExposed_Get_b(Const_ClassMemberPointersExposed._Underlying *_this);
                        this.__ptr_storage_b = __MR_CSharp_ClassMemberPointersExposed_Get_b(_UnderlyingPtr);
                    }

                    { // c (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_c", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_c(MR.CS.CSharp.Const_ClassMemberPointersExposed._Underlying *_this);
                        this.__ref_storage_c = __MR_CSharp_ClassMemberPointersExposed_Get_c(_UnderlyingPtr);
                    }

                    { // d (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_Get_d", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_ClassMemberPointersExposed_Get_d(MR.CS.CSharp.Const_ClassMemberPointersExposed._Underlying *_this);
                        this.__ref_storage_d = __MR_CSharp_ClassMemberPointersExposed_Get_d(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_ClassMemberPointersExposed(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                /// </summary>
                public unsafe Const_ClassMemberPointersExposed(MR.CS.CSharp.Const_ClassMemberPointersExposed _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersExposed._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                /// </summary>
                public Const_ClassMemberPointersExposed(ClassMemberPointersExposed _other) : this((Const_ClassMemberPointersExposed)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersExposed` elementwise.
                /// </summary>
                public unsafe Const_ClassMemberPointersExposed(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.CSharp.ExposedLayout? b, ref MR.CS.CSharp.ExposedLayout c, in MR.CS.CSharp.ExposedLayout d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFrom(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout *c, MR.CS.CSharp.ExposedLayout *d);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr_c = &c)
                    {
                        fixed (MR.CS.CSharp.ExposedLayout *__ptr_d = &d)
                        {
                            MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                            MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                            _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, __ptr_d);
                            if (a is not null) a.Value = __value_a;
                            _FinalizeFields();
                        }
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersExposed`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ClassMemberPointersExposed : Const_ClassMemberPointersExposed
            {
                public new unsafe MR.CS.CSharp.Box_ExposedLayout? a
                {
                    get => base.a;
                    set
                    {
                        _DiscardKeepAlive("a");
                        if (value is not null)
                            _KeepAlive(value, "a");
                        *__ptr_storage_a = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.CSharp.ConstBox_ExposedLayout? b
                {
                    get => base.b;
                    set
                    {
                        _DiscardKeepAlive("b");
                        if (value is not null)
                            _KeepAlive(value, "b");
                        *__ptr_storage_b = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe ClassMemberPointersExposed(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                /// </summary>
                public unsafe ClassMemberPointersExposed(MR.CS.CSharp.Const_ClassMemberPointersExposed _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersExposed._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersExposed::ClassMemberPointersExposed`.
                /// </summary>
                public ClassMemberPointersExposed(ClassMemberPointersExposed _other) : this((Const_ClassMemberPointersExposed)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersExposed` elementwise.
                /// </summary>
                public unsafe ClassMemberPointersExposed(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.CSharp.ExposedLayout? b, ref MR.CS.CSharp.ExposedLayout c, in MR.CS.CSharp.ExposedLayout d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersExposed_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersExposed._Underlying *__MR_CSharp_ClassMemberPointersExposed_ConstructFrom(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout *c, MR.CS.CSharp.ExposedLayout *d);
                    fixed (MR.CS.CSharp.ExposedLayout *__ptr_c = &c)
                    {
                        fixed (MR.CS.CSharp.ExposedLayout *__ptr_d = &d)
                        {
                            MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                            MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                            _UnderlyingPtr = __MR_CSharp_ClassMemberPointersExposed_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, __ptr_d);
                            if (a is not null) a.Value = __value_a;
                            _FinalizeFields();
                        }
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersExposed` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersExposed`/`Const_ClassMemberPointersExposed` directly.
            /// </summary>
            public class _InOptMut_ClassMemberPointersExposed
            {
                public ClassMemberPointersExposed? Opt;

                public _InOptMut_ClassMemberPointersExposed() {}
                public _InOptMut_ClassMemberPointersExposed(ClassMemberPointersExposed value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersExposed(ClassMemberPointersExposed value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersExposed` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersExposed`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersExposed`/`Const_ClassMemberPointersExposed` to pass it to the function.
            /// </summary>
            public class _InOptConst_ClassMemberPointersExposed
            {
                public Const_ClassMemberPointersExposed? Opt;

                public _InOptConst_ClassMemberPointersExposed() {}
                public _InOptConst_ClassMemberPointersExposed(Const_ClassMemberPointersExposed value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersExposed(Const_ClassMemberPointersExposed value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersUshort`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ClassMemberPointersUshort : MR.CS.Misc.Object<Const_ClassMemberPointersUshort>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersUshort_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersUshort_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersUshort() {Dispose(false);}

                public static unsafe MR.CS.Misc.Box<ushort>? Sa
                {
                    get
                    {
                        MR.CS.Misc.Box<ushort>? value = null;
                        if (*__ptr_storage_Sa is not null)
                            value = new(*__ptr_storage_Sa);
                        return value;
                    }
                }
                private protected static unsafe ushort **__ptr_storage_Sa;

                public static unsafe MR.CS.Misc.Const_Box<ushort>? Sb
                {
                    get
                    {
                        MR.CS.Misc.Const_Box<ushort>? value = null;
                        if (*__ptr_storage_Sb is not null)
                            value = new(*__ptr_storage_Sb);
                        return value;
                    }
                }
                private protected static unsafe ushort **__ptr_storage_Sb;

                public static unsafe ref ushort Sc => ref *__ref_storage_Sc;
                private protected static unsafe ushort *__ref_storage_Sc;

                public static unsafe ushort Sd => *__ref_storage_Sd;
                private protected static unsafe ushort *__ref_storage_Sd;

                public unsafe MR.CS.Misc.Box<ushort>? a
                {
                    get
                    {
                        MR.CS.Misc.Box<ushort>? value = null;
                        if (*__ptr_storage_a is not null)
                        {
                            value = new(*__ptr_storage_a);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe ushort **__ptr_storage_a;

                public unsafe MR.CS.Misc.Const_Box<ushort>? b
                {
                    get
                    {
                        MR.CS.Misc.Const_Box<ushort>? value = null;
                        if (*__ptr_storage_b is not null)
                        {
                            value = new(*__ptr_storage_b);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe ushort **__ptr_storage_b;

                public unsafe ref ushort c => ref *__ref_storage_c;
                private protected unsafe ushort *__ref_storage_c;

                public unsafe ushort d => *__ref_storage_d;
                private protected unsafe ushort *__ref_storage_d;

                unsafe static Const_ClassMemberPointersUshort()
                {
                    { // Sa (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sa", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_sa();
                        Const_ClassMemberPointersUshort.__ptr_storage_Sa = __MR_CSharp_ClassMemberPointersUshort_Get_sa();
                    }

                    { // Sb (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sb", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_sb();
                        Const_ClassMemberPointersUshort.__ptr_storage_Sb = __MR_CSharp_ClassMemberPointersUshort_Get_sb();
                    }

                    { // Sc (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sc", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_sc();
                        Const_ClassMemberPointersUshort.__ref_storage_Sc = __MR_CSharp_ClassMemberPointersUshort_Get_sc();
                    }

                    { // Sd (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_sd", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_sd();
                        Const_ClassMemberPointersUshort.__ref_storage_Sd = __MR_CSharp_ClassMemberPointersUshort_Get_sd();
                    }
                }

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_a", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_a(Const_ClassMemberPointersUshort._Underlying *_this);
                        this.__ptr_storage_a = __MR_CSharp_ClassMemberPointersUshort_Get_a(_UnderlyingPtr);
                    }

                    { // b (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_b", ExactSpelling = true)]
                        extern static ushort **__MR_CSharp_ClassMemberPointersUshort_Get_b(Const_ClassMemberPointersUshort._Underlying *_this);
                        this.__ptr_storage_b = __MR_CSharp_ClassMemberPointersUshort_Get_b(_UnderlyingPtr);
                    }

                    { // c (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_c", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_c(MR.CS.CSharp.Const_ClassMemberPointersUshort._Underlying *_this);
                        this.__ref_storage_c = __MR_CSharp_ClassMemberPointersUshort_Get_c(_UnderlyingPtr);
                    }

                    { // d (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_Get_d", ExactSpelling = true)]
                        extern static ushort *__MR_CSharp_ClassMemberPointersUshort_Get_d(MR.CS.CSharp.Const_ClassMemberPointersUshort._Underlying *_this);
                        this.__ref_storage_d = __MR_CSharp_ClassMemberPointersUshort_Get_d(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_ClassMemberPointersUshort(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                /// </summary>
                public unsafe Const_ClassMemberPointersUshort(MR.CS.CSharp.Const_ClassMemberPointersUshort _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersUshort._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                /// </summary>
                public Const_ClassMemberPointersUshort(ClassMemberPointersUshort _other) : this((Const_ClassMemberPointersUshort)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersUshort` elementwise.
                /// </summary>
                public unsafe Const_ClassMemberPointersUshort(MR.CS.Misc.InOut<ushort>? a, ushort? b, ref ushort c, ushort d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFrom(ushort *a, ushort *b, ushort *c, ushort *d);
                    fixed (ushort *__ptr_c = &c)
                    {
                        ushort __value_a = a is not null ? a.Value : default(ushort);
                        ushort __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                        _FinalizeFields();
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersUshort`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ClassMemberPointersUshort : Const_ClassMemberPointersUshort
            {
                public new unsafe MR.CS.Misc.Box<ushort>? a
                {
                    get => base.a;
                    set
                    {
                        _DiscardKeepAlive("a");
                        if (value is not null)
                            _KeepAlive(value, "a");
                        *__ptr_storage_a = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.Misc.Const_Box<ushort>? b
                {
                    get => base.b;
                    set
                    {
                        _DiscardKeepAlive("b");
                        if (value is not null)
                            _KeepAlive(value, "b");
                        *__ptr_storage_b = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe ClassMemberPointersUshort(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                /// </summary>
                public unsafe ClassMemberPointersUshort(MR.CS.CSharp.Const_ClassMemberPointersUshort _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersUshort._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersUshort::ClassMemberPointersUshort`.
                /// </summary>
                public ClassMemberPointersUshort(ClassMemberPointersUshort _other) : this((Const_ClassMemberPointersUshort)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersUshort` elementwise.
                /// </summary>
                public unsafe ClassMemberPointersUshort(MR.CS.Misc.InOut<ushort>? a, ushort? b, ref ushort c, ushort d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersUshort_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersUshort._Underlying *__MR_CSharp_ClassMemberPointersUshort_ConstructFrom(ushort *a, ushort *b, ushort *c, ushort *d);
                    fixed (ushort *__ptr_c = &c)
                    {
                        ushort __value_a = a is not null ? a.Value : default(ushort);
                        ushort __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersUshort_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                        _FinalizeFields();
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersUshort` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersUshort`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersUshort`/`Const_ClassMemberPointersUshort` directly.
            /// </summary>
            public class _InOptMut_ClassMemberPointersUshort
            {
                public ClassMemberPointersUshort? Opt;

                public _InOptMut_ClassMemberPointersUshort() {}
                public _InOptMut_ClassMemberPointersUshort(ClassMemberPointersUshort value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersUshort(ClassMemberPointersUshort value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersUshort` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersUshort`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersUshort`/`Const_ClassMemberPointersUshort` to pass it to the function.
            /// </summary>
            public class _InOptConst_ClassMemberPointersUshort
            {
                public Const_ClassMemberPointersUshort? Opt;

                public _InOptConst_ClassMemberPointersUshort() {}
                public _InOptConst_ClassMemberPointersUshort(Const_ClassMemberPointersUshort value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersUshort(Const_ClassMemberPointersUshort value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersBool`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_ClassMemberPointersBool : MR.CS.Misc.Object<Const_ClassMemberPointersBool>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_ClassMemberPointersBool_Destroy(_Underlying *_this);
                    __MR_CSharp_ClassMemberPointersBool_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_ClassMemberPointersBool() {Dispose(false);}

                public static unsafe MR.CS.Misc.Box<byte>? Sa
                {
                    get
                    {
                        MR.CS.Misc.Box<byte>? value = null;
                        if (*__ptr_storage_Sa is not null)
                            value = new(*__ptr_storage_Sa);
                        return value;
                    }
                }
                private protected static unsafe byte **__ptr_storage_Sa;

                public static unsafe MR.CS.Misc.Const_Box<byte>? Sb
                {
                    get
                    {
                        MR.CS.Misc.Const_Box<byte>? value = null;
                        if (*__ptr_storage_Sb is not null)
                            value = new(*__ptr_storage_Sb);
                        return value;
                    }
                }
                private protected static unsafe byte **__ptr_storage_Sb;

                public static unsafe ref bool Sc => ref *__ref_storage_Sc;
                private protected static unsafe bool *__ref_storage_Sc;

                public static unsafe bool Sd => *__ref_storage_Sd;
                private protected static unsafe bool *__ref_storage_Sd;

                public unsafe MR.CS.Misc.Box<byte>? a
                {
                    get
                    {
                        MR.CS.Misc.Box<byte>? value = null;
                        if (*__ptr_storage_a is not null)
                        {
                            value = new(*__ptr_storage_a);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe byte **__ptr_storage_a;

                public unsafe MR.CS.Misc.Const_Box<byte>? b
                {
                    get
                    {
                        MR.CS.Misc.Const_Box<byte>? value = null;
                        if (*__ptr_storage_b is not null)
                        {
                            value = new(*__ptr_storage_b);
                            value._KeepAliveEnclosingObject = this;
                        }
                        return value;
                    }
                }
                private protected unsafe byte **__ptr_storage_b;

                public unsafe ref bool c => ref *__ref_storage_c;
                private protected unsafe bool *__ref_storage_c;

                public unsafe bool d => *__ref_storage_d;
                private protected unsafe bool *__ref_storage_d;

                unsafe static Const_ClassMemberPointersBool()
                {
                    { // Sa (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sa", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_sa();
                        Const_ClassMemberPointersBool.__ptr_storage_Sa = __MR_CSharp_ClassMemberPointersBool_Get_sa();
                    }

                    { // Sb (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sb", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_sb();
                        Const_ClassMemberPointersBool.__ptr_storage_Sb = __MR_CSharp_ClassMemberPointersBool_Get_sb();
                    }

                    { // Sc (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sc", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_sc();
                        Const_ClassMemberPointersBool.__ref_storage_Sc = __MR_CSharp_ClassMemberPointersBool_Get_sc();
                    }

                    { // Sd (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_sd", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_sd();
                        Const_ClassMemberPointersBool.__ref_storage_Sd = __MR_CSharp_ClassMemberPointersBool_Get_sd();
                    }
                }

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_a", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_a(Const_ClassMemberPointersBool._Underlying *_this);
                        this.__ptr_storage_a = __MR_CSharp_ClassMemberPointersBool_Get_a(_UnderlyingPtr);
                    }

                    { // b (raw pointer)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_b", ExactSpelling = true)]
                        extern static byte **__MR_CSharp_ClassMemberPointersBool_Get_b(Const_ClassMemberPointersBool._Underlying *_this);
                        this.__ptr_storage_b = __MR_CSharp_ClassMemberPointersBool_Get_b(_UnderlyingPtr);
                    }

                    { // c (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_c", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_c(MR.CS.CSharp.Const_ClassMemberPointersBool._Underlying *_this);
                        this.__ref_storage_c = __MR_CSharp_ClassMemberPointersBool_Get_c(_UnderlyingPtr);
                    }

                    { // d (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_Get_d", ExactSpelling = true)]
                        extern static bool *__MR_CSharp_ClassMemberPointersBool_Get_d(MR.CS.CSharp.Const_ClassMemberPointersBool._Underlying *_this);
                        this.__ref_storage_d = __MR_CSharp_ClassMemberPointersBool_Get_d(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_ClassMemberPointersBool(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                /// </summary>
                public unsafe Const_ClassMemberPointersBool(MR.CS.CSharp.Const_ClassMemberPointersBool _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersBool._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                /// </summary>
                public Const_ClassMemberPointersBool(ClassMemberPointersBool _other) : this((Const_ClassMemberPointersBool)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersBool` elementwise.
                /// </summary>
                public unsafe Const_ClassMemberPointersBool(MR.CS.Misc.InOut<bool>? a, bool? b, ref bool c, bool d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFrom(bool *a, bool *b, bool *c, bool *d);
                    fixed (bool *__ptr_c = &c)
                    {
                        bool __value_a = a is not null ? a.Value : default(bool);
                        bool __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                        _FinalizeFields();
                    }
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::ClassMemberPointersBool`.
            /// This is the non-const half of the class.
            /// </summary>
            public class ClassMemberPointersBool : Const_ClassMemberPointersBool
            {
                public new unsafe MR.CS.Misc.Box<byte>? a
                {
                    get => base.a;
                    set
                    {
                        _DiscardKeepAlive("a");
                        if (value is not null)
                            _KeepAlive(value, "a");
                        *__ptr_storage_a = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                public new unsafe MR.CS.Misc.Const_Box<byte>? b
                {
                    get => base.b;
                    set
                    {
                        _DiscardKeepAlive("b");
                        if (value is not null)
                            _KeepAlive(value, "b");
                        *__ptr_storage_b = (value is not null ? value._UnderlyingPtr : null);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe ClassMemberPointersBool(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                /// </summary>
                public unsafe ClassMemberPointersBool(MR.CS.CSharp.Const_ClassMemberPointersBool _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(MR.CS.CSharp.ClassMemberPointersBool._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::ClassMemberPointersBool::ClassMemberPointersBool`.
                /// </summary>
                public ClassMemberPointersBool(ClassMemberPointersBool _other) : this((Const_ClassMemberPointersBool)_other) {}

                /// <summary>
                /// Constructs `MR::CSharp::ClassMemberPointersBool` elementwise.
                /// </summary>
                public unsafe ClassMemberPointersBool(MR.CS.Misc.InOut<bool>? a, bool? b, ref bool c, bool d) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_ClassMemberPointersBool_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ClassMemberPointersBool._Underlying *__MR_CSharp_ClassMemberPointersBool_ConstructFrom(bool *a, bool *b, bool *c, bool *d);
                    fixed (bool *__ptr_c = &c)
                    {
                        bool __value_a = a is not null ? a.Value : default(bool);
                        bool __deref_b = b.GetValueOrDefault();
                        _UnderlyingPtr = __MR_CSharp_ClassMemberPointersBool_ConstructFrom(a is not null ? &__value_a : null, b.HasValue ? &__deref_b : null, __ptr_c, &d);
                        if (a is not null) a.Value = __value_a;
                        _FinalizeFields();
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersBool` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_ClassMemberPointersBool`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersBool`/`Const_ClassMemberPointersBool` directly.
            /// </summary>
            public class _InOptMut_ClassMemberPointersBool
            {
                public ClassMemberPointersBool? Opt;

                public _InOptMut_ClassMemberPointersBool() {}
                public _InOptMut_ClassMemberPointersBool(ClassMemberPointersBool value) {Opt = value;}
                public static implicit operator _InOptMut_ClassMemberPointersBool(ClassMemberPointersBool value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `ClassMemberPointersBool` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_ClassMemberPointersBool`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `ClassMemberPointersBool`/`Const_ClassMemberPointersBool` to pass it to the function.
            /// </summary>
            public class _InOptConst_ClassMemberPointersBool
            {
                public Const_ClassMemberPointersBool? Opt;

                public _InOptConst_ClassMemberPointersBool() {}
                public _InOptConst_ClassMemberPointersBool(Const_ClassMemberPointersBool value) {Opt = value;}
                public static implicit operator _InOptConst_ClassMemberPointersBool(Const_ClassMemberPointersBool value) {return new(value);}
            }

            // Keep-alive sorcery:
            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_LifetimesA : MR.CS.Misc.Object<Const_LifetimesA>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesA_Destroy(_Underlying *_this);
                    __MR_CSharp_LifetimesA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_LifetimesA() {Dispose(false);}

                public unsafe int x => *__ref_storage_x;
                private protected unsafe int *__ref_storage_x;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // x (ref)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_Get_x", ExactSpelling = true)]
                        extern static int *__MR_CSharp_LifetimesA_Get_x(MR.CS.CSharp.Const_LifetimesA._Underlying *_this);
                        this.__ref_storage_x = __MR_CSharp_LifetimesA_Get_x(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_LifetimesA(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_LifetimesA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesA` elementwise.
                /// </summary>
                public unsafe Const_LifetimesA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_ConstructFrom(x);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesA::LifetimesA`.
                /// </summary>
                public unsafe Const_LifetimesA(MR.CS.CSharp.Const_LifetimesA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_ConstructFromAnother(MR.CS.CSharp.LifetimesA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesA::LifetimesA`.
                /// </summary>
                public Const_LifetimesA(LifetimesA _other) : this((Const_LifetimesA)_other) {}
            }

            // Keep-alive sorcery:
            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class LifetimesA : Const_LifetimesA
            {
                public new unsafe ref int x => ref *__ref_storage_x;

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe LifetimesA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe LifetimesA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesA` elementwise.
                /// </summary>
                public unsafe LifetimesA(int x) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_ConstructFrom(int x);
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_ConstructFrom(x);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesA::LifetimesA`.
                /// </summary>
                public unsafe LifetimesA(MR.CS.CSharp.Const_LifetimesA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_ConstructFromAnother(MR.CS.CSharp.LifetimesA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesA::LifetimesA`.
                /// </summary>
                public LifetimesA(LifetimesA _other) : this((Const_LifetimesA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesA assign(MR.CS.CSharp.Const_LifetimesA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.LifetimesA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_LifetimesA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                // Some degenerate cases that have to be ignored in C#, because we don't support the lifetime operations for those types.
                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesA::foo`.
                /// </summary>
                public unsafe ref int foo()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_foo", ExactSpelling = true)]
                    extern static int *__MR_CSharp_LifetimesA_foo(_Underlying *_this);
                    return ref *__MR_CSharp_LifetimesA_foo(_UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesA::bar`.
                /// </summary>
                public unsafe void bar(ref int ref_)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesA_bar", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesA_bar(_Underlying *_this, int *ref_);
                    fixed (int *__ptr_ref_ = &ref_)
                    {
                        __MR_CSharp_LifetimesA_bar(_UnderlyingPtr, __ptr_ref_);
                    }
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_LifetimesA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesA`/`Const_LifetimesA` directly.
            /// </summary>
            public class _InOptMut_LifetimesA
            {
                public LifetimesA? Opt;

                public _InOptMut_LifetimesA() {}
                public _InOptMut_LifetimesA(LifetimesA value) {Opt = value;}
                public static implicit operator _InOptMut_LifetimesA(LifetimesA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_LifetimesA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesA`/`Const_LifetimesA` to pass it to the function.
            /// </summary>
            public class _InOptConst_LifetimesA
            {
                public Const_LifetimesA? Opt;

                public _InOptConst_LifetimesA() {}
                public _InOptConst_LifetimesA(Const_LifetimesA value) {Opt = value;}
                public static implicit operator _InOptConst_LifetimesA(Const_LifetimesA value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_LifetimesB : MR.CS.Misc.Object<Const_LifetimesB>, System.IDisposable, IEnumerable<MR.CS.CSharp.Const_LifetimesA>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesB_Destroy(_Underlying *_this);
                    __MR_CSharp_LifetimesB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_LifetimesB() {Dispose(false);}

                public class _Enumerator : IEnumerator<MR.CS.CSharp.Const_LifetimesA>
                {
                    Const_LifetimesB _container;
                    MR.CS.CSharp.ConstPtrLifetimesA _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_LifetimesB container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public MR.CS.CSharp.Const_LifetimesA Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.CSharp.Const_LifetimesA> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe MR.CS.CSharp.Const_LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_LifetimesB_Get_a(MR.CS.CSharp.Const_LifetimesB._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesB_Get_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_LifetimesB(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_LifetimesB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesB` elementwise.
                /// </summary>
                public unsafe Const_LifetimesB(MR.CS.CSharp.Const_LifetimesA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_ConstructFrom(MR.CS.CSharp.LifetimesA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesB::LifetimesB`.
                /// </summary>
                public unsafe Const_LifetimesB(MR.CS.CSharp.Const_LifetimesB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_ConstructFromAnother(MR.CS.CSharp.LifetimesB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesB::LifetimesB`.
                /// </summary>
                public Const_LifetimesB(LifetimesB _other) : this((Const_LifetimesB)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator*`.
                /// </summary>
                public unsafe MR.CS.CSharp.Const_LifetimesA deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_const_MR_CSharp_LifetimesB_ref", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_C_deref_const_MR_CSharp_LifetimesB_ref(_Underlying *b);
                    MR.CS.CSharp.Const_LifetimesA __ret;
                    __ret = new(__MR_C_deref_const_MR_CSharp_LifetimesB_ref(_UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class LifetimesB : Const_LifetimesB, IEnumerable<MR.CS.CSharp.LifetimesA>
            {
                public new class _Enumerator : IEnumerator<MR.CS.CSharp.LifetimesA>
                {
                    LifetimesB _container;
                    MR.CS.CSharp.PtrLifetimesA _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(LifetimesB container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.CSharp.LifetimesA Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public new IEnumerator<MR.CS.CSharp.LifetimesA> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public new unsafe MR.CS.CSharp.LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesB_GetMutable_a(MR.CS.CSharp.LifetimesB._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesB_GetMutable_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe LifetimesB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe LifetimesB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesB` elementwise.
                /// </summary>
                public unsafe LifetimesB(MR.CS.CSharp.Const_LifetimesA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_ConstructFrom(MR.CS.CSharp.LifetimesA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesB::LifetimesB`.
                /// </summary>
                public unsafe LifetimesB(MR.CS.CSharp.Const_LifetimesB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_ConstructFromAnother(MR.CS.CSharp.LifetimesB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesB::LifetimesB`.
                /// </summary>
                public LifetimesB(LifetimesB _other) : this((Const_LifetimesB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesB assign(MR.CS.CSharp.Const_LifetimesB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesB._Underlying *__MR_CSharp_LifetimesB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.LifetimesB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_LifetimesB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                // `--infer-lifetime-iterators` should act on those:
                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesB::begin`.
                /// </summary>
                public unsafe MR.CS.CSharp.PtrLifetimesA begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_begin", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesB_begin(_Underlying *_this);
                    var __c_ret = __MR_CSharp_LifetimesB_begin(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesB::end`.
                /// </summary>
                public unsafe MR.CS.CSharp.PtrLifetimesA end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesB_end", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesB_end(_Underlying *_this);
                    var __c_ret = __MR_CSharp_LifetimesB_end(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesB::operator*`.
                /// </summary>
                public unsafe new MR.CS.CSharp.LifetimesA deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_LifetimesB_ref", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_C_deref_MR_CSharp_LifetimesB_ref(_Underlying *_this);
                    MR.CS.CSharp.LifetimesA __ret;
                    __ret = new(__MR_C_deref_MR_CSharp_LifetimesB_ref(_UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_LifetimesB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesB`/`Const_LifetimesB` directly.
            /// </summary>
            public class _InOptMut_LifetimesB
            {
                public LifetimesB? Opt;

                public _InOptMut_LifetimesB() {}
                public _InOptMut_LifetimesB(LifetimesB value) {Opt = value;}
                public static implicit operator _InOptMut_LifetimesB(LifetimesB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_LifetimesB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesB`/`Const_LifetimesB` to pass it to the function.
            /// </summary>
            public class _InOptConst_LifetimesB
            {
                public Const_LifetimesB? Opt;

                public _InOptConst_LifetimesB() {}
                public _InOptConst_LifetimesB(Const_LifetimesB value) {Opt = value;}
                public static implicit operator _InOptConst_LifetimesB(Const_LifetimesB value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_LifetimesC : MR.CS.Misc.Object<Const_LifetimesC>, System.IDisposable, IEnumerable<MR.CS.CSharp.Const_LifetimesA>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesC_Destroy(_Underlying *_this);
                    __MR_CSharp_LifetimesC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_LifetimesC() {Dispose(false);}

                public class _Enumerator : IEnumerator<MR.CS.CSharp.Const_LifetimesA>
                {
                    Const_LifetimesC _container;
                    MR.CS.CSharp.ConstPtrLifetimesA _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_LifetimesC container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public MR.CS.CSharp.Const_LifetimesA Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.CSharp.Const_LifetimesA> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe MR.CS.CSharp.Const_LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_LifetimesC_Get_a(MR.CS.CSharp.Const_LifetimesC._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesC_Get_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_LifetimesC(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_LifetimesC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesC` elementwise.
                /// </summary>
                public unsafe Const_LifetimesC(MR.CS.CSharp.Const_LifetimesA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_ConstructFrom(MR.CS.CSharp.LifetimesA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesC::LifetimesC`.
                /// </summary>
                public unsafe Const_LifetimesC(MR.CS.CSharp.Const_LifetimesC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_ConstructFromAnother(MR.CS.CSharp.LifetimesC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesC::LifetimesC`.
                /// </summary>
                public Const_LifetimesC(LifetimesC _other) : this((Const_LifetimesC)_other) {}

                /// <summary>
                /// Generated from function `MR::CSharp::operator*`.
                /// </summary>
                public unsafe MR.CS.CSharp.Const_LifetimesA deref()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_LifetimesC", ExactSpelling = true)]
                    extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_C_deref_MR_CSharp_LifetimesC(_Underlying *c);
                    MR.CS.CSharp.Const_LifetimesA __ret;
                    __ret = new(__MR_C_deref_MR_CSharp_LifetimesC(_UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class LifetimesC : Const_LifetimesC
            {
                public new unsafe MR.CS.CSharp.LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesC_GetMutable_a(MR.CS.CSharp.LifetimesC._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesC_GetMutable_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe LifetimesC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe LifetimesC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Constructs `MR::CSharp::LifetimesC` elementwise.
                /// </summary>
                public unsafe LifetimesC(MR.CS.CSharp.Const_LifetimesA a) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_ConstructFrom", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_ConstructFrom(MR.CS.CSharp.LifetimesA._Underlying *a);
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_ConstructFrom(a._UnderlyingPtr);
                    _KeepAlive(a);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesC::LifetimesC`.
                /// </summary>
                public unsafe LifetimesC(MR.CS.CSharp.Const_LifetimesC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_ConstructFromAnother(MR.CS.CSharp.LifetimesC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesC::LifetimesC`.
                /// </summary>
                public LifetimesC(LifetimesC _other) : this((Const_LifetimesC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesC assign(MR.CS.CSharp.Const_LifetimesC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesC._Underlying *__MR_CSharp_LifetimesC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.LifetimesC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_LifetimesC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_LifetimesC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesC`/`Const_LifetimesC` directly.
            /// </summary>
            public class _InOptMut_LifetimesC
            {
                public LifetimesC? Opt;

                public _InOptMut_LifetimesC() {}
                public _InOptMut_LifetimesC(LifetimesC value) {Opt = value;}
                public static implicit operator _InOptMut_LifetimesC(LifetimesC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_LifetimesC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesC`/`Const_LifetimesC` to pass it to the function.
            /// </summary>
            public class _InOptConst_LifetimesC
            {
                public Const_LifetimesC? Opt;

                public _InOptConst_LifetimesC() {}
                public _InOptConst_LifetimesC(Const_LifetimesC value) {Opt = value;}
                public static implicit operator _InOptConst_LifetimesC(Const_LifetimesC value) {return new(value);}
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_LifetimesD : MR.CS.Misc.Object<Const_LifetimesD>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesD_Destroy(_Underlying *_this);
                    __MR_CSharp_LifetimesD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_LifetimesD() {Dispose(false);}

                public unsafe MR.CS.CSharp.Const_LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Get_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_LifetimesD_Get_a(MR.CS.CSharp.Const_LifetimesD._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesD_Get_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_LifetimesD(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe Const_LifetimesD(MR.CS.CSharp.Const_LifetimesD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_ConstructFromAnother(MR.CS.CSharp.LifetimesD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public Const_LifetimesD(LifetimesD _other) : this((Const_LifetimesD)_other) {}

                // Store param references in this. The two annotation styles are equivalent for constructors.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe Const_LifetimesD(MR.CS.CSharp.LifetimesA ref_, MR.CS.CSharp.LifetimesB other_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_2", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_2(MR.CS.CSharp.LifetimesA._Underlying *ref_, MR.CS.CSharp.LifetimesB._Underlying *other_ref);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_2(ref_._UnderlyingPtr, other_ref._UnderlyingPtr);
                    _KeepAlive(ref_);
                    _KeepAlive(other_ref);
                    _FinalizeFields();
                }

                // `--infer-lifetime-constructors` should act on this.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe Const_LifetimesD(MR.CS.CSharp.LifetimesA ref_) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA(MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA(ref_._UnderlyingPtr);
                    _FinalizeFields();
                }

                // `--infer-lifetime-constructors` should act on this.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator Const_LifetimesD(MR.CS.CSharp.LifetimesA ref_) {return new(ref_);}

                // Store reference to this in param.
                // `--infer-lifetime-constructors` skips this, because we already have custom attributes.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe Const_LifetimesD(MR.CS.CSharp.LifetimesB ref_) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB(MR.CS.CSharp.LifetimesB._Underlying *ref_);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB(ref_._UnderlyingPtr);
                    ref_._KeepAlive(this);
                    _FinalizeFields();
                }

                // Store reference to this in param.
                // `--infer-lifetime-constructors` skips this, because we already have custom attributes.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator Const_LifetimesD(MR.CS.CSharp.LifetimesB ref_) {return new(ref_);}

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::return_ref_static`.
                /// </summary>
                public static unsafe MR.CS.CSharp.LifetimesA returnRefStatic(MR.CS.CSharp.LifetimesA ref_)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_return_ref_static", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesD_return_ref_static(MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    MR.CS.CSharp.LifetimesA __ret;
                    __ret = new(__MR_CSharp_LifetimesD_return_ref_static(ref_._UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(ref_);
                    return __ret;
                }
            }

            /// <summary>
            /// Generated from class `MR::CSharp::LifetimesD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class LifetimesD : Const_LifetimesD
            {
                public new unsafe MR.CS.CSharp.LifetimesA a {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // a
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_GetMutable_a", ExactSpelling = true)]
                        extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesD_GetMutable_a(MR.CS.CSharp.LifetimesD._Underlying *_this);
                        this.a = new(__MR_CSharp_LifetimesD_GetMutable_a(_UnderlyingPtr), is_owning: false);
                        this.a._KeepAliveEnclosingObject = this;
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe LifetimesD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe LifetimesD(MR.CS.CSharp.Const_LifetimesD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_ConstructFromAnother(MR.CS.CSharp.LifetimesD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public LifetimesD(LifetimesD _other) : this((Const_LifetimesD)_other) {}

                // Store param references in this. The two annotation styles are equivalent for constructors.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe LifetimesD(MR.CS.CSharp.LifetimesA ref_, MR.CS.CSharp.LifetimesB other_ref) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_2", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_2(MR.CS.CSharp.LifetimesA._Underlying *ref_, MR.CS.CSharp.LifetimesB._Underlying *other_ref);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_2(ref_._UnderlyingPtr, other_ref._UnderlyingPtr);
                    _KeepAlive(ref_);
                    _KeepAlive(other_ref);
                    _FinalizeFields();
                }

                // `--infer-lifetime-constructors` should act on this.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe LifetimesD(MR.CS.CSharp.LifetimesA ref_) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA(MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesA(ref_._UnderlyingPtr);
                    _FinalizeFields();
                }

                // `--infer-lifetime-constructors` should act on this.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator LifetimesD(MR.CS.CSharp.LifetimesA ref_) {return new(ref_);}

                // Store reference to this in param.
                // `--infer-lifetime-constructors` skips this, because we already have custom attributes.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public unsafe LifetimesD(MR.CS.CSharp.LifetimesB ref_) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB(MR.CS.CSharp.LifetimesB._Underlying *ref_);
                    _UnderlyingPtr = __MR_CSharp_LifetimesD_Construct_1_MR_CSharp_LifetimesB(ref_._UnderlyingPtr);
                    ref_._KeepAlive(this);
                    _FinalizeFields();
                }

                // Store reference to this in param.
                // `--infer-lifetime-constructors` skips this, because we already have custom attributes.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator LifetimesD(MR.CS.CSharp.LifetimesB ref_) {return new(ref_);}

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesD assign(MR.CS.CSharp.Const_LifetimesD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesD._Underlying *__MR_CSharp_LifetimesD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.LifetimesD._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_LifetimesD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::get`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesA get()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_get", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesD_get(_Underlying *_this);
                    MR.CS.CSharp.LifetimesA __ret;
                    __ret = new(__MR_CSharp_LifetimesD_get(_UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(this);
                    return __ret;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::return_ref`.
                /// </summary>
                public unsafe MR.CS.CSharp.LifetimesA returnRef(MR.CS.CSharp.LifetimesA ref_)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_return_ref", ExactSpelling = true)]
                    extern static MR.CS.CSharp.LifetimesA._Underlying *__MR_CSharp_LifetimesD_return_ref(_Underlying *_this, MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    MR.CS.CSharp.LifetimesA __ret;
                    __ret = new(__MR_CSharp_LifetimesD_return_ref(_UnderlyingPtr, ref_._UnderlyingPtr), is_owning: false);
                    __ret._KeepAlive(ref_);
                    return __ret;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::store_ref_in_this`.
                /// </summary>
                public unsafe void storeRefInThis(MR.CS.CSharp.LifetimesA ref_)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_store_ref_in_this", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesD_store_ref_in_this(_Underlying *_this, MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    _KeepAlive(ref_);
                    __MR_CSharp_LifetimesD_store_ref_in_this(_UnderlyingPtr, ref_._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::store_ref_in_param`.
                /// </summary>
                public unsafe void storeRefInParam(MR.CS.CSharp.LifetimesA ref_, MR.CS.CSharp.LifetimesB other_ref)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_store_ref_in_param", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesD_store_ref_in_param(_Underlying *_this, MR.CS.CSharp.LifetimesA._Underlying *ref_, MR.CS.CSharp.LifetimesB._Underlying *other_ref);
                    other_ref._KeepAlive(ref_);
                    __MR_CSharp_LifetimesD_store_ref_in_param(_UnderlyingPtr, ref_._UnderlyingPtr, other_ref._UnderlyingPtr);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::LifetimesD::store_this_in_param`.
                /// </summary>
                public unsafe void storeThisInParam(MR.CS.CSharp.LifetimesA ref_)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_LifetimesD_store_this_in_param", ExactSpelling = true)]
                    extern static void __MR_CSharp_LifetimesD_store_this_in_param(_Underlying *_this, MR.CS.CSharp.LifetimesA._Underlying *ref_);
                    ref_._KeepAlive(this);
                    __MR_CSharp_LifetimesD_store_this_in_param(_UnderlyingPtr, ref_._UnderlyingPtr);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_LifetimesD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesD`/`Const_LifetimesD` directly.
            /// </summary>
            public class _InOptMut_LifetimesD
            {
                public LifetimesD? Opt;

                public _InOptMut_LifetimesD() {}
                public _InOptMut_LifetimesD(LifetimesD value) {Opt = value;}
                public static implicit operator _InOptMut_LifetimesD(LifetimesD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `LifetimesD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_LifetimesD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `LifetimesD`/`Const_LifetimesD` to pass it to the function.
            /// </summary>
            public class _InOptConst_LifetimesD
            {
                public Const_LifetimesD? Opt;

                public _InOptConst_LifetimesD() {}
                public _InOptConst_LifetimesD(Const_LifetimesD value) {Opt = value;}
                public static implicit operator _InOptConst_LifetimesD(Const_LifetimesD value) {return new(value);}

                // `--infer-lifetime-constructors` should act on this.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_LifetimesD(MR.CS.CSharp.LifetimesA ref_) {return new Const_LifetimesD(ref_);}

                // Store reference to this in param.
                // `--infer-lifetime-constructors` skips this, because we already have custom attributes.
                /// <summary>
                /// Generated from constructor `MR::CSharp::LifetimesD::LifetimesD`.
                /// </summary>
                public static unsafe implicit operator _InOptConst_LifetimesD(MR.CS.CSharp.LifetimesB ref_) {return new Const_LifetimesD(ref_);}
            }

            // Const member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableA`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableA : MR.CS.Misc.Object<Const_IterableA>, System.IDisposable, IEnumerable<int>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableA_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableA_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableA() {Dispose(false);}

                public class _Enumerator : IEnumerator<int>
                {
                    Const_IterableA _container;
                    MR.CS.ConstPtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_IterableA container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableA_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableA_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableA(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableA._Underlying *__MR_CSharp_IterableA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableA::IterableA`.
                /// </summary>
                public unsafe Const_IterableA(MR.CS.CSharp.Const_IterableA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableA._Underlying *__MR_CSharp_IterableA_ConstructFromAnother(MR.CS.CSharp.IterableA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableA::IterableA`.
                /// </summary>
                public Const_IterableA(IterableA _other) : this((Const_IterableA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableA::begin`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_begin", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableA_begin(_Underlying *_this);
                    return new(__MR_CSharp_IterableA_begin(_UnderlyingPtr));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableA::end`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_end", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableA_end(_Underlying *_this);
                    return new(__MR_CSharp_IterableA_end(_UnderlyingPtr));
                }
            }

            // Const member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableA`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableA : Const_IterableA
            {
                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableA(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableA() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableA._Underlying *__MR_CSharp_IterableA_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableA_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableA::IterableA`.
                /// </summary>
                public unsafe IterableA(MR.CS.CSharp.Const_IterableA _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableA._Underlying *__MR_CSharp_IterableA_ConstructFromAnother(MR.CS.CSharp.IterableA._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableA_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableA::IterableA`.
                /// </summary>
                public IterableA(IterableA _other) : this((Const_IterableA)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableA::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableA assign(MR.CS.CSharp.Const_IterableA _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableA_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableA._Underlying *__MR_CSharp_IterableA_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableA._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableA_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableA` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableA`/`Const_IterableA` directly.
            /// </summary>
            public class _InOptMut_IterableA
            {
                public IterableA? Opt;

                public _InOptMut_IterableA() {}
                public _InOptMut_IterableA(IterableA value) {Opt = value;}
                public static implicit operator _InOptMut_IterableA(IterableA value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableA` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableA`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableA`/`Const_IterableA` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableA
            {
                public Const_IterableA? Opt;

                public _InOptConst_IterableA() {}
                public _InOptConst_IterableA(Const_IterableA value) {Opt = value;}
                public static implicit operator _InOptConst_IterableA(Const_IterableA value) {return new(value);}
            }

            // Mutable member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableB`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableB : MR.CS.Misc.Object<Const_IterableB>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableB_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableB_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableB() {Dispose(false);}

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableB_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableB_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableB(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableB._Underlying *__MR_CSharp_IterableB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableB::IterableB`.
                /// </summary>
                public unsafe Const_IterableB(MR.CS.CSharp.Const_IterableB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableB._Underlying *__MR_CSharp_IterableB_ConstructFromAnother(MR.CS.CSharp.IterableB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableB::IterableB`.
                /// </summary>
                public Const_IterableB(IterableB _other) : this((Const_IterableB)_other) {}
            }

            // Mutable member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableB`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableB : Const_IterableB, IEnumerable<MR.CS.Misc.Ref<int>>
            {
                public class _Enumerator : IEnumerator<MR.CS.Misc.Ref<int>>
                {
                    IterableB _container;
                    MR.CS.PtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableB container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Misc.Ref<int> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(ref _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Misc.Ref<int>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableB(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableB() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableB._Underlying *__MR_CSharp_IterableB_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableB_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableB::IterableB`.
                /// </summary>
                public unsafe IterableB(MR.CS.CSharp.Const_IterableB _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableB._Underlying *__MR_CSharp_IterableB_ConstructFromAnother(MR.CS.CSharp.IterableB._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableB_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableB::IterableB`.
                /// </summary>
                public IterableB(IterableB _other) : this((Const_IterableB)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableB::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableB assign(MR.CS.CSharp.Const_IterableB _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableB._Underlying *__MR_CSharp_IterableB_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableB._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableB_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableB::begin`.
                /// </summary>
                public unsafe MR.CS.PtrInt32T begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_begin", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableB_begin(_Underlying *_this);
                    return new(__MR_CSharp_IterableB_begin(_UnderlyingPtr));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableB::end`.
                /// </summary>
                public unsafe MR.CS.PtrInt32T end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableB_end", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableB_end(_Underlying *_this);
                    return new(__MR_CSharp_IterableB_end(_UnderlyingPtr));
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableB` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableB`/`Const_IterableB` directly.
            /// </summary>
            public class _InOptMut_IterableB
            {
                public IterableB? Opt;

                public _InOptMut_IterableB() {}
                public _InOptMut_IterableB(IterableB value) {Opt = value;}
                public static implicit operator _InOptMut_IterableB(IterableB value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableB` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableB`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableB`/`Const_IterableB` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableB
            {
                public Const_IterableB? Opt;

                public _InOptConst_IterableB() {}
                public _InOptConst_IterableB(Const_IterableB value) {Opt = value;}
                public static implicit operator _InOptConst_IterableB(Const_IterableB value) {return new(value);}
            }

            // Both const and mutable member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableC`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableC : MR.CS.Misc.Object<Const_IterableC>, System.IDisposable, IEnumerable<int>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableC_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableC_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableC() {Dispose(false);}

                public class _Enumerator : IEnumerator<int>
                {
                    Const_IterableC _container;
                    MR.CS.ConstPtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_IterableC container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableC_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableC_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableC(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableC._Underlying *__MR_CSharp_IterableC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableC_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableC::IterableC`.
                /// </summary>
                public unsafe Const_IterableC(MR.CS.CSharp.Const_IterableC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableC._Underlying *__MR_CSharp_IterableC_ConstructFromAnother(MR.CS.CSharp.IterableC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableC::IterableC`.
                /// </summary>
                public Const_IterableC(IterableC _other) : this((Const_IterableC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableC::begin`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_begin", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableC_begin(_Underlying *_this);
                    return new(__MR_CSharp_IterableC_begin(_UnderlyingPtr));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableC::end`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_end", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableC_end(_Underlying *_this);
                    return new(__MR_CSharp_IterableC_end(_UnderlyingPtr));
                }
            }

            // Both const and mutable member functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableC`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableC : Const_IterableC, IEnumerable<MR.CS.Misc.Ref<int>>
            {
                public new class _Enumerator : IEnumerator<MR.CS.Misc.Ref<int>>
                {
                    IterableC _container;
                    MR.CS.PtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableC container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Misc.Ref<int> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(ref _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public new IEnumerator<MR.CS.Misc.Ref<int>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableC(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableC() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableC._Underlying *__MR_CSharp_IterableC_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableC_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableC::IterableC`.
                /// </summary>
                public unsafe IterableC(MR.CS.CSharp.Const_IterableC _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableC._Underlying *__MR_CSharp_IterableC_ConstructFromAnother(MR.CS.CSharp.IterableC._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableC_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableC::IterableC`.
                /// </summary>
                public IterableC(IterableC _other) : this((Const_IterableC)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableC::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableC assign(MR.CS.CSharp.Const_IterableC _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableC._Underlying *__MR_CSharp_IterableC_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableC._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableC_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableC::begin`.
                /// </summary>
                public unsafe new MR.CS.PtrInt32T begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_begin_mut", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableC_begin_mut(_Underlying *_this);
                    return new(__MR_CSharp_IterableC_begin_mut(_UnderlyingPtr));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableC::end`.
                /// </summary>
                public unsafe new MR.CS.PtrInt32T end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableC_end_mut", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableC_end_mut(_Underlying *_this);
                    return new(__MR_CSharp_IterableC_end_mut(_UnderlyingPtr));
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableC` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableC`/`Const_IterableC` directly.
            /// </summary>
            public class _InOptMut_IterableC
            {
                public IterableC? Opt;

                public _InOptMut_IterableC() {}
                public _InOptMut_IterableC(IterableC value) {Opt = value;}
                public static implicit operator _InOptMut_IterableC(IterableC value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableC` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableC`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableC`/`Const_IterableC` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableC
            {
                public Const_IterableC? Opt;

                public _InOptConst_IterableC() {}
                public _InOptConst_IterableC(Const_IterableC value) {Opt = value;}
                public static implicit operator _InOptConst_IterableC(Const_IterableC value) {return new(value);}
            }

            // Const free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableD`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableD : MR.CS.Misc.Object<Const_IterableD>, System.IDisposable, IEnumerable<int>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableD_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableD_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableD() {Dispose(false);}

                public class _Enumerator : IEnumerator<int>
                {
                    Const_IterableD _container;
                    MR.CS.ConstPtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_IterableD container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableD_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableD_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableD(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableD._Underlying *__MR_CSharp_IterableD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableD_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableD::IterableD`.
                /// </summary>
                public unsafe Const_IterableD(MR.CS.CSharp.Const_IterableD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableD._Underlying *__MR_CSharp_IterableD_ConstructFromAnother(MR.CS.CSharp.IterableD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableD::IterableD`.
                /// </summary>
                public Const_IterableD(IterableD _other) : this((Const_IterableD)_other) {}
            }

            // Const free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableD`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableD : Const_IterableD
            {
                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableD(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableD() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableD._Underlying *__MR_CSharp_IterableD_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableD_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableD::IterableD`.
                /// </summary>
                public unsafe IterableD(MR.CS.CSharp.Const_IterableD _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableD._Underlying *__MR_CSharp_IterableD_ConstructFromAnother(MR.CS.CSharp.IterableD._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableD_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableD::IterableD`.
                /// </summary>
                public IterableD(IterableD _other) : this((Const_IterableD)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableD::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableD assign(MR.CS.CSharp.Const_IterableD _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableD_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableD._Underlying *__MR_CSharp_IterableD_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableD._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableD_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableD` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableD`/`Const_IterableD` directly.
            /// </summary>
            public class _InOptMut_IterableD
            {
                public IterableD? Opt;

                public _InOptMut_IterableD() {}
                public _InOptMut_IterableD(IterableD value) {Opt = value;}
                public static implicit operator _InOptMut_IterableD(IterableD value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableD` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableD`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableD`/`Const_IterableD` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableD
            {
                public Const_IterableD? Opt;

                public _InOptConst_IterableD() {}
                public _InOptConst_IterableD(Const_IterableD value) {Opt = value;}
                public static implicit operator _InOptConst_IterableD(Const_IterableD value) {return new(value);}
            }

            // Mutable free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableE`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableE : MR.CS.Misc.Object<Const_IterableE>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableE_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableE_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableE() {Dispose(false);}

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableE_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableE_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableE(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableE._Underlying *__MR_CSharp_IterableE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableE_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableE::IterableE`.
                /// </summary>
                public unsafe Const_IterableE(MR.CS.CSharp.Const_IterableE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableE._Underlying *__MR_CSharp_IterableE_ConstructFromAnother(MR.CS.CSharp.IterableE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableE::IterableE`.
                /// </summary>
                public Const_IterableE(IterableE _other) : this((Const_IterableE)_other) {}
            }

            // Mutable free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableE`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableE : Const_IterableE, IEnumerable<MR.CS.Misc.Ref<int>>
            {
                public class _Enumerator : IEnumerator<MR.CS.Misc.Ref<int>>
                {
                    IterableE _container;
                    MR.CS.PtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableE container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public MR.CS.Misc.Ref<int> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(ref _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Misc.Ref<int>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableE(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableE() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableE._Underlying *__MR_CSharp_IterableE_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableE_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableE::IterableE`.
                /// </summary>
                public unsafe IterableE(MR.CS.CSharp.Const_IterableE _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableE._Underlying *__MR_CSharp_IterableE_ConstructFromAnother(MR.CS.CSharp.IterableE._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableE_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableE::IterableE`.
                /// </summary>
                public IterableE(IterableE _other) : this((Const_IterableE)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableE::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableE assign(MR.CS.CSharp.Const_IterableE _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableE_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableE._Underlying *__MR_CSharp_IterableE_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableE._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableE_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableE` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableE`/`Const_IterableE` directly.
            /// </summary>
            public class _InOptMut_IterableE
            {
                public IterableE? Opt;

                public _InOptMut_IterableE() {}
                public _InOptMut_IterableE(IterableE value) {Opt = value;}
                public static implicit operator _InOptMut_IterableE(IterableE value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableE` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableE`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableE`/`Const_IterableE` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableE
            {
                public Const_IterableE? Opt;

                public _InOptConst_IterableE() {}
                public _InOptConst_IterableE(Const_IterableE value) {Opt = value;}
                public static implicit operator _InOptConst_IterableE(Const_IterableE value) {return new(value);}
            }

            // Both const and mutable free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableF`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableF : MR.CS.Misc.Object<Const_IterableF>, System.IDisposable, IEnumerable<int>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableF_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableF_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableF() {Dispose(false);}

                public class _Enumerator : IEnumerator<int>
                {
                    Const_IterableF _container;
                    MR.CS.ConstPtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_IterableF container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableF_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableF_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableF(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableF._Underlying *__MR_CSharp_IterableF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableF_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableF::IterableF`.
                /// </summary>
                public unsafe Const_IterableF(MR.CS.CSharp.Const_IterableF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableF._Underlying *__MR_CSharp_IterableF_ConstructFromAnother(MR.CS.CSharp.IterableF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableF::IterableF`.
                /// </summary>
                public Const_IterableF(IterableF _other) : this((Const_IterableF)_other) {}
            }

            // Both const and mutable free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableF`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableF : Const_IterableF, IEnumerable<MR.CS.Misc.Ref<int>>
            {
                public new class _Enumerator : IEnumerator<MR.CS.Misc.Ref<int>>
                {
                    IterableF _container;
                    MR.CS.PtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableF container)
                    {
                        _container = container;
                        _cur = MR.CS.CSharp.begin(_container);
                        _done = _cur == MR.CS.CSharp.end(_container);
                    }

                    public MR.CS.Misc.Ref<int> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(ref _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == MR.CS.CSharp.end(_container))
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = MR.CS.CSharp.begin(_container);
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public new IEnumerator<MR.CS.Misc.Ref<int>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableF(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableF() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableF._Underlying *__MR_CSharp_IterableF_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableF_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableF::IterableF`.
                /// </summary>
                public unsafe IterableF(MR.CS.CSharp.Const_IterableF _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableF._Underlying *__MR_CSharp_IterableF_ConstructFromAnother(MR.CS.CSharp.IterableF._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableF_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableF::IterableF`.
                /// </summary>
                public IterableF(IterableF _other) : this((Const_IterableF)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableF::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableF assign(MR.CS.CSharp.Const_IterableF _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableF_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableF._Underlying *__MR_CSharp_IterableF_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableF._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableF_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableF` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableF`/`Const_IterableF` directly.
            /// </summary>
            public class _InOptMut_IterableF
            {
                public IterableF? Opt;

                public _InOptMut_IterableF() {}
                public _InOptMut_IterableF(IterableF value) {Opt = value;}
                public static implicit operator _InOptMut_IterableF(IterableF value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableF` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableF`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableF`/`Const_IterableF` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableF
            {
                public Const_IterableF? Opt;

                public _InOptConst_IterableF() {}
                public _InOptConst_IterableF(Const_IterableF value) {Opt = value;}
                public static implicit operator _InOptConst_IterableF(Const_IterableF value) {return new(value);}
            }

            // Returning mutable class instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableG`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableG : MR.CS.Misc.Object<Const_IterableG>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableG_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableG_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableG() {Dispose(false);}

                public unsafe MR.CS.Std.ArrayString3 arr {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableG_Get_arr(_Underlying *_this);
                        this.arr = new(__MR_CSharp_IterableG_Get_arr(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableG(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableG._Underlying *__MR_CSharp_IterableG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableG_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public unsafe Const_IterableG(MR.CS.CSharp._ByValue_IterableG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableG._Underlying *__MR_CSharp_IterableG_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableG_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public Const_IterableG(Const_IterableG _other) : this(new _ByValue_IterableG(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public Const_IterableG(IterableG _other) : this((Const_IterableG)_other) {}
            }

            // Returning mutable class instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableG`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableG : Const_IterableG, IEnumerable<MR.CS.Std.String>
            {
                public class _Enumerator : IEnumerator<MR.CS.Std.String>
                {
                    IterableG _container;
                    MR.CS.Std.PtrString _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableG container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Std.String Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Std.String> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe MR.CS.Std.ArrayString3 arr {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // arr (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_GetMutable_arr", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableG_GetMutable_arr(_Underlying *_this);
                        this.arr = new(__MR_CSharp_IterableG_GetMutable_arr(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableG(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableG() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableG._Underlying *__MR_CSharp_IterableG_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableG_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public unsafe IterableG(MR.CS.CSharp._ByValue_IterableG _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableG._Underlying *__MR_CSharp_IterableG_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableG._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableG_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public IterableG(Const_IterableG _other) : this(new _ByValue_IterableG(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableG::IterableG`.
                /// </summary>
                public IterableG(IterableG _other) : this((Const_IterableG)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableG::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableG assign(MR.CS.CSharp._ByValue_IterableG _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableG._Underlying *__MR_CSharp_IterableG_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableG._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_IterableG_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableG::begin`.
                /// </summary>
                public unsafe MR.CS.Std.PtrString begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_begin", ExactSpelling = true)]
                    extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableG_begin(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableG_begin(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableG::end`.
                /// </summary>
                public unsafe MR.CS.Std.PtrString end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableG_end", ExactSpelling = true)]
                    extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableG_end(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableG_end(_UnderlyingPtr);
                    return new(__c_ret);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `IterableG` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `IterableG`/`Const_IterableG` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_IterableG
            {
                internal readonly Const_IterableG? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IterableG() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IterableG(Const_IterableG new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_IterableG(Const_IterableG arg) {return new(arg);}
                public _ByValue_IterableG(MR.CS.Misc._Moved<IterableG> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IterableG(MR.CS.Misc._Moved<IterableG> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableG` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableG`/`Const_IterableG` directly.
            /// </summary>
            public class _InOptMut_IterableG
            {
                public IterableG? Opt;

                public _InOptMut_IterableG() {}
                public _InOptMut_IterableG(IterableG value) {Opt = value;}
                public static implicit operator _InOptMut_IterableG(IterableG value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableG` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableG`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableG`/`Const_IterableG` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableG
            {
                public Const_IterableG? Opt;

                public _InOptConst_IterableG() {}
                public _InOptConst_IterableG(Const_IterableG value) {Opt = value;}
                public static implicit operator _InOptConst_IterableG(Const_IterableG value) {return new(value);}
            }

            // Returning const class instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableH`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableH : MR.CS.Misc.Object<Const_IterableH>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableH_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableH_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableH() {Dispose(false);}

                public unsafe MR.CS.Std.ArrayString3 arr {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableH_Get_arr(_Underlying *_this);
                        this.arr = new(__MR_CSharp_IterableH_Get_arr(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableH(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableH._Underlying *__MR_CSharp_IterableH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableH_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public unsafe Const_IterableH(MR.CS.CSharp._ByValue_IterableH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableH._Underlying *__MR_CSharp_IterableH_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableH_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public Const_IterableH(Const_IterableH _other) : this(new _ByValue_IterableH(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public Const_IterableH(IterableH _other) : this((Const_IterableH)_other) {}
            }

            // Returning const class instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableH`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableH : Const_IterableH, IEnumerable<MR.CS.Std.Const_String>
            {
                public class _Enumerator : IEnumerator<MR.CS.Std.Const_String>
                {
                    IterableH _container;
                    MR.CS.Std.ConstPtrString _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableH container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Std.Const_String Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Std.Const_String> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe MR.CS.Std.ArrayString3 arr {get; private protected set;}

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected new unsafe void _FinalizeFields()
                {
                    base._FinalizeFields();

                    { // arr (array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_GetMutable_arr", ExactSpelling = true)]
                        extern static MR.CS.Std.String._Underlying *__MR_CSharp_IterableH_GetMutable_arr(_Underlying *_this);
                        this.arr = new(__MR_CSharp_IterableH_GetMutable_arr(_UnderlyingPtr));
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableH(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableH() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableH._Underlying *__MR_CSharp_IterableH_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableH_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public unsafe IterableH(MR.CS.CSharp._ByValue_IterableH _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableH._Underlying *__MR_CSharp_IterableH_ConstructFromAnother(MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableH._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableH_ConstructFromAnother(_other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null);
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public IterableH(Const_IterableH _other) : this(new _ByValue_IterableH(_other)) {}

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableH::IterableH`.
                /// </summary>
                public IterableH(IterableH _other) : this((Const_IterableH)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableH::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableH assign(MR.CS.CSharp._ByValue_IterableH _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableH._Underlying *__MR_CSharp_IterableH_AssignFromAnother(_Underlying *_this, MR.CS.Misc._PassBy _other_pass_by, MR.CS.CSharp.IterableH._Underlying *_other);
                    _DiscardKeepAlive();
                    if (_other.Value is not null) _KeepAlive(_other.Value);
                    return new(__MR_CSharp_IterableH_AssignFromAnother(_UnderlyingPtr, _other.PassByMode, _other.Value is not null ? _other.Value._UnderlyingPtr : null), is_owning: false);
                }

                // Not making those functions `const` for a change.
                /// <summary>
                /// Generated from method `MR::CSharp::IterableH::begin`.
                /// </summary>
                public unsafe MR.CS.Std.ConstPtrString begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_begin", ExactSpelling = true)]
                    extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_IterableH_begin(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableH_begin(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableH::end`.
                /// </summary>
                public unsafe MR.CS.Std.ConstPtrString end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableH_end", ExactSpelling = true)]
                    extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_IterableH_end(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableH_end(_UnderlyingPtr);
                    return new(__c_ret);
                }
            }

            /// <summary>
            /// This is used as a function parameter when the underlying function receives `IterableH` by value.
            /// Usage:
            /// * Pass `new()` to default-construct the instance.
            /// * Pass an instance of `IterableH`/`Const_IterableH` to copy it into the function.
            /// * Pass `Move(instance)` to move it into the function. This is a more efficient form of copying that might invalidate the input object.
            ///   Be careful if your input isn't a unique reference to this object.
            /// * Pass `null` to use the default argument, assuming the parameter has a default argument (has `?` in the type).
            /// </summary>
            public class _ByValue_IterableH
            {
                internal readonly Const_IterableH? Value;
                internal readonly MR.CS.Misc._PassBy PassByMode;
                public _ByValue_IterableH() {PassByMode = MR.CS.Misc._PassBy.default_construct;}
                public _ByValue_IterableH(Const_IterableH new_value) {Value = new_value; PassByMode = MR.CS.Misc._PassBy.copy;}
                public static implicit operator _ByValue_IterableH(Const_IterableH arg) {return new(arg);}
                public _ByValue_IterableH(MR.CS.Misc._Moved<IterableH> moved) {Value = moved.Value; PassByMode = MR.CS.Misc._PassBy.move;}
                public static implicit operator _ByValue_IterableH(MR.CS.Misc._Moved<IterableH> arg) {return new(arg);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableH` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableH`/`Const_IterableH` directly.
            /// </summary>
            public class _InOptMut_IterableH
            {
                public IterableH? Opt;

                public _InOptMut_IterableH() {}
                public _InOptMut_IterableH(IterableH value) {Opt = value;}
                public static implicit operator _InOptMut_IterableH(IterableH value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableH` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableH`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableH`/`Const_IterableH` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableH
            {
                public Const_IterableH? Opt;

                public _InOptConst_IterableH() {}
                public _InOptConst_IterableH(Const_IterableH value) {Opt = value;}
                public static implicit operator _InOptConst_IterableH(Const_IterableH value) {return new(value);}
            }

            // Returning mutable exposed struct instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableI`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableI : MR.CS.Misc.Object<Const_IterableI>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableI_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableI_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableI() {Dispose(false);}

                public unsafe ref MR.CS.CSharp.ArrayExposedLayout3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.CSharp.ArrayExposedLayout3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ArrayExposedLayout3 *__MR_CSharp_IterableI_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableI_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableI(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableI._Underlying *__MR_CSharp_IterableI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableI_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableI::IterableI`.
                /// </summary>
                public unsafe Const_IterableI(MR.CS.CSharp.Const_IterableI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableI._Underlying *__MR_CSharp_IterableI_ConstructFromAnother(MR.CS.CSharp.IterableI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableI_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableI::IterableI`.
                /// </summary>
                public Const_IterableI(IterableI _other) : this((Const_IterableI)_other) {}
            }

            // Returning mutable exposed struct instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableI`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableI : Const_IterableI, IEnumerable<MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>>
            {
                public class _Enumerator : IEnumerator<MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>>
                {
                    IterableI _container;
                    MR.CS.CSharp.PtrExposedLayout _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableI container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(ref _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.CSharp.ArrayExposedLayout3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableI(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableI() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableI._Underlying *__MR_CSharp_IterableI_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableI_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableI::IterableI`.
                /// </summary>
                public unsafe IterableI(MR.CS.CSharp.Const_IterableI _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableI._Underlying *__MR_CSharp_IterableI_ConstructFromAnother(MR.CS.CSharp.IterableI._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableI_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableI::IterableI`.
                /// </summary>
                public IterableI(IterableI _other) : this((Const_IterableI)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableI::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableI assign(MR.CS.CSharp.Const_IterableI _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableI._Underlying *__MR_CSharp_IterableI_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableI._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableI_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableI::begin`.
                /// </summary>
                public unsafe MR.CS.CSharp.PtrExposedLayout begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_begin", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_IterableI_begin(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableI_begin(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableI::end`.
                /// </summary>
                public unsafe MR.CS.CSharp.PtrExposedLayout end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableI_end", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_IterableI_end(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableI_end(_UnderlyingPtr);
                    return new(__c_ret);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableI` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableI`/`Const_IterableI` directly.
            /// </summary>
            public class _InOptMut_IterableI
            {
                public IterableI? Opt;

                public _InOptMut_IterableI() {}
                public _InOptMut_IterableI(IterableI value) {Opt = value;}
                public static implicit operator _InOptMut_IterableI(IterableI value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableI` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableI`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableI`/`Const_IterableI` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableI
            {
                public Const_IterableI? Opt;

                public _InOptConst_IterableI() {}
                public _InOptConst_IterableI(Const_IterableI value) {Opt = value;}
                public static implicit operator _InOptConst_IterableI(Const_IterableI value) {return new(value);}
            }

            // Returning const exposed struct instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableJ`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableJ : MR.CS.Misc.Object<Const_IterableJ>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableJ_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableJ_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableJ() {Dispose(false);}

                public unsafe ref MR.CS.CSharp.ArrayExposedLayout3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.CSharp.ArrayExposedLayout3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.CSharp.ArrayExposedLayout3 *__MR_CSharp_IterableJ_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableJ_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableJ(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableJ() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableJ._Underlying *__MR_CSharp_IterableJ_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableJ_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableJ::IterableJ`.
                /// </summary>
                public unsafe Const_IterableJ(MR.CS.CSharp.Const_IterableJ _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableJ._Underlying *__MR_CSharp_IterableJ_ConstructFromAnother(MR.CS.CSharp.IterableJ._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableJ_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableJ::IterableJ`.
                /// </summary>
                public Const_IterableJ(IterableJ _other) : this((Const_IterableJ)_other) {}
            }

            // Returning const exposed struct instances.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableJ`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableJ : Const_IterableJ, IEnumerable<MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout>>
            {
                public class _Enumerator : IEnumerator<MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout>>
                {
                    IterableJ _container;
                    MR.CS.CSharp.ConstPtrExposedLayout _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableJ container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout> Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return new(in _cur.deref());
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<MR.CS.Misc.ConstRef<MR.CS.CSharp.ExposedLayout>> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.CSharp.ArrayExposedLayout3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableJ(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableJ() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableJ._Underlying *__MR_CSharp_IterableJ_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableJ_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableJ::IterableJ`.
                /// </summary>
                public unsafe IterableJ(MR.CS.CSharp.Const_IterableJ _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableJ._Underlying *__MR_CSharp_IterableJ_ConstructFromAnother(MR.CS.CSharp.IterableJ._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableJ_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableJ::IterableJ`.
                /// </summary>
                public IterableJ(IterableJ _other) : this((Const_IterableJ)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableJ::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableJ assign(MR.CS.CSharp.Const_IterableJ _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableJ._Underlying *__MR_CSharp_IterableJ_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableJ._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableJ_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                // Not making those functions `const` for a change.
                /// <summary>
                /// Generated from method `MR::CSharp::IterableJ::begin`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConstPtrExposedLayout begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_begin", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_IterableJ_begin(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableJ_begin(_UnderlyingPtr);
                    return new(__c_ret);
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableJ::end`.
                /// </summary>
                public unsafe MR.CS.CSharp.ConstPtrExposedLayout end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableJ_end", ExactSpelling = true)]
                    extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_IterableJ_end(_Underlying *_this);
                    var __c_ret = __MR_CSharp_IterableJ_end(_UnderlyingPtr);
                    return new(__c_ret);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableJ` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableJ`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableJ`/`Const_IterableJ` directly.
            /// </summary>
            public class _InOptMut_IterableJ
            {
                public IterableJ? Opt;

                public _InOptMut_IterableJ() {}
                public _InOptMut_IterableJ(IterableJ value) {Opt = value;}
                public static implicit operator _InOptMut_IterableJ(IterableJ value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableJ` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableJ`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableJ`/`Const_IterableJ` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableJ
            {
                public Const_IterableJ? Opt;

                public _InOptConst_IterableJ() {}
                public _InOptConst_IterableJ(Const_IterableJ value) {Opt = value;}
                public static implicit operator _InOptConst_IterableJ(Const_IterableJ value) {return new(value);}
            }

            // The sentinel having a different type.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableK`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableK : MR.CS.Misc.Object<Const_IterableK>, System.IDisposable
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableK_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableK_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableK() {Dispose(false);}

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableK_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableK_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableK(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableK() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK._Underlying *__MR_CSharp_IterableK_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableK_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableK::IterableK`.
                /// </summary>
                public unsafe Const_IterableK(MR.CS.CSharp.Const_IterableK _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK._Underlying *__MR_CSharp_IterableK_ConstructFromAnother(MR.CS.CSharp.IterableK._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableK_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableK::IterableK`.
                /// </summary>
                public Const_IterableK(IterableK _other) : this((Const_IterableK)_other) {}

                /// <summary>
                /// Generated from class `MR::CSharp::IterableK::Iter`.
                /// This is the const half of the class.
                /// </summary>
                public class Const_Iter : MR.CS.Misc.Object<Const_Iter>, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_IterableK_Iter_Destroy(_Underlying *_this);
                        __MR_CSharp_IterableK_Iter_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_Iter() {Dispose(false);}

                    public unsafe MR.CS.Misc.Box<int>? ptr
                    {
                        get
                        {
                            MR.CS.Misc.Box<int>? value = null;
                            if (*__ptr_storage_ptr is not null)
                            {
                                value = new(*__ptr_storage_ptr);
                                value._KeepAliveEnclosingObject = this;
                            }
                            return value;
                        }
                    }
                    private protected unsafe int **__ptr_storage_ptr;

                    /// <summary>
                    /// Constructors call this at the end to initialize class fields.
                    /// </summary>
                    protected unsafe void _FinalizeFields()
                    {
                        { // ptr (raw pointer)
                            [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_Get_ptr", ExactSpelling = true)]
                            extern static int **__MR_CSharp_IterableK_Iter_Get_ptr(Const_Iter._Underlying *_this);
                            this.__ptr_storage_ptr = __MR_CSharp_IterableK_Iter_Get_ptr(_UnderlyingPtr);
                        }
                    }

                    // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                    #pragma warning disable CS8618
                    internal unsafe Const_Iter(_Underlying *ptr, bool is_owning) : base(is_owning)
                    {
                        _UnderlyingPtr = ptr;
                        if (ptr is not null)
                            _FinalizeFields();
                    }
                    #pragma warning restore CS8618

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Const_Iter() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_DefaultConstruct();
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Constructs `MR::CSharp::IterableK::Iter` elementwise.
                    /// </summary>
                    public unsafe Const_Iter(MR.CS.Misc.InOut<int>? ptr) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_ConstructFrom", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_ConstructFrom(int *ptr);
                        int __value_ptr = ptr is not null ? ptr.Value : default(int);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_ConstructFrom(ptr is not null ? &__value_ptr : null);
                        if (ptr is not null) ptr.Value = __value_ptr;
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Iter::Iter`.
                    /// </summary>
                    public unsafe Const_Iter(MR.CS.CSharp.IterableK.Const_Iter _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_ConstructFromAnother(MR.CS.CSharp.IterableK.Iter._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Iter::Iter`.
                    /// </summary>
                    public Const_Iter(Iter _other) : this((Const_Iter)_other) {}

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Iter::operator*`.
                    /// </summary>
                    public unsafe int deref()
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_deref_MR_CSharp_IterableK_Iter", ExactSpelling = true)]
                        extern static int __MR_C_deref_MR_CSharp_IterableK_Iter(_Underlying *_this);
                        return __MR_C_deref_MR_CSharp_IterableK_Iter(_UnderlyingPtr);
                    }

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Iter::operator++`.
                    /// </summary>
                    public static unsafe Iter operator++(MR.CS.CSharp.IterableK.Const_Iter _this)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IterableK_Iter", ExactSpelling = true)]
                        extern static void __MR_C_incr_MR_CSharp_IterableK_Iter(MR.CS.CSharp.IterableK.Const_Iter._Underlying *_this);
                        Iter __this_copy = new(_this);
                        __MR_C_incr_MR_CSharp_IterableK_Iter(__this_copy._UnderlyingPtr);
                        return __this_copy;
                    }
                }

                /// <summary>
                /// Generated from class `MR::CSharp::IterableK::Iter`.
                /// This is the non-const half of the class.
                /// </summary>
                public class Iter : Const_Iter, System.IEquatable<MR.CS.CSharp.IterableK.Const_Sentinel>
                {
                    public new unsafe MR.CS.Misc.Box<int>? ptr
                    {
                        get => base.ptr;
                        set
                        {
                            _DiscardKeepAlive("ptr");
                            if (value is not null)
                                _KeepAlive(value, "ptr");
                            *__ptr_storage_ptr = (value is not null ? value._UnderlyingPtr : null);
                        }
                    }

                    // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                    #pragma warning disable CS8618
                    internal unsafe Iter(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                    {
                        if (ptr is not null)
                            _FinalizeFields();
                    }
                    #pragma warning restore CS8618

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Iter() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_DefaultConstruct();
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Constructs `MR::CSharp::IterableK::Iter` elementwise.
                    /// </summary>
                    public unsafe Iter(MR.CS.Misc.InOut<int>? ptr) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_ConstructFrom", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_ConstructFrom(int *ptr);
                        int __value_ptr = ptr is not null ? ptr.Value : default(int);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_ConstructFrom(ptr is not null ? &__value_ptr : null);
                        if (ptr is not null) ptr.Value = __value_ptr;
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Iter::Iter`.
                    /// </summary>
                    public unsafe Iter(MR.CS.CSharp.IterableK.Const_Iter _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_ConstructFromAnother(MR.CS.CSharp.IterableK.Iter._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Iter_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Iter::Iter`.
                    /// </summary>
                    public Iter(Iter _other) : this((Const_Iter)_other) {}

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Iter::operator=`.
                    /// </summary>
                    public unsafe MR.CS.CSharp.IterableK.Iter assign(MR.CS.CSharp.IterableK.Const_Iter _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Iter_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_Iter_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableK.Iter._Underlying *_other);
                        _DiscardKeepAlive();
                        _KeepAlive(_other);
                        return new(__MR_CSharp_IterableK_Iter_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Iter::operator++`.
                    /// </summary>
                    public unsafe void incr()
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_incr_MR_CSharp_IterableK_Iter", ExactSpelling = true)]
                        extern static void __MR_C_incr_MR_CSharp_IterableK_Iter(_Underlying *_this);
                        __MR_C_incr_MR_CSharp_IterableK_Iter(_UnderlyingPtr);
                    }

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Iter::operator==`.
                    /// </summary>
                    public static unsafe bool operator==(MR.CS.CSharp.IterableK.Iter _this, MR.CS.CSharp.IterableK.Const_Sentinel s)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_equal_MR_CSharp_IterableK_Iter_MR_CSharp_IterableK_Sentinel", ExactSpelling = true)]
                        extern static byte __MR_C_equal_MR_CSharp_IterableK_Iter_MR_CSharp_IterableK_Sentinel(MR.CS.CSharp.IterableK.Iter._Underlying *_this, MR.CS.CSharp.IterableK.Sentinel._Underlying *s);
                        return __MR_C_equal_MR_CSharp_IterableK_Iter_MR_CSharp_IterableK_Sentinel(_this._UnderlyingPtr, s._UnderlyingPtr) != 0;
                    }

                    public static unsafe bool operator!=(MR.CS.CSharp.IterableK.Iter _this, MR.CS.CSharp.IterableK.Const_Sentinel s)
                    {
                        return !(_this == s);
                    }

                    // IEquatable:

                    public bool Equals(MR.CS.CSharp.IterableK.Const_Sentinel? s)
                    {
                        if (s is null)
                            return false;
                        return this == s;
                    }

                    public override bool Equals(object? other)
                    {
                        if (other is null)
                            return false;
                        if (other is MR.CS.CSharp.IterableK.Const_Sentinel)
                            return this == (MR.CS.CSharp.IterableK.Const_Sentinel)other;
                        return false;
                    }
                }

                /// <summary>
                /// This is used for optional parameters of class `Iter` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_Iter`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Iter`/`Const_Iter` directly.
                /// </summary>
                public class _InOptMut_Iter
                {
                    public Iter? Opt;

                    public _InOptMut_Iter() {}
                    public _InOptMut_Iter(Iter value) {Opt = value;}
                    public static implicit operator _InOptMut_Iter(Iter value) {return new(value);}
                }

                /// <summary>
                /// This is used for optional parameters of class `Iter` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_Iter`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Iter`/`Const_Iter` to pass it to the function.
                /// </summary>
                public class _InOptConst_Iter
                {
                    public Const_Iter? Opt;

                    public _InOptConst_Iter() {}
                    public _InOptConst_Iter(Const_Iter value) {Opt = value;}
                    public static implicit operator _InOptConst_Iter(Const_Iter value) {return new(value);}
                }

                /// <summary>
                /// Generated from class `MR::CSharp::IterableK::Sentinel`.
                /// This is the const half of the class.
                /// </summary>
                public class Const_Sentinel : MR.CS.Misc.Object<Const_Sentinel>, System.IDisposable
                {
                    internal struct _Underlying {} // Represents the underlying C++ type.

                    internal unsafe _Underlying *_UnderlyingPtr;

                    protected virtual unsafe void Dispose(bool disposing)
                    {
                        if (_UnderlyingPtr is null || !_IsOwningVal)
                            return;
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_Destroy", ExactSpelling = true)]
                        extern static void __MR_CSharp_IterableK_Sentinel_Destroy(_Underlying *_this);
                        __MR_CSharp_IterableK_Sentinel_Destroy(_UnderlyingPtr);
                        _UnderlyingPtr = null;
                    }
                    public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                    ~Const_Sentinel() {Dispose(false);}

                    public unsafe MR.CS.Misc.Box<int>? ptr
                    {
                        get
                        {
                            MR.CS.Misc.Box<int>? value = null;
                            if (*__ptr_storage_ptr is not null)
                            {
                                value = new(*__ptr_storage_ptr);
                                value._KeepAliveEnclosingObject = this;
                            }
                            return value;
                        }
                    }
                    private protected unsafe int **__ptr_storage_ptr;

                    /// <summary>
                    /// Constructors call this at the end to initialize class fields.
                    /// </summary>
                    protected unsafe void _FinalizeFields()
                    {
                        { // ptr (raw pointer)
                            [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_Get_ptr", ExactSpelling = true)]
                            extern static int **__MR_CSharp_IterableK_Sentinel_Get_ptr(Const_Sentinel._Underlying *_this);
                            this.__ptr_storage_ptr = __MR_CSharp_IterableK_Sentinel_Get_ptr(_UnderlyingPtr);
                        }
                    }

                    // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                    #pragma warning disable CS8618
                    internal unsafe Const_Sentinel(_Underlying *ptr, bool is_owning) : base(is_owning)
                    {
                        _UnderlyingPtr = ptr;
                        if (ptr is not null)
                            _FinalizeFields();
                    }
                    #pragma warning restore CS8618

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Const_Sentinel() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_DefaultConstruct();
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Constructs `MR::CSharp::IterableK::Sentinel` elementwise.
                    /// </summary>
                    public unsafe Const_Sentinel(MR.CS.Misc.InOut<int>? ptr) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_ConstructFrom", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_ConstructFrom(int *ptr);
                        int __value_ptr = ptr is not null ? ptr.Value : default(int);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_ConstructFrom(ptr is not null ? &__value_ptr : null);
                        if (ptr is not null) ptr.Value = __value_ptr;
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Sentinel::Sentinel`.
                    /// </summary>
                    public unsafe Const_Sentinel(MR.CS.CSharp.IterableK.Const_Sentinel _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_ConstructFromAnother(MR.CS.CSharp.IterableK.Sentinel._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Sentinel::Sentinel`.
                    /// </summary>
                    public Const_Sentinel(Sentinel _other) : this((Const_Sentinel)_other) {}
                }

                /// <summary>
                /// Generated from class `MR::CSharp::IterableK::Sentinel`.
                /// This is the non-const half of the class.
                /// </summary>
                public class Sentinel : Const_Sentinel
                {
                    public new unsafe MR.CS.Misc.Box<int>? ptr
                    {
                        get => base.ptr;
                        set
                        {
                            _DiscardKeepAlive("ptr");
                            if (value is not null)
                                _KeepAlive(value, "ptr");
                            *__ptr_storage_ptr = (value is not null ? value._UnderlyingPtr : null);
                        }
                    }

                    // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                    #pragma warning disable CS8618
                    internal unsafe Sentinel(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                    {
                        if (ptr is not null)
                            _FinalizeFields();
                    }
                    #pragma warning restore CS8618

                    /// <summary>
                    /// Constructs an empty (default-constructed) instance.
                    /// </summary>
                    public unsafe Sentinel() : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_DefaultConstruct", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_DefaultConstruct();
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_DefaultConstruct();
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Constructs `MR::CSharp::IterableK::Sentinel` elementwise.
                    /// </summary>
                    public unsafe Sentinel(MR.CS.Misc.InOut<int>? ptr) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_ConstructFrom", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_ConstructFrom(int *ptr);
                        int __value_ptr = ptr is not null ? ptr.Value : default(int);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_ConstructFrom(ptr is not null ? &__value_ptr : null);
                        if (ptr is not null) ptr.Value = __value_ptr;
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Sentinel::Sentinel`.
                    /// </summary>
                    public unsafe Sentinel(MR.CS.CSharp.IterableK.Const_Sentinel _other) : this(null, is_owning: true)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_ConstructFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_ConstructFromAnother(MR.CS.CSharp.IterableK.Sentinel._Underlying *_other);
                        _UnderlyingPtr = __MR_CSharp_IterableK_Sentinel_ConstructFromAnother(_other._UnderlyingPtr);
                        _KeepAlive(_other);
                        _FinalizeFields();
                    }

                    /// <summary>
                    /// Generated from constructor `MR::CSharp::IterableK::Sentinel::Sentinel`.
                    /// </summary>
                    public Sentinel(Sentinel _other) : this((Const_Sentinel)_other) {}

                    /// <summary>
                    /// Generated from method `MR::CSharp::IterableK::Sentinel::operator=`.
                    /// </summary>
                    public unsafe MR.CS.CSharp.IterableK.Sentinel assign(MR.CS.CSharp.IterableK.Const_Sentinel _other)
                    {
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_Sentinel_AssignFromAnother", ExactSpelling = true)]
                        extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_Sentinel_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableK.Sentinel._Underlying *_other);
                        _DiscardKeepAlive();
                        _KeepAlive(_other);
                        return new(__MR_CSharp_IterableK_Sentinel_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                    }
                }

                /// <summary>
                /// This is used for optional parameters of class `Sentinel` with default arguments.
                /// This is only used mutable parameters. For const ones we have `_InOptConst_Sentinel`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Sentinel`/`Const_Sentinel` directly.
                /// </summary>
                public class _InOptMut_Sentinel
                {
                    public Sentinel? Opt;

                    public _InOptMut_Sentinel() {}
                    public _InOptMut_Sentinel(Sentinel value) {Opt = value;}
                    public static implicit operator _InOptMut_Sentinel(Sentinel value) {return new(value);}
                }

                /// <summary>
                /// This is used for optional parameters of class `Sentinel` with default arguments.
                /// This is only used const parameters. For non-const ones we have `_InOptMut_Sentinel`.
                /// Usage:
                /// * Pass `null` to use the default argument.
                /// * Pass `new()` to pass no object.
                /// * Pass an instance of `Sentinel`/`Const_Sentinel` to pass it to the function.
                /// </summary>
                public class _InOptConst_Sentinel
                {
                    public Const_Sentinel? Opt;

                    public _InOptConst_Sentinel() {}
                    public _InOptConst_Sentinel(Const_Sentinel value) {Opt = value;}
                    public static implicit operator _InOptConst_Sentinel(Const_Sentinel value) {return new(value);}
                }
            }

            // The sentinel having a different type.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableK`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableK : Const_IterableK, IEnumerable<int>
            {
                public class _Enumerator : IEnumerator<int>
                {
                    IterableK _container;
                    MR.CS.CSharp.IterableK.Iter _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(IterableK container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableK(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableK() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK._Underlying *__MR_CSharp_IterableK_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableK_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableK::IterableK`.
                /// </summary>
                public unsafe IterableK(MR.CS.CSharp.Const_IterableK _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK._Underlying *__MR_CSharp_IterableK_ConstructFromAnother(MR.CS.CSharp.IterableK._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableK_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableK::IterableK`.
                /// </summary>
                public IterableK(IterableK _other) : this((Const_IterableK)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableK::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableK assign(MR.CS.CSharp.Const_IterableK _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK._Underlying *__MR_CSharp_IterableK_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableK._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableK_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }

                // Not making those functions `const` for a change.
                /// <summary>
                /// Generated from method `MR::CSharp::IterableK::begin`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableK.Iter begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_begin", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK.Iter._Underlying *__MR_CSharp_IterableK_begin(_Underlying *_this);
                    MR.CS.CSharp.IterableK.Iter __ret;
                    __ret = new(__MR_CSharp_IterableK_begin(_UnderlyingPtr), is_owning: true);
                    __ret._KeepAlive(this);
                    return __ret;
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableK::end`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableK.Sentinel end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableK_end", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableK.Sentinel._Underlying *__MR_CSharp_IterableK_end(_Underlying *_this);
                    MR.CS.CSharp.IterableK.Sentinel __ret;
                    __ret = new(__MR_CSharp_IterableK_end(_UnderlyingPtr), is_owning: true);
                    __ret._KeepAlive(this);
                    return __ret;
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableK` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableK`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableK`/`Const_IterableK` directly.
            /// </summary>
            public class _InOptMut_IterableK
            {
                public IterableK? Opt;

                public _InOptMut_IterableK() {}
                public _InOptMut_IterableK(IterableK value) {Opt = value;}
                public static implicit operator _InOptMut_IterableK(IterableK value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableK` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableK`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableK`/`Const_IterableK` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableK
            {
                public Const_IterableK? Opt;

                public _InOptConst_IterableK() {}
                public _InOptConst_IterableK(Const_IterableK value) {Opt = value;}
                public static implicit operator _InOptConst_IterableK(Const_IterableK value) {return new(value);}
            }

            // Templated free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableL<int32_t>`.
            /// This is the const half of the class.
            /// </summary>
            public class Const_IterableL_Int32T : MR.CS.Misc.Object<Const_IterableL_Int32T>, System.IDisposable, IEnumerable<int>
            {
                internal struct _Underlying {} // Represents the underlying C++ type.

                internal unsafe _Underlying *_UnderlyingPtr;

                protected virtual unsafe void Dispose(bool disposing)
                {
                    if (_UnderlyingPtr is null || !_IsOwningVal)
                        return;
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_Destroy", ExactSpelling = true)]
                    extern static void __MR_CSharp_IterableL_int32_t_Destroy(_Underlying *_this);
                    __MR_CSharp_IterableL_int32_t_Destroy(_UnderlyingPtr);
                    _UnderlyingPtr = null;
                }
                public virtual void Dispose() {Dispose(true); GC.SuppressFinalize(this);}
                ~Const_IterableL_Int32T() {Dispose(false);}

                public class _Enumerator : IEnumerator<int>
                {
                    Const_IterableL_Int32T _container;
                    MR.CS.ConstPtrInt32T _cur;
                    bool _first = true;
                    bool _done;

                    public _Enumerator(Const_IterableL_Int32T container)
                    {
                        _container = container;
                        _cur = _container.begin();
                        _done = _cur == _container.end();
                    }

                    public int Current
                    {
                        get
                        {
                            if (_first || _done)
                                throw new MR.CS.Misc.InvalidEnumeratorExpression("Attempting to dereference an invalid enumerator.");
                            return _cur.deref();
                        }
                    }

                    object System.Collections.IEnumerator.Current => Current;

                    public bool MoveNext()
                    {
                        if (_done)
                            return false;
                        if (_first)
                        {
                            _first = false;
                            return true;
                        }
                        _cur.incr();
                        if (_cur == _container.end())
                        {
                            _done = true;
                            return false;
                        }
                        return true;
                    }

                    public void Reset()
                    {
                        _cur = _container.begin();
                        _first = true;
                        _done = false;
                    }

                    void IDisposable.Dispose() {}
                }

                public IEnumerator<int> GetEnumerator()
                {
                    return new _Enumerator(this);
                }

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
                {
                    return GetEnumerator();
                }

                public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);
                private protected unsafe MR.CS.ArrayInt32T3 *__array_storage_arr;

                /// <summary>
                /// Constructors call this at the end to initialize class fields.
                /// </summary>
                protected unsafe void _FinalizeFields()
                {
                    { // arr (ref array)
                        [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_Get_arr", ExactSpelling = true)]
                        extern static MR.CS.ArrayInt32T3 *__MR_CSharp_IterableL_int32_t_Get_arr(_Underlying *_this);
                        this.__array_storage_arr = __MR_CSharp_IterableL_int32_t_Get_arr(_UnderlyingPtr);
                    }
                }

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe Const_IterableL_Int32T(_Underlying *ptr, bool is_owning) : base(is_owning)
                {
                    _UnderlyingPtr = ptr;
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe Const_IterableL_Int32T() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableL_Int32T._Underlying *__MR_CSharp_IterableL_int32_t_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableL_int32_t_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableL<int32_t>::IterableL`.
                /// </summary>
                public unsafe Const_IterableL_Int32T(MR.CS.CSharp.Const_IterableL_Int32T _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableL_Int32T._Underlying *__MR_CSharp_IterableL_int32_t_ConstructFromAnother(MR.CS.CSharp.IterableL_Int32T._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableL_int32_t_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableL<int32_t>::IterableL`.
                /// </summary>
                public Const_IterableL_Int32T(IterableL_Int32T _other) : this((Const_IterableL_Int32T)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableL<int32_t>::begin`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T begin()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_begin", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableL_int32_t_begin(_Underlying *_this);
                    return new(__MR_CSharp_IterableL_int32_t_begin(_UnderlyingPtr));
                }

                /// <summary>
                /// Generated from method `MR::CSharp::IterableL<int32_t>::end`.
                /// </summary>
                public unsafe MR.CS.ConstPtrInt32T end()
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_end", ExactSpelling = true)]
                    extern static int *__MR_CSharp_IterableL_int32_t_end(_Underlying *_this);
                    return new(__MR_CSharp_IterableL_int32_t_end(_UnderlyingPtr));
                }
            }

            // Templated free functions.
            /// <summary>
            /// Generated from class `MR::CSharp::IterableL<int32_t>`.
            /// This is the non-const half of the class.
            /// </summary>
            public class IterableL_Int32T : Const_IterableL_Int32T
            {
                new public unsafe ref MR.CS.ArrayInt32T3 arr => ref *(__array_storage_arr);

                // Don't warn about some fields remaining conditionally uninitialized. We initialize them later.
                #pragma warning disable CS8618
                internal unsafe IterableL_Int32T(_Underlying *ptr, bool is_owning) : base(ptr, is_owning)
                {
                    if (ptr is not null)
                        _FinalizeFields();
                }
                #pragma warning restore CS8618

                /// <summary>
                /// Constructs an empty (default-constructed) instance.
                /// </summary>
                public unsafe IterableL_Int32T() : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_DefaultConstruct", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableL_Int32T._Underlying *__MR_CSharp_IterableL_int32_t_DefaultConstruct();
                    _UnderlyingPtr = __MR_CSharp_IterableL_int32_t_DefaultConstruct();
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableL<int32_t>::IterableL`.
                /// </summary>
                public unsafe IterableL_Int32T(MR.CS.CSharp.Const_IterableL_Int32T _other) : this(null, is_owning: true)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_ConstructFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableL_Int32T._Underlying *__MR_CSharp_IterableL_int32_t_ConstructFromAnother(MR.CS.CSharp.IterableL_Int32T._Underlying *_other);
                    _UnderlyingPtr = __MR_CSharp_IterableL_int32_t_ConstructFromAnother(_other._UnderlyingPtr);
                    _KeepAlive(_other);
                    _FinalizeFields();
                }

                /// <summary>
                /// Generated from constructor `MR::CSharp::IterableL<int32_t>::IterableL`.
                /// </summary>
                public IterableL_Int32T(IterableL_Int32T _other) : this((Const_IterableL_Int32T)_other) {}

                /// <summary>
                /// Generated from method `MR::CSharp::IterableL<int32_t>::operator=`.
                /// </summary>
                public unsafe MR.CS.CSharp.IterableL_Int32T assign(MR.CS.CSharp.Const_IterableL_Int32T _other)
                {
                    [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_IterableL_int32_t_AssignFromAnother", ExactSpelling = true)]
                    extern static MR.CS.CSharp.IterableL_Int32T._Underlying *__MR_CSharp_IterableL_int32_t_AssignFromAnother(_Underlying *_this, MR.CS.CSharp.IterableL_Int32T._Underlying *_other);
                    _DiscardKeepAlive();
                    _KeepAlive(_other);
                    return new(__MR_CSharp_IterableL_int32_t_AssignFromAnother(_UnderlyingPtr, _other._UnderlyingPtr), is_owning: false);
                }
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableL_Int32T` with default arguments.
            /// This is only used mutable parameters. For const ones we have `_InOptConst_IterableL_Int32T`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableL_Int32T`/`Const_IterableL_Int32T` directly.
            /// </summary>
            public class _InOptMut_IterableL_Int32T
            {
                public IterableL_Int32T? Opt;

                public _InOptMut_IterableL_Int32T() {}
                public _InOptMut_IterableL_Int32T(IterableL_Int32T value) {Opt = value;}
                public static implicit operator _InOptMut_IterableL_Int32T(IterableL_Int32T value) {return new(value);}
            }

            /// <summary>
            /// This is used for optional parameters of class `IterableL_Int32T` with default arguments.
            /// This is only used const parameters. For non-const ones we have `_InOptMut_IterableL_Int32T`.
            /// Usage:
            /// * Pass `null` to use the default argument.
            /// * Pass `new()` to pass no object.
            /// * Pass an instance of `IterableL_Int32T`/`Const_IterableL_Int32T` to pass it to the function.
            /// </summary>
            public class _InOptConst_IterableL_Int32T
            {
                public Const_IterableL_Int32T? Opt;

                public _InOptConst_IterableL_Int32T() {}
                public _InOptConst_IterableL_Int32T(Const_IterableL_Int32T value) {Opt = value;}
                public static implicit operator _InOptConst_IterableL_Int32T(Const_IterableL_Int32T value) {return new(value);}
            }

            /// <summary>
            /// Generated from function `MR::CSharp::foo`.
            /// </summary>
            public static void foo()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_foo", ExactSpelling = true)]
                extern static void __MR_CSharp_foo();
                __MR_CSharp_foo();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int`.
            /// Parameter `b` defaults to `42`.
            /// </summary>
            public static unsafe int testInt(int a, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int", ExactSpelling = true)]
                extern static int __MR_CSharp_test_int(int a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_int(a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_bool`.
            /// Parameter `b` defaults to `true`.
            /// </summary>
            public static unsafe bool testBool(bool a, bool? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool", ExactSpelling = true)]
                extern static byte __MR_CSharp_test_bool(byte a, byte *b);
                byte __deref_b = b.GetValueOrDefault() ? (byte)1 : (byte)0;
                return __MR_CSharp_test_bool(a ? (byte)1 : (byte)0, b.HasValue ? &__deref_b : null) != 0;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_bool_ref`.
            /// Parameter `b` defaults to `default_bool`.
            /// </summary>
            public static unsafe void testBoolRef(ref bool a, MR.CS.Misc.InOut<bool>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_ref", ExactSpelling = true)]
                extern static void __MR_CSharp_test_bool_ref(bool *a, bool *b);
                fixed (bool *__ptr_a = &a)
                {
                    bool __value_b = b is not null ? b.Value : default(bool);
                    if (b is not null) b.Value = __value_b;
                    __MR_CSharp_test_bool_ref(__ptr_a, b is not null ? &__value_b : null);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_bool_ref2`.
            /// Parameter `b` defaults to `default_bool`.
            /// </summary>
            public static unsafe int testBoolRef2(ref bool a, MR.CS.Misc.InOut<bool>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_ref2", ExactSpelling = true)]
                extern static int __MR_CSharp_test_bool_ref2(bool *a, bool *b);
                fixed (bool *__ptr_a = &a)
                {
                    bool __value_b = b is not null ? b.Value : default(bool);
                    var __c_ret = __MR_CSharp_test_bool_ref2(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return __c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_bool_ref`.
            /// </summary>
            public static unsafe ref bool getBoolRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_bool_ref", ExactSpelling = true)]
                extern static bool *__MR_CSharp_get_bool_ref();
                return ref *__MR_CSharp_get_bool_ref();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::print_bool_ref`.
            /// </summary>
            public static void printBoolRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_print_bool_ref", ExactSpelling = true)]
                extern static void __MR_CSharp_print_bool_ref();
                __MR_CSharp_print_bool_ref();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_bool_cref`.
            /// Parameter `_2` defaults to `default_bool`.
            /// </summary>
            public static unsafe bool testBoolCref(bool _1, bool? _2 = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_bool_cref", ExactSpelling = true)]
                extern static bool *__MR_CSharp_test_bool_cref(bool *_1, bool *_2);
                bool __deref__2 = _2.GetValueOrDefault();
                return *__MR_CSharp_test_bool_cref(&_1, _2.HasValue ? &__deref__2 : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_ref`.
            /// Parameter `b` defaults to `default_int`.
            /// </summary>
            public static unsafe ref int testIntRef(ref int a, MR.CS.Misc.InOut<int>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_ref(int *a, int *b);
                fixed (int *__ptr_a = &a)
                {
                    int __value_b = b is not null ? b.Value : default(int);
                    var __c_ret = __MR_CSharp_test_int_ref(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_cref`.
            /// Parameter `b` defaults to `default_int`.
            /// </summary>
            public static unsafe int testIntCref(int a, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_cref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_cref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_cref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_rref`.
            /// Parameter `b` defaults to `42`.
            /// </summary>
            public static unsafe int testIntRref(MR.CS.Misc._MoveRef _move_a, int a, MR.CS.Misc._MoveRef _move_b = default, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_rref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_rref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_rref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_crref`.
            /// Parameter `b` defaults to `42`.
            /// </summary>
            public static unsafe int testIntCrref(MR.CS.Misc._MoveRef _move_a, int a, MR.CS.Misc._MoveRef _move_b = default, int? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_crref", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_crref(int *a, int *b);
                int __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_int_crref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_ptr`.
            /// Parameter `c` defaults to `&default_int`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<int>? testIntPtr(MR.CS.Misc.InOut<int>? a, MR.CS.Misc.InOut<int>? b = null, MR.CS.Misc._InOutOpt<int>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_ptr", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_ptr(int *a, int *b, int **c);
                int __value_a = a is not null ? a.Value : default(int);
                int __value_b = b is not null ? b.Value : default(int);
                int __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(int);
                int *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_int_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<int>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_int_cptr`.
            /// Parameter `c` defaults to `&default_int`.
            /// </summary>
            public static unsafe int? testIntCptr(int? a, int? b = null, MR.CS.Misc._InOpt<int>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_int_cptr", ExactSpelling = true)]
                extern static int *__MR_CSharp_test_int_cptr(int *a, int *b, int **c);
                int __deref_a = a.GetValueOrDefault();
                int __deref_b = b.GetValueOrDefault();
                int __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(int);
                int *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_int_cptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __c_ret is not null ? *__c_ret : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort`.
            /// Parameter `b` defaults to `42`.
            /// </summary>
            public static unsafe ushort testUshort(ushort a, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort", ExactSpelling = true)]
                extern static ushort __MR_CSharp_test_ushort(ushort a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_ushort(a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_ref`.
            /// Parameter `b` defaults to `default_ushort`.
            /// </summary>
            public static unsafe ref ushort testUshortRef(ref ushort a, MR.CS.Misc.InOut<ushort>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_ref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_ref(ushort *a, ushort *b);
                fixed (ushort *__ptr_a = &a)
                {
                    ushort __value_b = b is not null ? b.Value : default(ushort);
                    var __c_ret = __MR_CSharp_test_ushort_ref(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_cref`.
            /// Parameter `b` defaults to `default_ushort`.
            /// </summary>
            public static unsafe ushort testUshortCref(ushort a, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_cref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_cref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_cref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_rref`.
            /// Parameter `b` defaults to `(unsigned short&&)default_ushort`.
            /// </summary>
            public static unsafe ushort testUshortRref(MR.CS.Misc._MoveRef _move_a, ushort a, MR.CS.Misc._MoveRef _move_b = default, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_rref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_rref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_rref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_crref`.
            /// Parameter `b` defaults to `(unsigned short&&)default_ushort`.
            /// </summary>
            public static unsafe ushort testUshortCrref(MR.CS.Misc._MoveRef _move_a, ushort a, MR.CS.Misc._MoveRef _move_b = default, ushort? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_crref", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_crref(ushort *a, ushort *b);
                ushort __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_ushort_crref(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_ptr`.
            /// Parameter `c` defaults to `&default_ushort`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<ushort>? testUshortPtr(MR.CS.Misc.InOut<ushort>? a, MR.CS.Misc.InOut<ushort>? b = null, MR.CS.Misc._InOutOpt<ushort>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_ptr", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_ptr(ushort *a, ushort *b, ushort **c);
                ushort __value_a = a is not null ? a.Value : default(ushort);
                ushort __value_b = b is not null ? b.Value : default(ushort);
                ushort __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(ushort);
                ushort *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_ushort_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<ushort>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ushort_cptr`.
            /// Parameter `c` defaults to `&default_ushort`.
            /// </summary>
            public static unsafe ushort? testUshortCptr(ushort? a, ushort? b = null, MR.CS.Misc._InOpt<ushort>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ushort_cptr", ExactSpelling = true)]
                extern static ushort *__MR_CSharp_test_ushort_cptr(ushort *a, ushort *b, ushort **c);
                ushort __deref_a = a.GetValueOrDefault();
                ushort __deref_b = b.GetValueOrDefault();
                ushort __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(ushort);
                ushort *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_ushort_cptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __c_ret is not null ? *__c_ret : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_constness_int`.
            /// Parameter `_2` defaults to `42`.
            /// </summary>
            public static unsafe int testConstnessInt(int _1, int? _2 = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_constness_int", ExactSpelling = true)]
                extern static int __MR_CSharp_test_constness_int(int _1, int *_2);
                int __deref__2 = _2.GetValueOrDefault();
                return __MR_CSharp_test_constness_int(_1, _2.HasValue ? &__deref__2 : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_constness_str`.
            /// Parameter `_2` defaults to `"42"`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.String> testConstnessStr(ReadOnlySpan<char> _1, MR.CS.Misc.ReadOnlyCharSpanOpt _2 = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_constness_str", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_constness_str(byte *_1, byte *_1_end, byte *_2, byte *_2_end);
                byte[] __bytes__1 = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(_1.Length)];
                int __len__1 = System.Text.Encoding.UTF8.GetBytes(_1, __bytes__1);
                fixed (byte *__ptr__1 = __bytes__1)
                {
                    byte[] __bytes__2;
                    int __len__2 = 0;
                    if (_2.HasValue)
                    {
                        __bytes__2 = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(_2.Value.Length)];
                        __len__2 = System.Text.Encoding.UTF8.GetBytes(_2.Value, __bytes__2);
                    }
                    fixed (byte *__ptr__2 = __bytes__2)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.String(__MR_CSharp_test_constness_str(__ptr__1, __ptr__1 + __len__1, _2.HasValue ? __ptr__2 : null, _2.HasValue ? __ptr__2 + __len__2 : null), is_owning: true));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum`.
            /// Parameter `b` defaults to `E1::b`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E1 testEnum(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 __MR_CSharp_test_enum_MR_CSharp_E1(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return __MR_CSharp_test_enum_MR_CSharp_E1(a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_ref`.
            /// Parameter `b` defaults to `default_e1`.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.E1 testEnumRef(ref MR.CS.CSharp.E1 a, MR.CS.Misc.InOut<MR.CS.CSharp.E1>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_ref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                fixed (MR.CS.CSharp.E1 *__ptr_a = &a)
                {
                    MR.CS.CSharp.E1 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E1);
                    var __c_ret = __MR_CSharp_test_enum_ref_MR_CSharp_E1(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_cref`.
            /// Parameter `b` defaults to `default_e1`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E1 testEnumCref(MR.CS.CSharp.E1 a, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_cref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_cref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::E1&&)default_e1`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E1 testEnumRref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E1 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_rref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_rref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_rref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::E1&&)default_e1`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E1 testEnumCrref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E1 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E1? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_crref_MR_CSharp_E1", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_crref_MR_CSharp_E1(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b);
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                return *__MR_CSharp_test_enum_crref_MR_CSharp_E1(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_ptr`.
            /// Parameter `c` defaults to `&default_e1`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.E1>? testEnumPtr(MR.CS.Misc.InOut<MR.CS.CSharp.E1>? a, MR.CS.Misc.InOut<MR.CS.CSharp.E1>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.E1>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b, MR.CS.CSharp.E1 **c);
                MR.CS.CSharp.E1 __value_a = a is not null ? a.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_enum_ptr_MR_CSharp_E1_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.E1>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_cptr`.
            /// Parameter `c` defaults to `&default_e1`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E1? testEnumCptr(MR.CS.CSharp.E1? a, MR.CS.CSharp.E1? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.E1>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E1 *__MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr(MR.CS.CSharp.E1 *a, MR.CS.CSharp.E1 *b, MR.CS.CSharp.E1 **c);
                MR.CS.CSharp.E1 __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.E1 __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.E1 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E1);
                MR.CS.CSharp.E1 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_enum_cptr_const_MR_CSharp_E1_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __c_ret is not null ? *__c_ret : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum`.
            /// Parameter `b` defaults to `E2::b`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E2 testEnum(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 __MR_CSharp_test_enum_MR_CSharp_E2(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return __MR_CSharp_test_enum_MR_CSharp_E2(a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_ref`.
            /// Parameter `b` defaults to `default_e2`.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.E2 testEnumRef(ref MR.CS.CSharp.E2 a, MR.CS.Misc.InOut<MR.CS.CSharp.E2>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_ref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                fixed (MR.CS.CSharp.E2 *__ptr_a = &a)
                {
                    if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                    MR.CS.CSharp.E2 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E2);
                    if ((byte)__value_b > 1) __value_b = (MR.CS.CSharp.E2)1;
                    var __c_ret = __MR_CSharp_test_enum_ref_MR_CSharp_E2(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_cref`.
            /// Parameter `b` defaults to `default_e2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E2 testEnumCref(MR.CS.CSharp.E2 a, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_cref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_cref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::E2&&)default_e2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E2 testEnumRref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E2 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_rref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_rref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_rref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::E2&&)default_e2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E2 testEnumCrref(MR.CS.Misc._MoveRef _move_a, MR.CS.CSharp.E2 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.E2? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_crref_MR_CSharp_E2", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_crref_MR_CSharp_E2(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b);
                if ((byte)a > 1) a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                return *__MR_CSharp_test_enum_crref_MR_CSharp_E2(&a, b.HasValue ? &__deref_b : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_ptr`.
            /// Parameter `c` defaults to `&default_e2`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.E2>? testEnumPtr(MR.CS.Misc.InOut<MR.CS.CSharp.E2>? a, MR.CS.Misc.InOut<MR.CS.CSharp.E2>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.E2>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b, MR.CS.CSharp.E2 **c);
                MR.CS.CSharp.E2 __value_a = a is not null ? a.Value : default(MR.CS.CSharp.E2);
                if ((byte)__value_a > 1) __value_a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_b = b is not null ? b.Value : default(MR.CS.CSharp.E2);
                if ((byte)__value_b > 1) __value_b = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E2);
                MR.CS.CSharp.E2 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                if ((byte)__value_c > 1) __value_c = (MR.CS.CSharp.E2)1;
                var __c_ret = __MR_CSharp_test_enum_ptr_MR_CSharp_E2_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.E2>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_enum_cptr`.
            /// Parameter `c` defaults to `&default_e2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.E2? testEnumCptr(MR.CS.CSharp.E2? a, MR.CS.CSharp.E2? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.E2>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.E2 *__MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr(MR.CS.CSharp.E2 *a, MR.CS.CSharp.E2 *b, MR.CS.CSharp.E2 **c);
                MR.CS.CSharp.E2 __deref_a = a.GetValueOrDefault();
                if ((byte)__deref_a > 1) __deref_a = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __deref_b = b.GetValueOrDefault();
                if ((byte)__deref_b > 1) __deref_b = (MR.CS.CSharp.E2)1;
                MR.CS.CSharp.E2 __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.E2);
                MR.CS.CSharp.E2 *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                if ((byte)__value_c > 1) __value_c = (MR.CS.CSharp.E2)1;
                var __c_ret = __MR_CSharp_test_enum_cptr_const_MR_CSharp_E2_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                return __c_ret is not null ? *__c_ret : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial`.
            /// Parameter `b` defaults to `{}`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Trivial testClassTrivial(MR.CS.CSharp.Const_Trivial a, MR.CS.CSharp.Const_Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_ref`.
            /// Parameter `b` defaults to `default_trivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Trivial testClassTrivialRef(MR.CS.CSharp.Trivial a, MR.CS.CSharp.Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_ref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_cref`.
            /// Parameter `b` defaults to `default_trivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_Trivial testClassTrivialCref(MR.CS.CSharp.Const_Trivial a, MR.CS.CSharp.Const_Trivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_cref(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b);
                return new(__MR_CSharp_test_class_trivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::Trivial&&)default_trivial`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Trivial> testClassTrivialRref(MR.CS.Misc._Moved<MR.CS.CSharp.Trivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Trivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_rref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Trivial(__MR_CSharp_test_class_trivial_rref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::Trivial&&)default_trivial`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial> testClassTrivialCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_Trivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_crref(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_Trivial(__MR_CSharp_test_class_trivial_crref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_ptr`.
            /// Parameter `c` defaults to `&default_trivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Trivial? testClassTrivialPtr(MR.CS.CSharp.Trivial? a, MR.CS.CSharp.Trivial? b = null, MR.CS.CSharp._InOptMut_Trivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Trivial._Underlying *__MR_CSharp_test_class_trivial_ptr(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.CSharp.Trivial._Underlying *b, MR.CS.CSharp.Trivial._Underlying **c);
                MR.CS.CSharp.Trivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_trivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.Trivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_trivial_cptr`.
            /// Parameter `c` defaults to `&default_trivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_Trivial? testClassTrivialCptr(MR.CS.CSharp.Const_Trivial? a, MR.CS.CSharp.Const_Trivial? b = null, MR.CS.CSharp._InOptConst_Trivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_trivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_Trivial._Underlying *__MR_CSharp_test_class_trivial_cptr(MR.CS.CSharp.Const_Trivial._Underlying *a, MR.CS.CSharp.Const_Trivial._Underlying *b, MR.CS.CSharp.Const_Trivial._Underlying **c);
                MR.CS.CSharp.Const_Trivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_trivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_Trivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial`.
            /// Parameter `b` defaults to `{}`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> testClassNontrivial(MR.CS.CSharp._ByValue_NonTrivial a, MR.CS.CSharp._ByValue_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.NonTrivial(__MR_CSharp_test_class_nontrivial(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_ref`.
            /// Parameter `b` defaults to `default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.NonTrivial testClassNontrivialRef(MR.CS.CSharp.NonTrivial a, MR.CS.CSharp.NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_ref(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_nontrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_cref`.
            /// Parameter `b` defaults to `default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_NonTrivial testClassNontrivialCref(MR.CS.CSharp.Const_NonTrivial a, MR.CS.CSharp.Const_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_cref(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_nontrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::NonTrivial&&)default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> testClassNontrivialRref(MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.NonTrivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_rref(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.NonTrivial(__MR_CSharp_test_class_nontrivial_rref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::NonTrivial&&)default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial> testClassNontrivialCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_NonTrivial>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_crref(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_NonTrivial(__MR_CSharp_test_class_nontrivial_crref(a.Value._UnderlyingPtr, b.HasValue ? b.Value.Value._UnderlyingPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_ptr`.
            /// Parameter `c` defaults to `&default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.NonTrivial? testClassNontrivialPtr(MR.CS.CSharp.NonTrivial? a, MR.CS.CSharp.NonTrivial? b = null, MR.CS.CSharp._InOptMut_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_ptr(MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.CSharp.NonTrivial._Underlying *b, MR.CS.CSharp.NonTrivial._Underlying **c);
                MR.CS.CSharp.NonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_nontrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.NonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_nontrivial_cptr`.
            /// Parameter `c` defaults to `&default_nontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_NonTrivial? testClassNontrivialCptr(MR.CS.CSharp.Const_NonTrivial? a, MR.CS.CSharp.Const_NonTrivial? b = null, MR.CS.CSharp._InOptConst_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_nontrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_NonTrivial._Underlying *__MR_CSharp_test_class_nontrivial_cptr(MR.CS.CSharp.Const_NonTrivial._Underlying *a, MR.CS.CSharp.Const_NonTrivial._Underlying *b, MR.CS.CSharp.Const_NonTrivial._Underlying **c);
                MR.CS.CSharp.Const_NonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_nontrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_NonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_void_ptr`.
            /// Parameter `a` is a mutable pointer.
            /// Parameter `b` is a mutable pointer.
            /// Parameter `c` defaults to `(void*)42`.
            /// Parameter `c` is a mutable pointer.
            /// Returns a mutable pointer.
            /// </summary>
            public static unsafe void *testVoidPtr(void *a, void *b = null, void **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_void_ptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_void_ptr(void *a, void *b, void **c);
                return __MR_CSharp_test_void_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_void_cptr`.
            /// Parameter `a` is a read-only pointer.
            /// Parameter `b` is a read-only pointer.
            /// Parameter `c` defaults to `(const void*)42`.
            /// Parameter `c` is a read-only pointer.
            /// Returns a read-only pointer.
            /// </summary>
            public static unsafe void *testVoidCptr(void *a, void *b = null, void **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_void_cptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_void_cptr(void *a, void *b, void **c);
                return __MR_CSharp_test_void_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::mark_se_as_shared`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SE> markSeAsShared()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_mark_se_as_shared", ExactSpelling = true)]
                extern static MR.CS.CSharp.SE._UnderlyingShared *__MR_CSharp_mark_se_as_shared();
                return MR.CS.Misc.Move(new MR.CS.CSharp.SE(__MR_CSharp_mark_se_as_shared(), is_owning: true));
            }

            // Poking a shared pointer type for a single class causes `std::shared_ptr` to be instantiated for the entire hierarchy (when `--bind-shared-ptr-virally`, which is required for `C#`).
            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr`.
            /// Parameter `b` defaults to `default_shptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShptr(MR.CS.CSharp._ByValueShared_SA a, MR.CS.CSharp._ByValueShared_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shptr(a.PassByMode, a.Value is not null ? a.Value._UnderlyingSharedPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingSharedPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_ref`.
            /// Parameter `b` defaults to `default_shptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.SA testShptrRef(MR.CS.CSharp.SA a, MR.CS.CSharp.SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_ref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shptr_ref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_cref`.
            /// Parameter `b` defaults to `default_shptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_SA testShptrCref(MR.CS.CSharp.Const_SA a, MR.CS.CSharp.Const_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_cref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shptr_cref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_rref`.
            /// Parameter `b` defaults to `(std::shared_ptr<MR::CSharp::SA>&&)default_shptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShptrRref(MR.CS.Misc._Moved<MR.CS.CSharp.SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_rref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shptr_rref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_crref`.
            /// Parameter `b` defaults to `(std::shared_ptr<MR::CSharp::SA>&&)default_shptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> testShptrCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_crref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_SA(__MR_CSharp_test_shptr_crref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_ptr`.
            /// Parameter `b` defaults to `&default_shptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.SA? testShptrPtr(MR.CS.CSharp.SA? a, MR.CS.CSharp._InOptMut_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shptr_ptr(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared **b);
                MR.CS.CSharp.SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __c_ret = __MR_CSharp_test_shptr_ptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.CSharp.SA(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shptr_cptr`.
            /// Parameter `b` defaults to `&default_shptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_SA? testShptrCptr(MR.CS.CSharp.Const_SA? a, MR.CS.CSharp._InOptConst_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shptr_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shptr_cptr(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared **b);
                MR.CS.CSharp.Const_SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __c_ret = __MR_CSharp_test_shptr_cptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_SA(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr`.
            /// Parameter `b` defaults to `default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShcptr(MR.CS.CSharp._ByValueShared_SA a, MR.CS.CSharp._ByValueShared_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shcptr(a.PassByMode, a.Value is not null ? a.Value._UnderlyingSharedPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingSharedPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_ref`.
            /// Parameter `b` defaults to `default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.SA testShcptrRef(MR.CS.CSharp.SA a, MR.CS.CSharp.SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_ref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shcptr_ref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_cref`.
            /// Parameter `b` defaults to `default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_SA testShcptrCref(MR.CS.CSharp.Const_SA a, MR.CS.CSharp.Const_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_cref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return new(__MR_CSharp_test_shcptr_cref(a._UnderlyingSharedPtr, b is not null ? b._UnderlyingSharedPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_rref`.
            /// Parameter `b` defaults to `(std::shared_ptr<const MR::CSharp::SA>&&)default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.SA> testShcptrRref(MR.CS.Misc._Moved<MR.CS.CSharp.SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_rref(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.SA(__MR_CSharp_test_shcptr_rref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_crref`.
            /// Parameter `b` defaults to `(std::shared_ptr<const MR::CSharp::SA>&&)default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> testShcptrCrref(MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA> a, MR.CS.Misc._Moved<MR.CS.CSharp.Const_SA>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_crref(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.Const_SA(__MR_CSharp_test_shcptr_crref(a.Value._UnderlyingSharedPtr, b.HasValue ? b.Value.Value._UnderlyingSharedPtr : null), is_owning: false));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_ptr`.
            /// Parameter `b` defaults to `&default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.SA? testShcptrPtr(MR.CS.CSharp.SA? a, MR.CS.CSharp._InOptMut_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.SA._UnderlyingShared *__MR_CSharp_test_shcptr_ptr(MR.CS.CSharp.SA._UnderlyingShared *a, MR.CS.CSharp.SA._UnderlyingShared **b);
                MR.CS.CSharp.SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __c_ret = __MR_CSharp_test_shcptr_ptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.CSharp.SA(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_shcptr_cptr`.
            /// Parameter `b` defaults to `&default_shcptr`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_SA? testShcptrCptr(MR.CS.CSharp.Const_SA? a, MR.CS.CSharp._InOptConst_SA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_shcptr_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_SA._UnderlyingShared *__MR_CSharp_test_shcptr_cptr(MR.CS.CSharp.Const_SA._UnderlyingShared *a, MR.CS.CSharp.Const_SA._UnderlyingShared **b);
                MR.CS.CSharp.Const_SA._UnderlyingShared *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingSharedPtr : null;
                var __c_ret = __MR_CSharp_test_shcptr_cptr(a is not null ? a._UnderlyingSharedPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_SA(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string`.
            /// Parameter `b` defaults to `default_string`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.String> testString(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.String(__MR_CSharp_test_string(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_ref`.
            /// Parameter `b` defaults to `default_string`.
            /// </summary>
            public static unsafe MR.CS.Std.String testStringRef(MR.CS.Std.String a, MR.CS.Std.String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_ref", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_ref(MR.CS.Std.String._Underlying *a, MR.CS.Std.String._Underlying *b);
                return new(__MR_CSharp_test_string_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_cref`.
            /// Parameter `b` defaults to `default_string`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_String testStringCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_string_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_rref`.
            /// Parameter `b` defaults to `(std::string&&)default_string`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.String> testStringRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_rref", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.String(__MR_CSharp_test_string_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_crref`.
            /// Parameter `b` defaults to `(std::string&&)default_string`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Const_String> testStringCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Const_String(__MR_CSharp_test_string_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_ptr`.
            /// Parameter `b` defaults to `&default_string`.
            /// </summary>
            public static unsafe MR.CS.Std.String? testStringPtr(MR.CS.Std.String? a, MR.CS.Std._InOptMut_String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.String._Underlying *__MR_CSharp_test_string_ptr(MR.CS.Std.String._Underlying *a, MR.CS.Std.String._Underlying **b);
                MR.CS.Std.String._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_string_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.String(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_string_cptr`.
            /// Parameter `b` defaults to `&default_string`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_String? testStringCptr(MR.CS.Std.Const_String? a, MR.CS.Std._InOptConst_String? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_string_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_String._Underlying *__MR_CSharp_test_string_cptr(MR.CS.Std.Const_String._Underlying *a, MR.CS.Std.Const_String._Underlying **b);
                MR.CS.Std.Const_String._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_string_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Const_String(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview`.
            /// Parameter `b` defaults to `default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Std.StringView testStringview(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_stringview(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true);
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_ref`.
            /// Parameter `b` defaults to `default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Std.StringView testStringviewRef(MR.CS.Std.StringView a, MR.CS.Std.StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_ref", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_ref(MR.CS.Std.StringView._Underlying *a, MR.CS.Std.StringView._Underlying *b);
                return new(__MR_CSharp_test_stringview_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_cref`.
            /// Parameter `b` defaults to `default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_StringView testStringviewCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_stringview_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_rref`.
            /// Parameter `b` defaults to `(std::string_view&&)default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.StringView> testStringviewRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_rref", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.StringView(__MR_CSharp_test_stringview_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_crref`.
            /// Parameter `b` defaults to `(std::string_view&&)default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Const_StringView> testStringviewCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Const_StringView(__MR_CSharp_test_stringview_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_ptr`.
            /// Parameter `b` defaults to `&default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Std.StringView? testStringviewPtr(MR.CS.Std.StringView? a, MR.CS.Std._InOptMut_StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.StringView._Underlying *__MR_CSharp_test_stringview_ptr(MR.CS.Std.StringView._Underlying *a, MR.CS.Std.StringView._Underlying **b);
                MR.CS.Std.StringView._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_stringview_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.StringView(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_stringview_cptr`.
            /// Parameter `b` defaults to `&default_stringview`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_StringView? testStringviewCptr(MR.CS.Std.Const_StringView? a, MR.CS.Std._InOptConst_StringView? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_stringview_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_StringView._Underlying *__MR_CSharp_test_stringview_cptr(MR.CS.Std.Const_StringView._Underlying *a, MR.CS.Std.Const_StringView._Underlying **b);
                MR.CS.Std.Const_StringView._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_stringview_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Const_StringView(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath`.
            /// Parameter `b` defaults to `default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Path> testFspath(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Path(__MR_CSharp_test_fspath(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: true));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_ref`.
            /// Parameter `b` defaults to `default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Std.Filesystem.Path testFspathRef(MR.CS.Std.Filesystem.Path a, MR.CS.Std.Filesystem.Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_ref(MR.CS.Std.Filesystem.Path._Underlying *a, MR.CS.Std.Filesystem.Path._Underlying *b);
                return new(__MR_CSharp_test_fspath_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_cref`.
            /// Parameter `b` defaults to `default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Std.Filesystem.Const_Path testFspathCref(ReadOnlySpan<char> a, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_cref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return new(__MR_CSharp_test_fspath_cref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false);
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_rref`.
            /// Parameter `b` defaults to `(std::filesystem::path&&)default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Path> testFspathRref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_rref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_rref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Path(__MR_CSharp_test_fspath_rref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_crref`.
            /// Parameter `b` defaults to `(std::filesystem::path&&)default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Filesystem.Const_Path> testFspathCrref(MR.CS.Misc._MoveRef _move_a, ReadOnlySpan<char> a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.Misc.ReadOnlyCharSpanOpt b = new())
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_crref", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_crref(byte *a, byte *a_end, byte *b, byte *b_end);
                byte[] __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Length)];
                int __len_a = System.Text.Encoding.UTF8.GetBytes(a, __bytes_a);
                fixed (byte *__ptr_a = __bytes_a)
                {
                    byte[] __bytes_b;
                    int __len_b = 0;
                    if (b.HasValue)
                    {
                        __bytes_b = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(b.Value.Length)];
                        __len_b = System.Text.Encoding.UTF8.GetBytes(b.Value, __bytes_b);
                    }
                    fixed (byte *__ptr_b = __bytes_b)
                    {
                        return MR.CS.Misc.Move(new MR.CS.Std.Filesystem.Const_Path(__MR_CSharp_test_fspath_crref(__ptr_a, __ptr_a + __len_a, b.HasValue ? __ptr_b : null, b.HasValue ? __ptr_b + __len_b : null), is_owning: false));
                    }
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_ptr`.
            /// Parameter `b` defaults to `&default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Std.Filesystem.Path? testFspathPtr(MR.CS.Std.Filesystem.Path? a, MR.CS.Std.Filesystem._InOptMut_Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Path._Underlying *__MR_CSharp_test_fspath_ptr(MR.CS.Std.Filesystem.Path._Underlying *a, MR.CS.Std.Filesystem.Path._Underlying **b);
                MR.CS.Std.Filesystem.Path._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_fspath_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Filesystem.Path(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_fspath_cptr`.
            /// Parameter `b` defaults to `&default_fspath`.
            /// </summary>
            public static unsafe MR.CS.Std.Filesystem.Const_Path? testFspathCptr(MR.CS.Std.Filesystem.Const_Path? a, MR.CS.Std.Filesystem._InOptConst_Path? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_fspath_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Filesystem.Const_Path._Underlying *__MR_CSharp_test_fspath_cptr(MR.CS.Std.Filesystem.Const_Path._Underlying *a, MR.CS.Std.Filesystem.Const_Path._Underlying **b);
                MR.CS.Std.Filesystem.Const_Path._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_fspath_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Filesystem.Const_Path(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::operator+`.
            /// </summary>
            public static unsafe int add(MR.CS.CSharp._ByValue_StaticOpsLhsC _1, int _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsLhsC_int32_t", ExactSpelling = true)]
                extern static int __MR_C_add_MR_CSharp_StaticOpsLhsC_int32_t(MR.CS.Misc._PassBy _1_pass_by, MR.CS.CSharp.StaticOpsLhsC._Underlying *_1, int _2);
                return __MR_C_add_MR_CSharp_StaticOpsLhsC_int32_t(_1.PassByMode, _1.Value is not null ? _1.Value._UnderlyingPtr : null, _2);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::operator+`.
            /// </summary>
            public static unsafe int add(int _1, MR.CS.CSharp._ByValue_StaticOpsRhsC _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_int32_t_MR_CSharp_StaticOpsRhsC", ExactSpelling = true)]
                extern static int __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsC(int _1, MR.CS.Misc._PassBy _2_pass_by, MR.CS.CSharp.StaticOpsRhsC._Underlying *_2);
                return __MR_C_add_int32_t_MR_CSharp_StaticOpsRhsC(_1, _2.PassByMode, _2.Value is not null ? _2.Value._UnderlyingPtr : null);
            }

            // Fails to inject, becomes a free function.
            /// <summary>
            /// Generated from function `MR::CSharp::operator+`.
            /// </summary>
            public static int add(MR.CS.CSharp.StaticOpsEnum _1, int _2)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_C_add_MR_CSharp_StaticOpsEnum_int32_t", ExactSpelling = true)]
                extern static int __MR_C_add_MR_CSharp_StaticOpsEnum_int32_t(MR.CS.CSharp.StaticOpsEnum _1, int _2);
                return __MR_C_add_MR_CSharp_StaticOpsEnum_int32_t(_1, _2);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convtrivial`.
            /// Parameter `b` defaults to `{}`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConvCtorTrivial testClassConvtrivial(MR.CS.CSharp.Const_ConvCtorTrivial a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convtrivial_ref`.
            /// Parameter `b` defaults to `default_convtrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConvCtorTrivial testClassConvtrivialRef(MR.CS.CSharp.ConvCtorTrivial a, MR.CS.CSharp.ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_ref(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convtrivial_cref`.
            /// Parameter `b` defaults to `default_convtrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_ConvCtorTrivial testClassConvtrivialCref(MR.CS.CSharp.Const_ConvCtorTrivial a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_cref(MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convtrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convtrivial_ptr`.
            /// Parameter `c` defaults to `&default_convtrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConvCtorTrivial? testClassConvtrivialPtr(MR.CS.CSharp.ConvCtorTrivial? a, MR.CS.CSharp.ConvCtorTrivial? b = null, MR.CS.CSharp._InOptMut_ConvCtorTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_ptr(MR.CS.CSharp.ConvCtorTrivial._Underlying *a, MR.CS.CSharp.ConvCtorTrivial._Underlying *b, MR.CS.CSharp.ConvCtorTrivial._Underlying **c);
                MR.CS.CSharp.ConvCtorTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_convtrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.ConvCtorTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convtrivial_cptr`.
            /// Parameter `c` defaults to `&default_convtrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_ConvCtorTrivial? testClassConvtrivialCptr(MR.CS.CSharp.Const_ConvCtorTrivial? a, MR.CS.CSharp.Const_ConvCtorTrivial? b = null, MR.CS.CSharp._InOptConst_ConvCtorTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convtrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__MR_CSharp_test_class_convtrivial_cptr(MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *b, MR.CS.CSharp.Const_ConvCtorTrivial._Underlying **c);
                MR.CS.CSharp.Const_ConvCtorTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_convtrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_ConvCtorTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convnontrivial`.
            /// Parameter `b` defaults to `{}`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.ConvCtorNonTrivial> testClassConvnontrivial(MR.CS.CSharp._ByValue_ConvCtorNonTrivial a, MR.CS.CSharp._ByValue_ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.CSharp.ConvCtorNonTrivial(__MR_CSharp_test_class_convnontrivial(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convnontrivial_ref`.
            /// Parameter `b` defaults to `default_convnontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConvCtorNonTrivial testClassConvnontrivialRef(MR.CS.CSharp.ConvCtorNonTrivial a, MR.CS.CSharp.ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_ref(MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convnontrivial_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convnontrivial_cref`.
            /// Parameter `b` defaults to `default_convnontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_ConvCtorNonTrivial testClassConvnontrivialCref(MR.CS.CSharp.Const_ConvCtorNonTrivial a, MR.CS.CSharp.Const_ConvCtorNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_cref(MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_class_convnontrivial_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convnontrivial_ptr`.
            /// Parameter `c` defaults to `&default_convnontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConvCtorNonTrivial? testClassConvnontrivialPtr(MR.CS.CSharp.ConvCtorNonTrivial? a, MR.CS.CSharp.ConvCtorNonTrivial? b = null, MR.CS.CSharp._InOptMut_ConvCtorNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_ptr(MR.CS.CSharp.ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.ConvCtorNonTrivial._Underlying *b, MR.CS.CSharp.ConvCtorNonTrivial._Underlying **c);
                MR.CS.CSharp.ConvCtorNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_convnontrivial_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.ConvCtorNonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_class_convnontrivial_cptr`.
            /// Parameter `c` defaults to `&default_convnontrivial`.
            /// </summary>
            public static unsafe MR.CS.CSharp.Const_ConvCtorNonTrivial? testClassConvnontrivialCptr(MR.CS.CSharp.Const_ConvCtorNonTrivial? a, MR.CS.CSharp.Const_ConvCtorNonTrivial? b = null, MR.CS.CSharp._InOptConst_ConvCtorNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_class_convnontrivial_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__MR_CSharp_test_class_convnontrivial_cptr(MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *a, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *b, MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying **c);
                MR.CS.CSharp.Const_ConvCtorNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_class_convnontrivial_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.CSharp.Const_ConvCtorNonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed`.
            /// Parameter `b` defaults to `default_exposed`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ExposedLayout testExposed(MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp._InOpt_ExposedLayout b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout __MR_CSharp_test_exposed_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp.ExposedLayout *b);
                return __MR_CSharp_test_exposed_MR_CSharp_ExposedLayout(a, b.HasValue ? &b.Object : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_ref`.
            /// Parameter `b` defaults to `default_exposed`.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ExposedLayout testExposedRef(ref MR.CS.CSharp.ExposedLayout a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayout);
                    var __c_ret = __MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayout(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_cref`.
            /// Parameter `b` defaults to `default_exposed`.
            /// </summary>
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedCref(in MR.CS.CSharp.ExposedLayout a, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayout(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::ExposedLayout&&)default_exposed`.
            /// </summary>
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedRref(MR.CS.Misc._MoveRef _move_a, in MR.CS.CSharp.ExposedLayout a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_rref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_rref(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_rref(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::ExposedLayout&&)default_exposed`.
            /// </summary>
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayout testExposedCrref(MR.CS.Misc._MoveRef _move_a, in MR.CS.CSharp.ExposedLayout a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.CSharp.ExposedLayout? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_crref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_crref(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_crref(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_ptr`.
            /// Parameter `c` defaults to `&default_exposed`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>? testExposedPtr(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayout>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.ExposedLayout>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout **c);
                MR.CS.CSharp.ExposedLayout __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayout_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayout>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_cptr`.
            /// Parameter `c` defaults to `&default_exposed`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ExposedLayout? testExposedCptr(MR.CS.CSharp.ExposedLayout? a, MR.CS.CSharp.ExposedLayout? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.ExposedLayout>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayout *__MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr(MR.CS.CSharp.ExposedLayout *a, MR.CS.CSharp.ExposedLayout *b, MR.CS.CSharp.ExposedLayout **c);
                MR.CS.CSharp.ExposedLayout __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayout __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayout __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayout);
                MR.CS.CSharp.ExposedLayout *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayout_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                if (__c_ret is not null) return *__c_ret; else return null;
            }

            // This broke at one point, so testing it too.
            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_vec`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Vector_MRCSharpExposedLayout> testExposedVec()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_vec", ExactSpelling = true)]
                extern static MR.CS.Std.Vector_MRCSharpExposedLayout._Underlying *__MR_CSharp_test_exposed_vec();
                return MR.CS.Misc.Move(new MR.CS.Std.Vector_MRCSharpExposedLayout(__MR_CSharp_test_exposed_vec(), is_owning: true));
            }

            // Test that capturing lifetime of an exposed struct is a no-op.
            /// <summary>
            /// Generated from function `MR::CSharp::asave_ref_in_exposed_layout`.
            /// </summary>
            public static unsafe MR.CS.CSharp.NonTrivial asaveRefInExposedLayout(ref MR.CS.CSharp.ExposedLayout ref_)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_asave_ref_in_exposed_layout", ExactSpelling = true)]
                extern static MR.CS.CSharp.NonTrivial._Underlying *__MR_CSharp_asave_ref_in_exposed_layout(MR.CS.CSharp.ExposedLayout *ref_);
                fixed (MR.CS.CSharp.ExposedLayout *__ptr_ref_ = &ref_)
                {
                    MR.CS.CSharp.NonTrivial __ret;
                    __ret = new(__MR_CSharp_asave_ref_in_exposed_layout(__ptr_ref_), is_owning: false);
                    return __ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::make_exposed_sh`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.CSharp.Box_ExposedLayoutSh> makeExposedSh()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_make_exposed_sh", ExactSpelling = true)]
                extern static MR.CS.CSharp.Box_ExposedLayoutSh._UnderlyingShared *__MR_CSharp_make_exposed_sh();
                return MR.CS.Misc.Move(new MR.CS.CSharp.Box_ExposedLayoutSh(__MR_CSharp_make_exposed_sh(), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ExposedLayoutSh testExposed(MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp._InOpt_ExposedLayoutSh b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh __MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp.ExposedLayoutSh *b);
                return __MR_CSharp_test_exposed_MR_CSharp_ExposedLayoutSh(a, b.HasValue ? &b.Object : null);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_ref`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ExposedLayoutSh testExposedRef(ref MR.CS.CSharp.ExposedLayoutSh a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b);
                fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayoutSh __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                    var __c_ret = __MR_CSharp_test_exposed_ref_MR_CSharp_ExposedLayoutSh(__ptr_a, b is not null ? &__value_b : null);
                    if (b is not null) b.Value = __value_b;
                    return ref *__c_ret;
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_cref`.
            /// Parameter `b` defaults to `default_exposed_sh`.
            /// </summary>
            public static unsafe ref readonly MR.CS.CSharp.ExposedLayoutSh testExposedCref(in MR.CS.CSharp.ExposedLayoutSh a, MR.CS.CSharp.ExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b);
                fixed (MR.CS.CSharp.ExposedLayoutSh *__ptr_a = &a)
                {
                    MR.CS.CSharp.ExposedLayoutSh __deref_b = b.GetValueOrDefault();
                    return ref *__MR_CSharp_test_exposed_cref_MR_CSharp_ExposedLayoutSh(__ptr_a, b.HasValue ? &__deref_b : null);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_ptr`.
            /// Parameter `c` defaults to `&default_exposed_sh`.
            /// </summary>
            public static unsafe MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayoutSh>? testExposedPtr(MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? a, MR.CS.Misc.InOut<MR.CS.CSharp.ExposedLayoutSh>? b = null, MR.CS.Misc._InOutOpt<MR.CS.CSharp.ExposedLayoutSh>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b, MR.CS.CSharp.ExposedLayoutSh **c);
                MR.CS.CSharp.ExposedLayoutSh __value_a = a is not null ? a.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh __value_b = b is not null ? b.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_exposed_ptr_MR_CSharp_ExposedLayoutSh_ptr(a is not null ? &__value_a : null, b is not null ? &__value_b : null, c is not null ? &__valueptr_c : null);
                if (c is not null && c.Opt is not null) c.Opt.Value = __value_c;
                if (b is not null) b.Value = __value_b;
                if (a is not null) a.Value = __value_a;
                return __c_ret is not null ? new MR.CS.Misc.Ref<MR.CS.CSharp.ExposedLayoutSh>(__c_ret) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_exposed_cptr`.
            /// Parameter `c` defaults to `&default_exposed_sh`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ExposedLayoutSh? testExposedCptr(MR.CS.CSharp.ExposedLayoutSh? a, MR.CS.CSharp.ExposedLayoutSh? b = null, MR.CS.Misc._InOpt<MR.CS.CSharp.ExposedLayoutSh>? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ExposedLayoutSh *__MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.CSharp.ExposedLayoutSh *b, MR.CS.CSharp.ExposedLayoutSh **c);
                MR.CS.CSharp.ExposedLayoutSh __deref_a = a.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayoutSh __deref_b = b.GetValueOrDefault();
                MR.CS.CSharp.ExposedLayoutSh __value_c = c is not null && c.Opt is not null ? c.Opt.Value : default(MR.CS.CSharp.ExposedLayoutSh);
                MR.CS.CSharp.ExposedLayoutSh *__valueptr_c = c is not null && c.Opt is not null ? &__value_c : null;
                var __c_ret = __MR_CSharp_test_exposed_cptr_const_MR_CSharp_ExposedLayoutSh_ptr(a.HasValue ? &__deref_a : null, b.HasValue ? &__deref_b : null, c is not null ? &__valueptr_c : null);
                if (__c_ret is not null) return *__c_ret; else return null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optint`.
            /// Parameter `b` defaults to `default_optint`.
            /// Parameter `c` defaults to `default_optint`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_Int32T testOptint(int? a, MR.CS.Std.Const_Optional_Int32T? b = null, MR.CS.Std.Const_Optional_Int32T? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int32T._Underlying *__MR_CSharp_test_optint(int *a, MR.CS.Std.Optional_Int32T._Underlying *b, MR.CS.Std.Optional_Int32T._Underlying *c);
                int __deref_a = a.GetValueOrDefault();
                return new(__MR_CSharp_test_optint(a.HasValue ? &__deref_a : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optint_ref`.
            /// Parameter `b` defaults to `default_optint`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_Int32T testOptintRef(MR.CS.Std.Optional_Int32T a, MR.CS.Std.Optional_Int32T? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int32T._Underlying *__MR_CSharp_test_optint_ref(MR.CS.Std.Optional_Int32T._Underlying *a, MR.CS.Std.Optional_Int32T._Underlying *b);
                return new(__MR_CSharp_test_optint_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optint_cref`.
            /// Parameter `b` defaults to `default_optint`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_Int32T testOptintCref(int? a, MR.CS.Std.Const_Optional_Int32T? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_Int32T._Underlying *__MR_CSharp_test_optint_cref(int *a, MR.CS.Std.Const_Optional_Int32T._Underlying *b);
                int __deref_a = a.GetValueOrDefault();
                return new(__MR_CSharp_test_optint_cref(a.HasValue ? &__deref_a : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optint_ptr`.
            /// Parameter `c` defaults to `&default_optint`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_Int32T? testOptintPtr(MR.CS.Std.Optional_Int32T? a, MR.CS.Std.Optional_Int32T? b = null, MR.CS.Std._InOptMut_Optional_Int32T? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_Int32T._Underlying *__MR_CSharp_test_optint_ptr(MR.CS.Std.Optional_Int32T._Underlying *a, MR.CS.Std.Optional_Int32T._Underlying *b, MR.CS.Std.Optional_Int32T._Underlying **c);
                MR.CS.Std.Optional_Int32T._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optint_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_Int32T(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optint_cptr`.
            /// Parameter `c` defaults to `&default_optint`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_Int32T? testOptintCptr(MR.CS.Std.Const_Optional_Int32T? a, MR.CS.Std.Const_Optional_Int32T? b = null, MR.CS.Std._InOptConst_Optional_Int32T? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optint_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_Int32T._Underlying *__MR_CSharp_test_optint_cptr(MR.CS.Std.Const_Optional_Int32T._Underlying *a, MR.CS.Std.Const_Optional_Int32T._Underlying *b, MR.CS.Std.Const_Optional_Int32T._Underlying **c);
                MR.CS.Std.Const_Optional_Int32T._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optint_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_Int32T(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optstr`.
            /// Parameter `b` defaults to `default_optstr`.
            /// Parameter `c` defaults to `default_optstr`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Optional_StdString> testOptstr(MR.CS.Misc.ReadOnlyCharSpanOpt a, MR.CS.Std._ByValue_Optional_StdString? b = null, MR.CS.Std._ByValue_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr(byte *a, byte *a_end, MR.CS.Misc._PassBy b_pass_by, MR.CS.Std.Optional_StdString._Underlying *b, MR.CS.Misc._PassBy c_pass_by, MR.CS.Std.Optional_StdString._Underlying *c);
                byte[] __bytes_a;
                int __len_a = 0;
                if (a.HasValue)
                {
                    __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Value.Length)];
                    __len_a = System.Text.Encoding.UTF8.GetBytes(a.Value, __bytes_a);
                }
                fixed (byte *__ptr_a = __bytes_a)
                {
                    return MR.CS.Misc.Move(new MR.CS.Std.Optional_StdString(__MR_CSharp_test_optstr(a.HasValue ? __ptr_a : null, a.HasValue ? __ptr_a + __len_a : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null, c is not null ? c.PassByMode : MR.CS.Misc._PassBy.default_arg, c is not null && c.Value is not null ? c.Value._UnderlyingPtr : null), is_owning: true));
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optstr_ref`.
            /// Parameter `b` defaults to `default_optstr`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_StdString testOptstrRef(MR.CS.Std.Optional_StdString a, MR.CS.Std.Optional_StdString? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr_ref(MR.CS.Std.Optional_StdString._Underlying *a, MR.CS.Std.Optional_StdString._Underlying *b);
                return new(__MR_CSharp_test_optstr_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optstr_cref`.
            /// Parameter `b` defaults to `default_optstr`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_StdString testOptstrCref(MR.CS.Misc.ReadOnlyCharSpanOpt a, MR.CS.Std.Const_Optional_StdString? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_StdString._Underlying *__MR_CSharp_test_optstr_cref(byte *a, byte *a_end, MR.CS.Std.Const_Optional_StdString._Underlying *b);
                byte[] __bytes_a;
                int __len_a = 0;
                if (a.HasValue)
                {
                    __bytes_a = new byte[System.Text.Encoding.UTF8.GetMaxByteCount(a.Value.Length)];
                    __len_a = System.Text.Encoding.UTF8.GetBytes(a.Value, __bytes_a);
                }
                fixed (byte *__ptr_a = __bytes_a)
                {
                    return new(__MR_CSharp_test_optstr_cref(a.HasValue ? __ptr_a : null, a.HasValue ? __ptr_a + __len_a : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optstr_ptr`.
            /// Parameter `c` defaults to `&default_optstr`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_StdString? testOptstrPtr(MR.CS.Std.Optional_StdString? a, MR.CS.Std.Optional_StdString? b = null, MR.CS.Std._InOptMut_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_StdString._Underlying *__MR_CSharp_test_optstr_ptr(MR.CS.Std.Optional_StdString._Underlying *a, MR.CS.Std.Optional_StdString._Underlying *b, MR.CS.Std.Optional_StdString._Underlying **c);
                MR.CS.Std.Optional_StdString._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optstr_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_StdString(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optstr_cptr`.
            /// Parameter `c` defaults to `&default_optstr`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_StdString? testOptstrCptr(MR.CS.Std.Const_Optional_StdString? a, MR.CS.Std.Const_Optional_StdString? b = null, MR.CS.Std._InOptConst_Optional_StdString? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optstr_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_StdString._Underlying *__MR_CSharp_test_optstr_cptr(MR.CS.Std.Const_Optional_StdString._Underlying *a, MR.CS.Std.Const_Optional_StdString._Underlying *b, MR.CS.Std.Const_Optional_StdString._Underlying **c);
                MR.CS.Std.Const_Optional_StdString._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optstr_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_StdString(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_opttriv`.
            /// Parameter `b` defaults to `default_opttriv`.
            /// Parameter `c` defaults to `default_opttriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial testOpttriv(MR.CS.CSharp.Const_Trivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null, MR.CS.Std.Const_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *c);
                return new(__MR_CSharp_test_opttriv(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_opttriv_ref`.
            /// Parameter `b` defaults to `default_opttriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial testOpttrivRef(MR.CS.Std.Optional_MRCSharpTrivial a, MR.CS.Std.Optional_MRCSharpTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_ref(MR.CS.Std.Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b);
                return new(__MR_CSharp_test_opttriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_opttriv_cref`.
            /// Parameter `b` defaults to `default_opttriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpTrivial testOpttrivCref(MR.CS.CSharp.Const_Trivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_cref(MR.CS.CSharp.Trivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *b);
                return new(__MR_CSharp_test_opttriv_cref(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_opttriv_ptr`.
            /// Parameter `c` defaults to `&default_opttriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpTrivial? testOpttrivPtr(MR.CS.Std.Optional_MRCSharpTrivial? a, MR.CS.Std.Optional_MRCSharpTrivial? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_ptr(MR.CS.Std.Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpTrivial._Underlying **c);
                MR.CS.Std.Optional_MRCSharpTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_opttriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_MRCSharpTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_opttriv_cptr`.
            /// Parameter `c` defaults to `&default_opttriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpTrivial? testOpttrivCptr(MR.CS.Std.Const_Optional_MRCSharpTrivial? a, MR.CS.Std.Const_Optional_MRCSharpTrivial? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_opttriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__MR_CSharp_test_opttriv_cptr(MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_opttriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optnontriv`.
            /// Parameter `b` defaults to `default_optnontriv`.
            /// Parameter `c` defaults to `default_optnontriv`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Optional_MRCSharpNonTrivial> testOptnontriv(MR.CS.CSharp._ByValue_NonTrivial? a, MR.CS.CSharp._ByValueOptOpt_NonTrivial? b = null, MR.CS.CSharp._ByValueOptOpt_NonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b, MR.CS.Misc._PassBy c_pass_by, MR.CS.CSharp.NonTrivial._Underlying *c);
                return MR.CS.Misc.Move(new MR.CS.Std.Optional_MRCSharpNonTrivial(__MR_CSharp_test_optnontriv(a is not null ? a.PassByMode : MR.CS.Misc._PassBy.no_object, a is not null && a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null, c is not null ? c.PassByMode : MR.CS.Misc._PassBy.default_arg, c is not null && c.Value is not null ? c.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optnontriv_ref`.
            /// Parameter `b` defaults to `default_optnontriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpNonTrivial testOptnontrivRef(MR.CS.Std.Optional_MRCSharpNonTrivial a, MR.CS.Std.Optional_MRCSharpNonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_ref(MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *b);
                return new(__MR_CSharp_test_optnontriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optnontriv_cref`.
            /// Parameter `b` defaults to `default_optnontriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpNonTrivial testOptnontrivCref(MR.CS.CSharp._ByValue_NonTrivial? a, MR.CS.CSharp._ByValueOptOpt_NonTrivial? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_cref(MR.CS.Misc._PassBy a_pass_by, MR.CS.CSharp.NonTrivial._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.CSharp.NonTrivial._Underlying *b);
                return new(__MR_CSharp_test_optnontriv_cref(a is not null ? a.PassByMode : MR.CS.Misc._PassBy.no_object, a is not null && a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optnontriv_ptr`.
            /// Parameter `c` defaults to `&default_optnontriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpNonTrivial? testOptnontrivPtr(MR.CS.Std.Optional_MRCSharpNonTrivial? a, MR.CS.Std.Optional_MRCSharpNonTrivial? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_ptr(MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *b, MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying **c);
                MR.CS.Std.Optional_MRCSharpNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optnontriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_MRCSharpNonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optnontriv_cptr`.
            /// Parameter `c` defaults to `&default_optnontriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpNonTrivial? testOptnontrivCptr(MR.CS.Std.Const_Optional_MRCSharpNonTrivial? a, MR.CS.Std.Const_Optional_MRCSharpNonTrivial? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpNonTrivial? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optnontriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__MR_CSharp_test_optnontriv_cptr(MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpNonTrivial._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optnontriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpNonTrivial(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshexp`.
            /// Parameter `b` defaults to `default_optshexp`.
            /// Parameter `c` defaults to `default_optshexp`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh testOptshexp(MR.CS.CSharp._InOpt_ExposedLayoutSh a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *c);
                return new(__MR_CSharp_test_optshexp(a.HasValue ? &a.Object : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshexp_ref`.
            /// Parameter `b` defaults to `default_optshexp`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh testOptshexpRef(MR.CS.Std.Optional_MRCSharpExposedLayoutSh a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_ref(MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b);
                return new(__MR_CSharp_test_optshexp_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshexp_cref`.
            /// Parameter `b` defaults to `default_optshexp`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh testOptshexpCref(MR.CS.CSharp._InOpt_ExposedLayoutSh a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_cref(MR.CS.CSharp.ExposedLayoutSh *a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *b);
                return new(__MR_CSharp_test_optshexp_cref(a.HasValue ? &a.Object : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshexp_ptr`.
            /// Parameter `c` defaults to `&default_optshexp`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpExposedLayoutSh? testOptshexpPtr(MR.CS.Std.Optional_MRCSharpExposedLayoutSh? a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_ptr(MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying **c);
                MR.CS.Std.Optional_MRCSharpExposedLayoutSh._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optshexp_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_MRCSharpExposedLayoutSh(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshexp_cptr`.
            /// Parameter `c` defaults to `&default_optshexp`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? testOptshexpCptr(MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpExposedLayoutSh? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshexp_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__MR_CSharp_test_optshexp_cptr(MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optshexp_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpExposedLayoutSh(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshtriv`.
            /// Parameter `b` defaults to `default_optshtriv`.
            /// Parameter `c` defaults to `default_optshtriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpSA testOptshtriv(MR.CS.CSharp.Const_SA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null, MR.CS.Std.Const_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv(MR.CS.CSharp.SA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Optional_MRCSharpSA._Underlying *c);
                return new(__MR_CSharp_test_optshtriv(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? c._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshtriv_ref`.
            /// Parameter `b` defaults to `default_optshtriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpSA testOptshtrivRef(MR.CS.Std.Optional_MRCSharpSA a, MR.CS.Std.Optional_MRCSharpSA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_ref(MR.CS.Std.Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b);
                return new(__MR_CSharp_test_optshtriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshtriv_cref`.
            /// Parameter `b` defaults to `default_optshtriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpSA testOptshtrivCref(MR.CS.CSharp.Const_SA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_cref(MR.CS.CSharp.SA._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *b);
                return new(__MR_CSharp_test_optshtriv_cref(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshtriv_ptr`.
            /// Parameter `c` defaults to `&default_optshtriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Optional_MRCSharpSA? testOptshtrivPtr(MR.CS.Std.Optional_MRCSharpSA? a, MR.CS.Std.Optional_MRCSharpSA? b = null, MR.CS.Std._InOptMut_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_ptr(MR.CS.Std.Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Optional_MRCSharpSA._Underlying **c);
                MR.CS.Std.Optional_MRCSharpSA._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optshtriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Optional_MRCSharpSA(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_optshtriv_cptr`.
            /// Parameter `c` defaults to `&default_optshtriv`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Optional_MRCSharpSA? testOptshtrivCptr(MR.CS.Std.Const_Optional_MRCSharpSA? a, MR.CS.Std.Const_Optional_MRCSharpSA? b = null, MR.CS.Std._InOptConst_Optional_MRCSharpSA? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_optshtriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__MR_CSharp_test_optshtriv_cptr(MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *a, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *b, MR.CS.Std.Const_Optional_MRCSharpSA._Underlying **c);
                MR.CS.Std.Const_Optional_MRCSharpSA._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_optshtriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Optional_MRCSharpSA(__c_ret, is_owning: false) : null;
            }

            // Tag types:
            /// <summary>
            /// Generated from function `MR::CSharp::test_tag`.
            /// </summary>
            public static MR.CS.Std.Greater_Int32T testTag(MR.CS.Std.Greater_Int32T a, MR.CS.Std.Greater_Int32T b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag", ExactSpelling = true)]
                extern static void __MR_CSharp_test_tag();
                __MR_CSharp_test_tag();
                return new();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_tag_cref`.
            /// </summary>
            public static void testTagCref(MR.CS.Std.Greater_Int32T a, MR.CS.Std.Greater_Int32T b = default)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_cref", ExactSpelling = true)]
                extern static void __MR_CSharp_test_tag_cref();
                __MR_CSharp_test_tag_cref();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_tag_ptr`.
            /// </summary>
            public static MR.CS.Std.Greater_Int32T? testTagPtr()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_ptr", ExactSpelling = true)]
                extern static bool __MR_CSharp_test_tag_ptr();
                return __MR_CSharp_test_tag_ptr() ? new MR.CS.Std.Greater_Int32T() : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_tag_cptr`.
            /// </summary>
            public static MR.CS.Std.Greater_Int32T? testTagCptr()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_tag_cptr", ExactSpelling = true)]
                extern static bool __MR_CSharp_test_tag_cptr();
                return __MR_CSharp_test_tag_cptr() ? new MR.CS.Std.Greater_Int32T() : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_variant`.
            /// Parameter `b` defaults to `default_variant`.
            /// </summary>
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int32T_Float testVariant(MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float a, MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *__MR_CSharp_test_variant(MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_variant(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_variant_ref`.
            /// Parameter `b` defaults to `default_variant`.
            /// </summary>
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int32T_Float testVariantRef(MR.CS.Std.Variant_StdMonostate_Int32T_Float a, MR.CS.Std.Variant_StdMonostate_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *__MR_CSharp_test_variant_ref(MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_variant_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_variant_cref`.
            /// Parameter `b` defaults to `default_variant`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float testVariantCref(MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float a, MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *__MR_CSharp_test_variant_cref(MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *a, MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_variant_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_variant_ptr`.
            /// Parameter `b` defaults to `&default_variant`.
            /// </summary>
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int32T_Float? testVariantPtr(MR.CS.Std.Variant_StdMonostate_Int32T_Float? a, MR.CS.Std._InOptMut_Variant_StdMonostate_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *__MR_CSharp_test_variant_ptr(MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *a, MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying **b);
                MR.CS.Std.Variant_StdMonostate_Int32T_Float._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_variant_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Variant_StdMonostate_Int32T_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_variant_cptr`.
            /// Parameter `b` defaults to `&default_variant`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float? testVariantCptr(MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float? a, MR.CS.Std._InOptConst_Variant_StdMonostate_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *__MR_CSharp_test_variant_cptr(MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *a, MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying **b);
                MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float._Underlying *__ptr_b = b is not null && b.Opt is not null ? b.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_variant_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? &__ptr_b : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Variant_StdMonostate_Int32T_Float(__c_ret, is_owning: false) : null;
            }

            // Test a variant that has duplicate element types.
            /// <summary>
            /// Generated from function `MR::CSharp::test_variant_with_repeated_types`.
            /// </summary>
            public static unsafe MR.CS.Std.Variant_StdMonostate_Int32T_Float_Float testVariantWithRepeatedTypes()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_variant_with_repeated_types", ExactSpelling = true)]
                extern static MR.CS.Std.Variant_StdMonostate_Int32T_Float_Float._Underlying *__MR_CSharp_test_variant_with_repeated_types();
                return new(__MR_CSharp_test_variant_with_repeated_types(), is_owning: true);
            }

            // Input and output streams:
            /// <summary>
            /// Generated from function `MR::CSharp::test_iostreams_ref`.
            /// </summary>
            public static unsafe MR.CS.Std.Ostream testIostreamsRef(MR.CS.Std.Istream _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Ostream._Underlying *__MR_CSharp_test_iostreams_ref(MR.CS.Std.Istream._Underlying *_1);
                return new(__MR_CSharp_test_iostreams_ref(_1._UnderlyingPtr), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_iostreams_ptr`.
            /// </summary>
            public static unsafe MR.CS.Std.Ostream? testIostreamsPtr(MR.CS.Std.Istream? _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.Ostream._Underlying *__MR_CSharp_test_iostreams_ptr(MR.CS.Std.Istream._Underlying *_1);
                var __c_ret = __MR_CSharp_test_iostreams_ptr(_1 is not null ? _1._UnderlyingPtr : null);
                return __c_ret is not null ? new MR.CS.Std.Ostream(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_iostreams_cref`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Ostream testIostreamsCref(MR.CS.Std.Const_Istream _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Ostream._Underlying *__MR_CSharp_test_iostreams_cref(MR.CS.Std.Const_Istream._Underlying *_1);
                return new(__MR_CSharp_test_iostreams_cref(_1._UnderlyingPtr), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_iostreams_cptr`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_Ostream? testIostreamsCptr(MR.CS.Std.Const_Istream? _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_iostreams_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_Ostream._Underlying *__MR_CSharp_test_iostreams_cptr(MR.CS.Std.Const_Istream._Underlying *_1);
                var __c_ret = __MR_CSharp_test_iostreams_cptr(_1 is not null ? _1._UnderlyingPtr : null);
                return __c_ret is not null ? new MR.CS.Std.Const_Ostream(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_uniqueptr`.
            /// Parameter `b` defaults to `std::move(default_uniqueptr)`.
            /// </summary>
            public static unsafe void *testUniqueptr(void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr", ExactSpelling = true)]
                extern static void *__MR_CSharp_test_uniqueptr(void *a, void *b);
                return __MR_CSharp_test_uniqueptr(a, b);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_uniqueptr_ref`.
            /// Parameter `b` defaults to `default_uniqueptr`.
            /// </summary>
            public static unsafe MR.CS.Std.UniquePtr_Int32T testUniqueptrRef(MR.CS.Std.UniquePtr_Int32T a, MR.CS.Std.UniquePtr_Int32T? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_ref", ExactSpelling = true)]
                extern static MR.CS.Std.UniquePtr_Int32T._Underlying *__MR_CSharp_test_uniqueptr_ref(MR.CS.Std.UniquePtr_Int32T._Underlying *a, MR.CS.Std.UniquePtr_Int32T._Underlying *b);
                return new(__MR_CSharp_test_uniqueptr_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_uniqueptr_cref`.
            /// Parameter `b` defaults to `default_uniqueptr`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_UniquePtr_Int32T testUniqueptrCref(MR.CS.Std.Const_UniquePtr_Int32T a, MR.CS.Std.Const_UniquePtr_Int32T? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_cref", ExactSpelling = true)]
                extern static MR.CS.Std.Const_UniquePtr_Int32T._Underlying *__MR_CSharp_test_uniqueptr_cref(MR.CS.Std.Const_UniquePtr_Int32T._Underlying *a, MR.CS.Std.Const_UniquePtr_Int32T._Underlying *b);
                return new(__MR_CSharp_test_uniqueptr_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_uniqueptr_ptr`.
            /// Parameter `c` defaults to `&default_uniqueptr`.
            /// </summary>
            public static unsafe MR.CS.Std.UniquePtr_Int32T? testUniqueptrPtr(MR.CS.Std.UniquePtr_Int32T? a, MR.CS.Std.UniquePtr_Int32T? b = null, MR.CS.Std._InOptMut_UniquePtr_Int32T? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_ptr", ExactSpelling = true)]
                extern static MR.CS.Std.UniquePtr_Int32T._Underlying *__MR_CSharp_test_uniqueptr_ptr(MR.CS.Std.UniquePtr_Int32T._Underlying *a, MR.CS.Std.UniquePtr_Int32T._Underlying *b, MR.CS.Std.UniquePtr_Int32T._Underlying **c);
                MR.CS.Std.UniquePtr_Int32T._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_uniqueptr_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.UniquePtr_Int32T(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_uniqueptr_cptr`.
            /// Parameter `c` defaults to `&default_uniqueptr`.
            /// </summary>
            public static unsafe MR.CS.Std.Const_UniquePtr_Int32T? testUniqueptrCptr(MR.CS.Std.Const_UniquePtr_Int32T? a, MR.CS.Std.Const_UniquePtr_Int32T? b = null, MR.CS.Std._InOptConst_UniquePtr_Int32T? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_uniqueptr_cptr", ExactSpelling = true)]
                extern static MR.CS.Std.Const_UniquePtr_Int32T._Underlying *__MR_CSharp_test_uniqueptr_cptr(MR.CS.Std.Const_UniquePtr_Int32T._Underlying *a, MR.CS.Std.Const_UniquePtr_Int32T._Underlying *b, MR.CS.Std.Const_UniquePtr_Int32T._Underlying **c);
                MR.CS.Std.Const_UniquePtr_Int32T._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_uniqueptr_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Std.Const_UniquePtr_Int32T(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_ref`.
            /// Parameter `b` defaults to `default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ArrayInt32T42 testPlainarrRef(ref MR.CS.ArrayInt32T42 a, MR.CS.ArrayInt32T42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 *__MR_CSharp_test_plainarr_ref(MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 *b);
                fixed (MR.CS.ArrayInt32T42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_cref`.
            /// Parameter `b` defaults to `default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ConstArrayInt32T42 testPlainarrCref(ref MR.CS.ConstArrayInt32T42 a, MR.CS.ConstArrayInt32T42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 *__MR_CSharp_test_plainarr_cref(MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 *b);
                fixed (MR.CS.ConstArrayInt32T42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray&&)default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ArrayInt32T42 testPlainarrRref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ArrayInt32T42 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ArrayInt32T42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_rref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 *__MR_CSharp_test_plainarr_rref(MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 *b);
                fixed (MR.CS.ArrayInt32T42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_rref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray&&)default_plainarr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ConstArrayInt32T42 testPlainarrCrref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ConstArrayInt32T42 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ConstArrayInt32T42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_crref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 *__MR_CSharp_test_plainarr_crref(MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 *b);
                fixed (MR.CS.ConstArrayInt32T42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr_crref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_ptr`.
            /// Parameter `c` defaults to `&default_plainarr`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T42 *testPlainarrPtr(MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 *b = null, MR.CS.ArrayInt32T42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 *__MR_CSharp_test_plainarr_ptr(MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 *b, MR.CS.ArrayInt32T42 **c);
                return __MR_CSharp_test_plainarr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr_cptr`.
            /// Parameter `c` defaults to `&default_plainarr`.
            /// </summary>
            public static unsafe MR.CS.ConstArrayInt32T42 *testPlainarrCptr(MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 *b = null, MR.CS.ConstArrayInt32T42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 *__MR_CSharp_test_plainarr_cptr(MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 *b, MR.CS.ConstArrayInt32T42 **c);
                return __MR_CSharp_test_plainarr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_ref`.
            /// Parameter `b` defaults to `default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ArrayInt32T10_20 testPlainarr2Ref(ref MR.CS.ArrayInt32T10_20 a, MR.CS.ArrayInt32T10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T10_20 *__MR_CSharp_test_plainarr2_ref(MR.CS.ArrayInt32T10_20 *a, MR.CS.ArrayInt32T10_20 *b);
                fixed (MR.CS.ArrayInt32T10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_cref`.
            /// Parameter `b` defaults to `default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ConstArrayInt32T10_20 testPlainarr2Cref(ref MR.CS.ConstArrayInt32T10_20 a, MR.CS.ConstArrayInt32T10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T10_20 *__MR_CSharp_test_plainarr2_cref(MR.CS.ConstArrayInt32T10_20 *a, MR.CS.ConstArrayInt32T10_20 *b);
                fixed (MR.CS.ConstArrayInt32T10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_rref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray2&&)default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ArrayInt32T10_20 testPlainarr2Rref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ArrayInt32T10_20 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ArrayInt32T10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_rref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T10_20 *__MR_CSharp_test_plainarr2_rref(MR.CS.ArrayInt32T10_20 *a, MR.CS.ArrayInt32T10_20 *b);
                fixed (MR.CS.ArrayInt32T10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_rref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_crref`.
            /// Parameter `b` defaults to `(MR::CSharp::PlainArray2&&)default_plainarr2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ConstArrayInt32T10_20 testPlainarr2Crref(MR.CS.Misc._MoveRef _move_a, ref MR.CS.ConstArrayInt32T10_20 a, MR.CS.Misc._MoveRef _move_b = default, MR.CS.ConstArrayInt32T10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_crref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T10_20 *__MR_CSharp_test_plainarr2_crref(MR.CS.ConstArrayInt32T10_20 *a, MR.CS.ConstArrayInt32T10_20 *b);
                fixed (MR.CS.ConstArrayInt32T10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarr2_crref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_ptr`.
            /// Parameter `c` defaults to `&default_plainarr2`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T10_20 *testPlainarr2Ptr(MR.CS.ArrayInt32T10_20 *a, MR.CS.ArrayInt32T10_20 *b = null, MR.CS.ArrayInt32T10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T10_20 *__MR_CSharp_test_plainarr2_ptr(MR.CS.ArrayInt32T10_20 *a, MR.CS.ArrayInt32T10_20 *b, MR.CS.ArrayInt32T10_20 **c);
                return __MR_CSharp_test_plainarr2_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarr2_cptr`.
            /// Parameter `c` defaults to `&default_plainarr2`.
            /// </summary>
            public static unsafe MR.CS.ConstArrayInt32T10_20 *testPlainarr2Cptr(MR.CS.ConstArrayInt32T10_20 *a, MR.CS.ConstArrayInt32T10_20 *b = null, MR.CS.ConstArrayInt32T10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarr2_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T10_20 *__MR_CSharp_test_plainarr2_cptr(MR.CS.ConstArrayInt32T10_20 *a, MR.CS.ConstArrayInt32T10_20 *b, MR.CS.ConstArrayInt32T10_20 **c);
                return __MR_CSharp_test_plainarr2_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum_ref`.
            /// Parameter `b` defaults to `default_plainarrenum`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ArrayE1_42 testPlainarrenumRef(ref MR.CS.CSharp.ArrayE1_42 a, MR.CS.CSharp.ArrayE1_42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_42 *__MR_CSharp_test_plainarrenum_ref(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b);
                fixed (MR.CS.CSharp.ArrayE1_42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum_cref`.
            /// Parameter `b` defaults to `default_plainarrenum`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ConstArrayE1_42 testPlainarrenumCref(ref MR.CS.CSharp.ConstArrayE1_42 a, MR.CS.CSharp.ConstArrayE1_42 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_42 *__MR_CSharp_test_plainarrenum_cref(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b);
                fixed (MR.CS.CSharp.ConstArrayE1_42 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum_ptr`.
            /// Parameter `c` defaults to `&default_plainarrenum`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ArrayE1_42 *testPlainarrenumPtr(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b = null, MR.CS.CSharp.ArrayE1_42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_42 *__MR_CSharp_test_plainarrenum_ptr(MR.CS.CSharp.ArrayE1_42 *a, MR.CS.CSharp.ArrayE1_42 *b, MR.CS.CSharp.ArrayE1_42 **c);
                return __MR_CSharp_test_plainarrenum_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum_cptr`.
            /// Parameter `c` defaults to `&default_plainarrenum`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstArrayE1_42 *testPlainarrenumCptr(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b = null, MR.CS.CSharp.ConstArrayE1_42 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_42 *__MR_CSharp_test_plainarrenum_cptr(MR.CS.CSharp.ConstArrayE1_42 *a, MR.CS.CSharp.ConstArrayE1_42 *b, MR.CS.CSharp.ConstArrayE1_42 **c);
                return __MR_CSharp_test_plainarrenum_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum2_ref`.
            /// Parameter `b` defaults to `default_plainarrenum2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ArrayE1_10_20 testPlainarrenum2Ref(ref MR.CS.CSharp.ArrayE1_10_20 a, MR.CS.CSharp.ArrayE1_10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_ref(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b);
                fixed (MR.CS.CSharp.ArrayE1_10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum2_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum2_cref`.
            /// Parameter `b` defaults to `default_plainarrenum2`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.CSharp.ConstArrayE1_10_20 testPlainarrenum2Cref(ref MR.CS.CSharp.ConstArrayE1_10_20 a, MR.CS.CSharp.ConstArrayE1_10_20 *b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_cref", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_cref(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b);
                fixed (MR.CS.CSharp.ConstArrayE1_10_20 *__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_plainarrenum2_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum2_ptr`.
            /// Parameter `c` defaults to `&default_plainarrenum2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ArrayE1_10_20 *testPlainarrenum2Ptr(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b = null, MR.CS.CSharp.ArrayE1_10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_ptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_ptr(MR.CS.CSharp.ArrayE1_10_20 *a, MR.CS.CSharp.ArrayE1_10_20 *b, MR.CS.CSharp.ArrayE1_10_20 **c);
                return __MR_CSharp_test_plainarrenum2_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_plainarrenum2_cptr`.
            /// Parameter `c` defaults to `&default_plainarrenum2`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstArrayE1_10_20 *testPlainarrenum2Cptr(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b = null, MR.CS.CSharp.ConstArrayE1_10_20 **c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_plainarrenum2_cptr", ExactSpelling = true)]
                extern static MR.CS.CSharp.ConstArrayE1_10_20 *__MR_CSharp_test_plainarrenum2_cptr(MR.CS.CSharp.ConstArrayE1_10_20 *a, MR.CS.CSharp.ConstArrayE1_10_20 *b, MR.CS.CSharp.ConstArrayE1_10_20 **c);
                return __MR_CSharp_test_plainarrenum2_cptr(a, b, c);
            }

            // Some multi-level pointer madness:
            /// <summary>
            /// Generated from function `MR::CSharp::test_ptrs1`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T42 **testPtrs1(MR.CS.ArrayInt32T42 **ptr, ref MR.CS.ArrayInt32T42 *ref_)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ptrs1", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 **__MR_CSharp_test_ptrs1(MR.CS.ArrayInt32T42 **ptr, MR.CS.ArrayInt32T42 **ref_);
                fixed (MR.CS.ArrayInt32T42 **__ptr_ref_ = &ref_)
                {
                    return __MR_CSharp_test_ptrs1(ptr, __ptr_ref_);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_ptrs2`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T42 ***testPtrs2(MR.CS.ArrayInt32T42 ***ptr, ref MR.CS.ArrayInt32T42 **ref_)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_ptrs2", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 ***__MR_CSharp_test_ptrs2(MR.CS.ArrayInt32T42 ***ptr, MR.CS.ArrayInt32T42 ***ref_);
                fixed (MR.CS.ArrayInt32T42 ***__ptr_ref_ = &ref_)
                {
                    return __MR_CSharp_test_ptrs2(ptr, __ptr_ref_);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptr_ref`.
            /// Parameter `b` defaults to `default_intptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref int *testIntptrRef(ref int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_ref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_ref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptr_cref`.
            /// Parameter `b` defaults to `default_intptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly int *testIntptrCref(in int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_cref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_cref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptr_ptr`.
            /// Parameter `c` defaults to `&default_intptr`.
            /// </summary>
            public static unsafe int **testIntptrPtr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_ptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_ptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptr_cptr`.
            /// Parameter `c` defaults to `&default_intptr`.
            /// </summary>
            public static unsafe int **testIntptrCptr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptr_cptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intptr_cptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intcptr_ref`.
            /// Parameter `b` defaults to `default_intcptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref int *testIntcptrRef(ref int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_ref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_ref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intcptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intcptr_cref`.
            /// Parameter `b` defaults to `default_intcptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly int *testIntcptrCref(in int *a, int **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_cref", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_cref(int **a, int **b);
                fixed (int **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intcptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intcptr_ptr`.
            /// Parameter `c` defaults to `&default_intcptr`.
            /// </summary>
            public static unsafe int **testIntcptrPtr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_ptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_ptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intcptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intcptr_cptr`.
            /// Parameter `c` defaults to `&default_intcptr`.
            /// </summary>
            public static unsafe int **testIntcptrCptr(int **a, int **b = null, int ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intcptr_cptr", ExactSpelling = true)]
                extern static int **__MR_CSharp_test_intcptr_cptr(int **a, int **b, int ***c);
                return __MR_CSharp_test_intcptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptrptr_ref`.
            /// Parameter `b` defaults to `default_intptrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref int **testIntptrptrRef(ref int **a, int ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_ref", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_ref(int ***a, int ***b);
                fixed (int ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptrptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptrptr_cref`.
            /// Parameter `b` defaults to `default_intptrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly int **testIntptrptrCref(in int **a, int ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_cref", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_cref(int ***a, int ***b);
                fixed (int ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_intptrptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptrptr_ptr`.
            /// Parameter `c` defaults to `&default_intptrptr`.
            /// </summary>
            public static unsafe int ***testIntptrptrPtr(int ***a, int ***b = null, int ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_ptr", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_ptr(int ***a, int ***b, int ****c);
                return __MR_CSharp_test_intptrptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_intptrptr_cptr`.
            /// Parameter `c` defaults to `&default_intptrptr`.
            /// </summary>
            public static unsafe int ***testIntptrptrCptr(int ***a, int ***b = null, int ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_intptrptr_cptr", ExactSpelling = true)]
                extern static int ***__MR_CSharp_test_intptrptr_cptr(int ***a, int ***b, int ****c);
                return __MR_CSharp_test_intptrptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptr_ref`.
            /// Parameter `b` defaults to `default_voidptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref void *testVoidptrRef(ref void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_ref", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_ref(void **a, void **b);
                fixed (void **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptr_cref`.
            /// Parameter `b` defaults to `default_voidptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly void *testVoidptrCref(in void *a, void **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_cref", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_cref(void **a, void **b);
                fixed (void **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptr_ptr`.
            /// Parameter `c` defaults to `&default_voidptr`.
            /// </summary>
            public static unsafe void **testVoidptrPtr(void **a, void **b = null, void ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_ptr", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_ptr(void **a, void **b, void ***c);
                return __MR_CSharp_test_voidptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptr_cptr`.
            /// Parameter `c` defaults to `&default_voidptr`.
            /// </summary>
            public static unsafe void **testVoidptrCptr(void **a, void **b = null, void ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptr_cptr", ExactSpelling = true)]
                extern static void **__MR_CSharp_test_voidptr_cptr(void **a, void **b, void ***c);
                return __MR_CSharp_test_voidptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptrptr_ref`.
            /// Parameter `b` defaults to `default_voidptrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref void **testVoidptrptrRef(ref void **a, void ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_ref", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_ref(void ***a, void ***b);
                fixed (void ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptrptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptrptr_cref`.
            /// Parameter `b` defaults to `default_voidptrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly void **testVoidptrptrCref(in void **a, void ***b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_cref", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_cref(void ***a, void ***b);
                fixed (void ***__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_voidptrptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptrptr_ptr`.
            /// Parameter `c` defaults to `&default_voidptrptr`.
            /// </summary>
            public static unsafe void ***testVoidptrptrPtr(void ***a, void ***b = null, void ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_ptr", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_ptr(void ***a, void ***b, void ****c);
                return __MR_CSharp_test_voidptrptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_voidptrptr_cptr`.
            /// Parameter `c` defaults to `&default_voidptrptr`.
            /// </summary>
            public static unsafe void ***testVoidptrptrCptr(void ***a, void ***b = null, void ****c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_voidptrptr_cptr", ExactSpelling = true)]
                extern static void ***__MR_CSharp_test_voidptrptr_cptr(void ***a, void ***b, void ****c);
                return __MR_CSharp_test_voidptrptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrptr_ref`.
            /// Parameter `b` defaults to `default_arrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ArrayInt32T42 *testArrptrRef(ref MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_ref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 **__MR_CSharp_test_arrptr_ref(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b);
                fixed (MR.CS.ArrayInt32T42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrptr_cref`.
            /// Parameter `b` defaults to `default_arrptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly MR.CS.ArrayInt32T42 *testArrptrCref(in MR.CS.ArrayInt32T42 *a, MR.CS.ArrayInt32T42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_cref", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 **__MR_CSharp_test_arrptr_cref(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b);
                fixed (MR.CS.ArrayInt32T42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrptr_ptr`.
            /// Parameter `c` defaults to `&default_arrptr`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T42 **testArrptrPtr(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b = null, MR.CS.ArrayInt32T42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_ptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 **__MR_CSharp_test_arrptr_ptr(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b, MR.CS.ArrayInt32T42 ***c);
                return __MR_CSharp_test_arrptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrptr_cptr`.
            /// Parameter `c` defaults to `&default_arrptr`.
            /// </summary>
            public static unsafe MR.CS.ArrayInt32T42 **testArrptrCptr(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b = null, MR.CS.ArrayInt32T42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrptr_cptr", ExactSpelling = true)]
                extern static MR.CS.ArrayInt32T42 **__MR_CSharp_test_arrptr_cptr(MR.CS.ArrayInt32T42 **a, MR.CS.ArrayInt32T42 **b, MR.CS.ArrayInt32T42 ***c);
                return __MR_CSharp_test_arrptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrcptr_ref`.
            /// Parameter `b` defaults to `default_arrcptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref MR.CS.ConstArrayInt32T42 *testArrcptrRef(ref MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_ref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 **__MR_CSharp_test_arrcptr_ref(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b);
                fixed (MR.CS.ConstArrayInt32T42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrcptr_ref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrcptr_cref`.
            /// Parameter `b` defaults to `default_arrcptr`.
            /// In C++ this function returns an rvalue reference.
            /// </summary>
            public static unsafe ref readonly MR.CS.ConstArrayInt32T42 *testArrcptrCref(in MR.CS.ConstArrayInt32T42 *a, MR.CS.ConstArrayInt32T42 **b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_cref", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 **__MR_CSharp_test_arrcptr_cref(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b);
                fixed (MR.CS.ConstArrayInt32T42 **__ptr_a = &a)
                {
                    return ref *__MR_CSharp_test_arrcptr_cref(__ptr_a, b);
                }
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrcptr_ptr`.
            /// Parameter `c` defaults to `&default_arrcptr`.
            /// </summary>
            public static unsafe MR.CS.ConstArrayInt32T42 **testArrcptrPtr(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b = null, MR.CS.ConstArrayInt32T42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_ptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 **__MR_CSharp_test_arrcptr_ptr(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b, MR.CS.ConstArrayInt32T42 ***c);
                return __MR_CSharp_test_arrcptr_ptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_arrcptr_cptr`.
            /// Parameter `c` defaults to `&default_arrcptr`.
            /// </summary>
            public static unsafe MR.CS.ConstArrayInt32T42 **testArrcptrCptr(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b = null, MR.CS.ConstArrayInt32T42 ***c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_arrcptr_cptr", ExactSpelling = true)]
                extern static MR.CS.ConstArrayInt32T42 **__MR_CSharp_test_arrcptr_cptr(MR.CS.ConstArrayInt32T42 **a, MR.CS.ConstArrayInt32T42 **b, MR.CS.ConstArrayInt32T42 ***c);
                return __MR_CSharp_test_arrcptr_cptr(a, b, c);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::nameConflicts`.
            /// </summary>
            public static void nameConflicts()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_nameConflicts", ExactSpelling = true)]
                extern static void __MR_CSharp_nameConflicts();
                __MR_CSharp_nameConflicts();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::nameConflictsExposed`.
            /// </summary>
            public static void nameConflictsExposed()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_nameConflictsExposed", ExactSpelling = true)]
                extern static void __MR_CSharp_nameConflictsExposed();
                __MR_CSharp_nameConflictsExposed();
            }

            // Test how template arguments are added to function names when needed to avoid ambiguities.
            /// <summary>
            /// Generated from function `MR::CSharp::template_a<int32_t>`.
            /// </summary>
            public static void templateA(int _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_a_int32_t", ExactSpelling = true)]
                extern static void __MR_CSharp_template_a_int32_t(int _1);
                __MR_CSharp_template_a_int32_t(_1);
            }

            // Test how template arguments are added to function names when needed to avoid ambiguities.
            /// <summary>
            /// Generated from function `MR::CSharp::template_a<float>`.
            /// </summary>
            public static void templateA(float _1)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_a_float", ExactSpelling = true)]
                extern static void __MR_CSharp_template_a_float(float _1);
                __MR_CSharp_template_a_float(_1);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::template_b<int32_t>`.
            /// </summary>
            public static int templateB_Int32T()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_b_int32_t", ExactSpelling = true)]
                extern static int __MR_CSharp_template_b_int32_t();
                return __MR_CSharp_template_b_int32_t();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::template_b<float>`.
            /// </summary>
            public static float templateB_Float()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_b_float", ExactSpelling = true)]
                extern static float __MR_CSharp_template_b_float();
                return __MR_CSharp_template_b_float();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::template_c<int32_t>`.
            /// </summary>
            public static void templateC_Int32T()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_c_int32_t", ExactSpelling = true)]
                extern static void __MR_CSharp_template_c_int32_t();
                __MR_CSharp_template_c_int32_t();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::template_c<float>`.
            /// </summary>
            public static void templateC_Float()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_template_c_float", ExactSpelling = true)]
                extern static void __MR_CSharp_template_c_float();
                __MR_CSharp_template_c_float();
            }

            /// <summary>
            /// Generated from function `MR::CSharp::instantiate`.
            /// </summary>
            public static void instantiate()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_instantiate", ExactSpelling = true)]
                extern static void __MR_CSharp_instantiate();
                __MR_CSharp_instantiate();
            }

            // `--infer-lifetime-iterators` should act on those:
            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstPtrLifetimesA begin(MR.CS.CSharp.Const_LifetimesB b)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_const_MR_CSharp_LifetimesB_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_begin_const_MR_CSharp_LifetimesB_ref(MR.CS.CSharp.Const_LifetimesB._Underlying *b);
                var __c_ret = __MR_CSharp_begin_const_MR_CSharp_LifetimesB_ref(b._UnderlyingPtr);
                return new(__c_ret);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstPtrLifetimesA end(MR.CS.CSharp.Const_LifetimesB b)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_const_MR_CSharp_LifetimesB_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_end_const_MR_CSharp_LifetimesB_ref(MR.CS.CSharp.Const_LifetimesB._Underlying *b);
                var __c_ret = __MR_CSharp_end_const_MR_CSharp_LifetimesB_ref(b._UnderlyingPtr);
                return new(__c_ret);
            }

            // `--infer-lifetime-iterators` should act on those:
            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstPtrLifetimesA begin(MR.CS.CSharp.Const_LifetimesC c)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_const_MR_CSharp_LifetimesC_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_begin_const_MR_CSharp_LifetimesC_ref(MR.CS.CSharp.Const_LifetimesC._Underlying *c);
                var __c_ret = __MR_CSharp_begin_const_MR_CSharp_LifetimesC_ref(c._UnderlyingPtr);
                return new(__c_ret);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.CSharp.ConstPtrLifetimesA end(MR.CS.CSharp.Const_LifetimesC c)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_const_MR_CSharp_LifetimesC_ref", ExactSpelling = true)]
                extern static MR.CS.CSharp.Const_LifetimesA._Underlying *__MR_CSharp_end_const_MR_CSharp_LifetimesC_ref(MR.CS.CSharp.Const_LifetimesC._Underlying *c);
                var __c_ret = __MR_CSharp_end_const_MR_CSharp_LifetimesC_ref(c._UnderlyingPtr);
                return new(__c_ret);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T begin(MR.CS.CSharp.Const_IterableD self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_const_MR_CSharp_IterableD_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_begin_const_MR_CSharp_IterableD_ref(MR.CS.CSharp.Const_IterableD._Underlying *self);
                return new(__MR_CSharp_begin_const_MR_CSharp_IterableD_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T end(MR.CS.CSharp.Const_IterableD self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_const_MR_CSharp_IterableD_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_end_const_MR_CSharp_IterableD_ref(MR.CS.CSharp.Const_IterableD._Underlying *self);
                return new(__MR_CSharp_end_const_MR_CSharp_IterableD_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.PtrInt32T begin(MR.CS.CSharp.IterableE self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_MR_CSharp_IterableE_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_begin_MR_CSharp_IterableE_ref(MR.CS.CSharp.IterableE._Underlying *self);
                return new(__MR_CSharp_begin_MR_CSharp_IterableE_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.PtrInt32T end(MR.CS.CSharp.IterableE self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_MR_CSharp_IterableE_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_end_MR_CSharp_IterableE_ref(MR.CS.CSharp.IterableE._Underlying *self);
                return new(__MR_CSharp_end_MR_CSharp_IterableE_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T begin(MR.CS.CSharp.Const_IterableF self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_const_MR_CSharp_IterableF_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_begin_const_MR_CSharp_IterableF_ref(MR.CS.CSharp.Const_IterableF._Underlying *self);
                return new(__MR_CSharp_begin_const_MR_CSharp_IterableF_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T end(MR.CS.CSharp.Const_IterableF self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_const_MR_CSharp_IterableF_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_end_const_MR_CSharp_IterableF_ref(MR.CS.CSharp.Const_IterableF._Underlying *self);
                return new(__MR_CSharp_end_const_MR_CSharp_IterableF_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::begin`.
            /// </summary>
            public static unsafe MR.CS.PtrInt32T begin(MR.CS.CSharp.IterableF self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_MR_CSharp_IterableF_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_begin_MR_CSharp_IterableF_ref(MR.CS.CSharp.IterableF._Underlying *self);
                return new(__MR_CSharp_begin_MR_CSharp_IterableF_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end`.
            /// </summary>
            public static unsafe MR.CS.PtrInt32T end(MR.CS.CSharp.IterableF self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_MR_CSharp_IterableF_ref", ExactSpelling = true)]
                extern static int *__MR_CSharp_end_MR_CSharp_IterableF_ref(MR.CS.CSharp.IterableF._Underlying *self);
                return new(__MR_CSharp_end_MR_CSharp_IterableF_ref(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::begin<int32_t>`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T begin(MR.CS.CSharp.Const_IterableL_Int32T self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_begin_int32_t", ExactSpelling = true)]
                extern static int *__MR_CSharp_begin_int32_t(MR.CS.CSharp.Const_IterableL_Int32T._Underlying *self);
                return new(__MR_CSharp_begin_int32_t(self._UnderlyingPtr));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::end<int32_t>`.
            /// </summary>
            public static unsafe MR.CS.ConstPtrInt32T end(MR.CS.CSharp.Const_IterableL_Int32T self)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_end_int32_t", ExactSpelling = true)]
                extern static int *__MR_CSharp_end_int32_t(MR.CS.CSharp.Const_IterableL_Int32T._Underlying *self);
                return new(__MR_CSharp_end_int32_t(self._UnderlyingPtr));
            }

            // Vectors of pointers to a class.
            // Currently `IEnumerable` is disabled for those, it needs to be fixed.
            /// <summary>
            /// Generated from function `MR::CSharp::test_vec_of_mut_ptr_to_class`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Vector_MRCSharpAPtr> testVecOfMutPtrToClass()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_vec_of_mut_ptr_to_class", ExactSpelling = true)]
                extern static MR.CS.Std.Vector_MRCSharpAPtr._Underlying *__MR_CSharp_test_vec_of_mut_ptr_to_class();
                return MR.CS.Misc.Move(new MR.CS.Std.Vector_MRCSharpAPtr(__MR_CSharp_test_vec_of_mut_ptr_to_class(), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_vec_of_const_ptr_to_class`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Vector_ConstMRCSharpAPtr> testVecOfConstPtrToClass()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_vec_of_const_ptr_to_class", ExactSpelling = true)]
                extern static MR.CS.Std.Vector_ConstMRCSharpAPtr._Underlying *__MR_CSharp_test_vec_of_const_ptr_to_class();
                return MR.CS.Misc.Move(new MR.CS.Std.Vector_ConstMRCSharpAPtr(__MR_CSharp_test_vec_of_const_ptr_to_class(), is_owning: true));
            }

            // Test decomposition for certain whitelisted standard tuple-like types: (tuples and pairs)
            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple0`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple getTuple0()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple0", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple._Underlying *__MR_CSharp_get_tuple0();
                return new(__MR_CSharp_get_tuple0(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple1`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_Int32T getTuple1()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple1", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_Int32T._Underlying *__MR_CSharp_get_tuple1();
                return new(__MR_CSharp_get_tuple1(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple2`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Tuple_Int32T_StdString> getTuple2()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple2", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_Int32T_StdString._Underlying *__MR_CSharp_get_tuple2();
                return MR.CS.Misc.Move(new MR.CS.Std.Tuple_Int32T_StdString(__MR_CSharp_get_tuple2(), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_pair2`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Pair_Int32T_StdString> getPair2()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_pair2", ExactSpelling = true)]
                extern static MR.CS.Std.Pair_Int32T_StdString._Underlying *__MR_CSharp_get_pair2();
                return MR.CS.Misc.Move(new MR.CS.Std.Pair_Int32T_StdString(__MR_CSharp_get_pair2(), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_const`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Std.Tuple_ConstInt32T_StdString> getTupleConst()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_const", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_ConstInt32T_StdString._Underlying *__MR_CSharp_get_tuple_const();
                return MR.CS.Misc.Move(new MR.CS.Std.Tuple_ConstInt32T_StdString(__MR_CSharp_get_tuple_const(), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_refs`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_Int32TRef_FloatRvalueRef_StdStringRef_StdStringRvalueRef getTupleRefs()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_refs", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_Int32TRef_FloatRvalueRef_StdStringRef_StdStringRvalueRef._Underlying *__MR_CSharp_get_tuple_refs();
                return new(__MR_CSharp_get_tuple_refs(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_crefs`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_ConstInt32TRef_ConstFloatRvalueRef_ConstStdStringRef_ConstStdStringRvalueRef getTupleCrefs()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_crefs", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_ConstInt32TRef_ConstFloatRvalueRef_ConstStdStringRef_ConstStdStringRvalueRef._Underlying *__MR_CSharp_get_tuple_crefs();
                return new(__MR_CSharp_get_tuple_crefs(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_exposed_value`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_MRCSharpExposedLayout_ConstMRCSharpExposedLayout getTupleExposedValue()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_exposed_value", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_MRCSharpExposedLayout_ConstMRCSharpExposedLayout._Underlying *__MR_CSharp_get_tuple_exposed_value();
                return new(__MR_CSharp_get_tuple_exposed_value(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_exposed_lvalue_ref`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_MRCSharpExposedLayoutRef_ConstMRCSharpExposedLayoutRef getTupleExposedLvalueRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_exposed_lvalue_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_MRCSharpExposedLayoutRef_ConstMRCSharpExposedLayoutRef._Underlying *__MR_CSharp_get_tuple_exposed_lvalue_ref();
                return new(__MR_CSharp_get_tuple_exposed_lvalue_ref(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::get_tuple_exposed_rvalue_ref`.
            /// </summary>
            public static unsafe MR.CS.Std.Tuple_MRCSharpExposedLayoutRvalueRef_ConstMRCSharpExposedLayoutRvalueRef getTupleExposedRvalueRef()
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_get_tuple_exposed_rvalue_ref", ExactSpelling = true)]
                extern static MR.CS.Std.Tuple_MRCSharpExposedLayoutRvalueRef_ConstMRCSharpExposedLayoutRvalueRef._Underlying *__MR_CSharp_get_tuple_exposed_rvalue_ref();
                return new(__MR_CSharp_get_tuple_exposed_rvalue_ref(), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_int`.
            /// Parameter `b` defaults to `expected<int, float>{42}`.
            /// </summary>
            public static unsafe MR.CS.Expected_Int32T_Float testExpectedInt(MR.CS.Const_Expected_Int32T_Float a, MR.CS.Const_Expected_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int", ExactSpelling = true)]
                extern static MR.CS.Expected_Int32T_Float._Underlying *__MR_CSharp_test_expected_int(MR.CS.Expected_Int32T_Float._Underlying *a, MR.CS.Expected_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_int_ref`.
            /// Parameter `b` defaults to `default_expected_int`.
            /// </summary>
            public static unsafe MR.CS.Expected_Int32T_Float testExpectedIntRef(MR.CS.Expected_Int32T_Float a, MR.CS.Expected_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_Int32T_Float._Underlying *__MR_CSharp_test_expected_int_ref(MR.CS.Expected_Int32T_Float._Underlying *a, MR.CS.Expected_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_int_cref`.
            /// Parameter `b` defaults to `default_expected_int`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_Int32T_Float testExpectedIntCref(MR.CS.Const_Expected_Int32T_Float a, MR.CS.Const_Expected_Int32T_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_Int32T_Float._Underlying *__MR_CSharp_test_expected_int_cref(MR.CS.Const_Expected_Int32T_Float._Underlying *a, MR.CS.Const_Expected_Int32T_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_int_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_int_ptr`.
            /// Parameter `c` defaults to `&default_expected_int`.
            /// </summary>
            public static unsafe MR.CS.Expected_Int32T_Float? testExpectedIntPtr(MR.CS.Expected_Int32T_Float? a, MR.CS.Expected_Int32T_Float? b = null, MR.CS._InOptMut_Expected_Int32T_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_Int32T_Float._Underlying *__MR_CSharp_test_expected_int_ptr(MR.CS.Expected_Int32T_Float._Underlying *a, MR.CS.Expected_Int32T_Float._Underlying *b, MR.CS.Expected_Int32T_Float._Underlying **c);
                MR.CS.Expected_Int32T_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_int_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_Int32T_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_int_cptr`.
            /// Parameter `c` defaults to `&default_expected_int`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_Int32T_Float? testExpectedIntCptr(MR.CS.Const_Expected_Int32T_Float? a, MR.CS.Const_Expected_Int32T_Float? b = null, MR.CS._InOptConst_Expected_Int32T_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_int_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_Int32T_Float._Underlying *__MR_CSharp_test_expected_int_cptr(MR.CS.Const_Expected_Int32T_Float._Underlying *a, MR.CS.Const_Expected_Int32T_Float._Underlying *b, MR.CS.Const_Expected_Int32T_Float._Underlying **c);
                MR.CS.Const_Expected_Int32T_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_int_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_Int32T_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_void`.
            /// Parameter `b` defaults to `expected<void, float>{}`.
            /// </summary>
            public static unsafe MR.CS.Expected_Void_Float testExpectedVoid(MR.CS.Const_Expected_Void_Float a, MR.CS.Const_Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void", ExactSpelling = true)]
                extern static MR.CS.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void(MR.CS.Expected_Void_Float._Underlying *a, MR.CS.Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_void_ref`.
            /// Parameter `b` defaults to `default_expected_void`.
            /// </summary>
            public static unsafe MR.CS.Expected_Void_Float testExpectedVoidRef(MR.CS.Expected_Void_Float a, MR.CS.Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_ref(MR.CS.Expected_Void_Float._Underlying *a, MR.CS.Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_void_cref`.
            /// Parameter `b` defaults to `default_expected_void`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_Void_Float testExpectedVoidCref(MR.CS.Const_Expected_Void_Float a, MR.CS.Const_Expected_Void_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_cref(MR.CS.Const_Expected_Void_Float._Underlying *a, MR.CS.Const_Expected_Void_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_void_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_void_ptr`.
            /// Parameter `c` defaults to `&default_expected_void`.
            /// </summary>
            public static unsafe MR.CS.Expected_Void_Float? testExpectedVoidPtr(MR.CS.Expected_Void_Float? a, MR.CS.Expected_Void_Float? b = null, MR.CS._InOptMut_Expected_Void_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_ptr(MR.CS.Expected_Void_Float._Underlying *a, MR.CS.Expected_Void_Float._Underlying *b, MR.CS.Expected_Void_Float._Underlying **c);
                MR.CS.Expected_Void_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_void_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_Void_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_void_cptr`.
            /// Parameter `c` defaults to `&default_expected_void`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_Void_Float? testExpectedVoidCptr(MR.CS.Const_Expected_Void_Float? a, MR.CS.Const_Expected_Void_Float? b = null, MR.CS._InOptConst_Expected_Void_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_void_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_Void_Float._Underlying *__MR_CSharp_test_expected_void_cptr(MR.CS.Const_Expected_Void_Float._Underlying *a, MR.CS.Const_Expected_Void_Float._Underlying *b, MR.CS.Const_Expected_Void_Float._Underlying **c);
                MR.CS.Const_Expected_Void_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_void_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_Void_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_enum`.
            /// Parameter `b` defaults to `expected<MR::CSharp::E1, float>{E1::b}`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpE1_Float testExpectedEnum(MR.CS.Const_Expected_MRCSharpE1_Float a, MR.CS.Const_Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum(MR.CS.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_enum_ref`.
            /// Parameter `b` defaults to `default_expected_enum`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpE1_Float testExpectedEnumRef(MR.CS.Expected_MRCSharpE1_Float a, MR.CS.Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_ref(MR.CS.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_enum_cref`.
            /// Parameter `b` defaults to `default_expected_enum`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpE1_Float testExpectedEnumCref(MR.CS.Const_Expected_MRCSharpE1_Float a, MR.CS.Const_Expected_MRCSharpE1_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_cref(MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_enum_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_enum_ptr`.
            /// Parameter `c` defaults to `&default_expected_enum`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpE1_Float? testExpectedEnumPtr(MR.CS.Expected_MRCSharpE1_Float? a, MR.CS.Expected_MRCSharpE1_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpE1_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_ptr(MR.CS.Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Expected_MRCSharpE1_Float._Underlying *b, MR.CS.Expected_MRCSharpE1_Float._Underlying **c);
                MR.CS.Expected_MRCSharpE1_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_enum_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpE1_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_enum_cptr`.
            /// Parameter `c` defaults to `&default_expected_enum`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpE1_Float? testExpectedEnumCptr(MR.CS.Const_Expected_MRCSharpE1_Float? a, MR.CS.Const_Expected_MRCSharpE1_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpE1_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_enum_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *__MR_CSharp_test_expected_enum_cptr(MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpE1_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpE1_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_enum_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpE1_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_triv`.
            /// Parameter `b` defaults to `expected<MR::CSharp::Trivial, float>{MR::CSharp::Trivial{}}`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpTrivial_Float testExpectedTriv(MR.CS.Const_Expected_MRCSharpTrivial_Float a, MR.CS.Const_Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv(MR.CS.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_triv_ref`.
            /// Parameter `b` defaults to `default_expected_triv`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpTrivial_Float testExpectedTrivRef(MR.CS.Expected_MRCSharpTrivial_Float a, MR.CS.Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_ref(MR.CS.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_triv_cref`.
            /// Parameter `b` defaults to `default_expected_triv`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpTrivial_Float testExpectedTrivCref(MR.CS.Const_Expected_MRCSharpTrivial_Float a, MR.CS.Const_Expected_MRCSharpTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_cref(MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_triv_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_triv_ptr`.
            /// Parameter `c` defaults to `&default_expected_triv`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpTrivial_Float? testExpectedTrivPtr(MR.CS.Expected_MRCSharpTrivial_Float? a, MR.CS.Expected_MRCSharpTrivial_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_ptr(MR.CS.Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Expected_MRCSharpTrivial_Float._Underlying *b, MR.CS.Expected_MRCSharpTrivial_Float._Underlying **c);
                MR.CS.Expected_MRCSharpTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_triv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpTrivial_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_triv_cptr`.
            /// Parameter `c` defaults to `&default_expected_triv`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpTrivial_Float? testExpectedTrivCptr(MR.CS.Const_Expected_MRCSharpTrivial_Float? a, MR.CS.Const_Expected_MRCSharpTrivial_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_triv_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *__MR_CSharp_test_expected_triv_cptr(MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_triv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpTrivial_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_nontriv`.
            /// Parameter `b` defaults to `expected<MR::CSharp::NonTrivial, float>{MR::CSharp::NonTrivial{}}`.
            /// </summary>
            public static unsafe MR.CS.Misc._Moved<MR.CS.Expected_MRCSharpNonTrivial_Float> testExpectedNontriv(MR.CS._ByValue_Expected_MRCSharpNonTrivial_Float a, MR.CS._ByValue_Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv(MR.CS.Misc._PassBy a_pass_by, MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Misc._PassBy b_pass_by, MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return MR.CS.Misc.Move(new MR.CS.Expected_MRCSharpNonTrivial_Float(__MR_CSharp_test_expected_nontriv(a.PassByMode, a.Value is not null ? a.Value._UnderlyingPtr : null, b is not null ? b.PassByMode : MR.CS.Misc._PassBy.default_arg, b is not null && b.Value is not null ? b.Value._UnderlyingPtr : null), is_owning: true));
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_nontriv_ref`.
            /// Parameter `b` defaults to `default_expected_nontriv`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpNonTrivial_Float testExpectedNontrivRef(MR.CS.Expected_MRCSharpNonTrivial_Float a, MR.CS.Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_ref(MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_nontriv_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_nontriv_cref`.
            /// Parameter `b` defaults to `default_expected_nontriv`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpNonTrivial_Float testExpectedNontrivCref(MR.CS.Const_Expected_MRCSharpNonTrivial_Float a, MR.CS.Const_Expected_MRCSharpNonTrivial_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_cref(MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_nontriv_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_nontriv_ptr`.
            /// Parameter `c` defaults to `&default_expected_nontriv`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpNonTrivial_Float? testExpectedNontrivPtr(MR.CS.Expected_MRCSharpNonTrivial_Float? a, MR.CS.Expected_MRCSharpNonTrivial_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpNonTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_ptr(MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *b, MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying **c);
                MR.CS.Expected_MRCSharpNonTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_nontriv_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpNonTrivial_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_nontriv_cptr`.
            /// Parameter `c` defaults to `&default_expected_nontriv`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpNonTrivial_Float? testExpectedNontrivCptr(MR.CS.Const_Expected_MRCSharpNonTrivial_Float? a, MR.CS.Const_Expected_MRCSharpNonTrivial_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpNonTrivial_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_nontriv_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__MR_CSharp_test_expected_nontriv_cptr(MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpNonTrivial_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_nontriv_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpNonTrivial_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_shared`.
            /// Parameter `b` defaults to `expected<MR::CSharp::SA, float>{MR::CSharp::SA{}}`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpSA_Float testExpectedShared(MR.CS.Const_Expected_MRCSharpSA_Float a, MR.CS.Const_Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared(MR.CS.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_shared_ref`.
            /// Parameter `b` defaults to `default_expected_shared`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpSA_Float testExpectedSharedRef(MR.CS.Expected_MRCSharpSA_Float a, MR.CS.Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_ref(MR.CS.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_shared_cref`.
            /// Parameter `b` defaults to `default_expected_shared`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpSA_Float testExpectedSharedCref(MR.CS.Const_Expected_MRCSharpSA_Float a, MR.CS.Const_Expected_MRCSharpSA_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_cref(MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_shared_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_shared_ptr`.
            /// Parameter `c` defaults to `&default_expected_shared`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpSA_Float? testExpectedSharedPtr(MR.CS.Expected_MRCSharpSA_Float? a, MR.CS.Expected_MRCSharpSA_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpSA_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_ptr(MR.CS.Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Expected_MRCSharpSA_Float._Underlying *b, MR.CS.Expected_MRCSharpSA_Float._Underlying **c);
                MR.CS.Expected_MRCSharpSA_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_shared_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpSA_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_shared_cptr`.
            /// Parameter `c` defaults to `&default_expected_shared`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpSA_Float? testExpectedSharedCptr(MR.CS.Const_Expected_MRCSharpSA_Float? a, MR.CS.Const_Expected_MRCSharpSA_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpSA_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_shared_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *__MR_CSharp_test_expected_shared_cptr(MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpSA_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpSA_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_shared_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpSA_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed`.
            /// Parameter `b` defaults to `expected<MR::CSharp::ExposedLayout, float>{MR::CSharp::ExposedLayout{}}`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayout_Float testExpectedExposed(MR.CS.Const_Expected_MRCSharpExposedLayout_Float a, MR.CS.Const_Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed(MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_ref`.
            /// Parameter `b` defaults to `default_expected_exposed`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayout_Float testExpectedExposedRef(MR.CS.Expected_MRCSharpExposedLayout_Float a, MR.CS.Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_ref(MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_cref`.
            /// Parameter `b` defaults to `default_expected_exposed`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpExposedLayout_Float testExpectedExposedCref(MR.CS.Const_Expected_MRCSharpExposedLayout_Float a, MR.CS.Const_Expected_MRCSharpExposedLayout_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_cref(MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_ptr`.
            /// Parameter `c` defaults to `&default_expected_exposed`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayout_Float? testExpectedExposedPtr(MR.CS.Expected_MRCSharpExposedLayout_Float? a, MR.CS.Expected_MRCSharpExposedLayout_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpExposedLayout_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_ptr(MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *b, MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying **c);
                MR.CS.Expected_MRCSharpExposedLayout_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_exposed_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpExposedLayout_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_cptr`.
            /// Parameter `c` defaults to `&default_expected_exposed`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpExposedLayout_Float? testExpectedExposedCptr(MR.CS.Const_Expected_MRCSharpExposedLayout_Float? a, MR.CS.Const_Expected_MRCSharpExposedLayout_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpExposedLayout_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__MR_CSharp_test_expected_exposed_cptr(MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpExposedLayout_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_exposed_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpExposedLayout_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_shared`.
            /// Parameter `b` defaults to `expected<MR::CSharp::ExposedLayoutSh, float>{MR::CSharp::ExposedLayoutSh{}}`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedShared(MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared(MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: true);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_shared_ref`.
            /// Parameter `b` defaults to `default_expected_exposed_shared`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedSharedRef(MR.CS.Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_ref", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_ref(MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared_ref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_shared_cref`.
            /// Parameter `b` defaults to `default_expected_exposed_shared`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float testExpectedExposedSharedCref(MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float a, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_cref", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_cref(MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *b);
                return new(__MR_CSharp_test_expected_exposed_shared_cref(a._UnderlyingPtr, b is not null ? b._UnderlyingPtr : null), is_owning: false);
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_shared_ptr`.
            /// Parameter `c` defaults to `&default_expected_exposed_shared`.
            /// </summary>
            public static unsafe MR.CS.Expected_MRCSharpExposedLayoutSh_Float? testExpectedExposedSharedPtr(MR.CS.Expected_MRCSharpExposedLayoutSh_Float? a, MR.CS.Expected_MRCSharpExposedLayoutSh_Float? b = null, MR.CS._InOptMut_Expected_MRCSharpExposedLayoutSh_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_ptr", ExactSpelling = true)]
                extern static MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_ptr(MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *b, MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying **c);
                MR.CS.Expected_MRCSharpExposedLayoutSh_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_exposed_shared_ptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Expected_MRCSharpExposedLayoutSh_Float(__c_ret, is_owning: false) : null;
            }

            /// <summary>
            /// Generated from function `MR::CSharp::test_expected_exposed_shared_cptr`.
            /// Parameter `c` defaults to `&default_expected_exposed_shared`.
            /// </summary>
            public static unsafe MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float? testExpectedExposedSharedCptr(MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float? a, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float? b = null, MR.CS._InOptConst_Expected_MRCSharpExposedLayoutSh_Float? c = null)
            {
                [System.Runtime.InteropServices.DllImport("bleh", EntryPoint = "MR_CSharp_test_expected_exposed_shared_cptr", ExactSpelling = true)]
                extern static MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__MR_CSharp_test_expected_exposed_shared_cptr(MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *a, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *b, MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying **c);
                MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float._Underlying *__ptr_c = c is not null && c.Opt is not null ? c.Opt._UnderlyingPtr : null;
                var __c_ret = __MR_CSharp_test_expected_exposed_shared_cptr(a is not null ? a._UnderlyingPtr : null, b is not null ? b._UnderlyingPtr : null, c is not null ? &__ptr_c : null);
                return __c_ret is not null ? new MR.CS.Const_Expected_MRCSharpExposedLayoutSh_Float(__c_ret, is_owning: false) : null;
            }
        }
    }
}

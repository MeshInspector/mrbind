# Generating C bindings

The C bindings are generated by a separate executable (`build/mrbind_gen_c`). It consumes the [parser output JSON](/docs/running_parser.md) and generates the C code, which you are then free to compile with any compiler.

## Running the generator

The minimal generation invocation looks like this:

```sh
mrbind_gen_c \
    --input parse_result.json \
    --output-header-dir output/include \
    --output-source-dir output/src \
    --helper-name-prefix MyLib_ \
    --map-path path/to/input/headers . \
    --assume-include-dir path/to/input
```

Let's go over the options. You can find more detailed descriptions in `mrbind_gen_c --help`.
* **`--input __.json`** is the input JSON as [produced by the parser](/docs/running_parser.md) (`mrbind`).
* **`--output-header-dir __` `--output-source-dir __`**** are the output directories for the headers and source files respectively.

  The default behavior is to error if those aren't empty. Pass `--clean-output-dirs` to automatically delete all contents before generation.

* **`--helper-name-prefix MyLib_`** sets the name prefix for certain generated functions/types/etc. This can be anything, but ideally you should pass your C++ namespace name followed by `_`.

  This isn't used for everything. The parsed names from the input will be prefixed with their C++ namespace names regardless of this flag. This prefix is used primarly for additional helper functions that we sometimes generate.

  This prefix is also used for macros by default. If you want a different prefix for macros (e.g. because this one isn't in all caps), pass it to `--helper-macro-name-prefix MYLIB_`.

* **`--map-path IN OUT`** controls the output directory hierarchy. Can be passed multiple times.

  For each input C++ header, we generate the respective output C header with the same name, and a C source file with the same name. (This only happens for headers that didn't have their contents filtered out by the parser's `--ignore`, so you don't need to worry about the standard library or third-party library headers.)

  Every such input C++ header must be located in one of the `IN` directories (this flag can be used several times to specify several directories). `IN` can be absolute or relative, it's made absolute internally anyway.

  `OUT` must always be relative. It's treated as relative to `--output-header-dir`/`--output-source-dir`.

  For example, if your input headers are `a/b/c/d/1.hpp`, `a/b/c/d/2.hpp`, and the output directories are `--output-header-dir include --output-source-dir src`, then:

  * `--map-path a/b .` would generate `include/c/d/1.h`, `include/c/d/2.h` and `src/c/d/1.c`, `src/c/d/2.c`.

  * `--map-path a/b foo/bar` would generate `include/foo/bar/c/d/1.h`, `include/foo/bar/c/d/2.h` and `src/foo/bar/c/d/1.c`, `src/foo/bar/c/d/2.c`.

  * `--map-path a/b/c .` would generate `include/d/1.h`, `include/d/2.h` and `src/d/1.c`, `src/d/2.c`, and so on.

* **`--assume-include-dir IN`** specifies which directories will be given to the compiler as include directories (via `-I...`).

  It's similar to `--map-path` in that it can be used multiple times, and every input C++ header must be one of the `IN` directories.

  For example, if your input headers are `a/b/c/d/1.hpp`, `a/b/c/d/2.hpp`, then `--assume-include-dir a/b` would cause the generator to use `#include <c/d/1.hpp>`, `#include <c/d/2.hpp>` to include those headers.

  NOTE: If your input headers use the `.h` extension, they can end up conflicting with the output `.h` headers with same names. To avoid this, don't pass directories that directly contain input headers, and instead pass their parents.

  For example, if your input header is named `a/b/c/d/1.h`, then don't pass `--assume-include-dir a/b/c/d`, and instead pass `a/b/c` or `a/b` or `a`.

  If you pass `--assume-include-dir a/b/c/d`, then the following will happen. The generated `1.c` will contain:

  ```c
  #include "1.h" // Include the generated C header `1.h`.
  #include <1.h> // Include the parsed C++ input header `1.h`.
  ```
  At least one of those will resolve incorrectly. (Since neither of those headers will be in the same directory as `1.c`.)

  And if you instead pass `--assume-include-dir a/b/c`, then you'll get:
  ```c
  #include "1.h"
  #include <d/1.h>
  ```
  Which is unambiguous, assuming you correctly set your include paths.

## Ignoring problematic parts of the code

If the generation fails because of certain problematic functions/types/etc, [exclude them from the bindings](/docs/skipping_entities.md).

## Completeness

Unlike Python, if C bindings generate and then compile successfully, you can be fairly sure that nothing is missing and they'll work correctly.

## Compiling the generated code

On success, the directories passed to `--output-header-dir`, `--output-source-dir` will contain the resulting C code, which you can compile with your preferred compiler, usually into a library.

You need at least following compiler flags:

* Add both `--output-header-dir` and `--output-source-dir` to the include search paths.

* Add your input C++ headers to the include search paths. Use the same directories you passed to `--assume-include-dir`.

* If you're compiling a shared library, define `MyLib_BUILD_LIBRARY`. This only matters on Windows, to enable `__declspec(dllexport)` for your functions.

  This macro is checked in `exports.h`, which is one of the generated headers.

  The `MyLib_` prefix is what you passe d to `--helper-macro-name-prefix` or `--helper-name-prefix`.

## Tuning the generated bindings

All flags beflow are for `mrbind_gen_c`, unless mentioned otherwise.

### File name length limit

Some generated headers can end up with long filenames (e.g. if you bind `std::tuple` with a 100 members). To set a limit on filename length, use `--max-header-name-length N` (e.g. with `N`=`100`). Longer filenames will get truncated, and hashes will be appended to those names to make them unique.

### Expose simple structs as structs

The default behavior is to expose all classes/structs as opaque heap-allocated pointers.

If you have sufficiently simple structs, you can opt into exposing them as plain C structs instead. The prime candidates for this are `struct Vec3 {float x,y,z;};` and such.

To do this, pass your struct name to `--expose-as-struct ...`. Use this flag multiple times to expose multiple structs. Invalid names are silently ignored.

The struct must be trivial enough: [trivially-copyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable), [standard-layout](https://en.cppreference.com/w/cpp/language/classes.html#Standard-layout_class), all members are public, no base classes. The members must have built-in types, or must themselves be structs passed to `--expose-as-struct` (so e.g. `struct Mat3 {Vec3 x,y,z;};` can be exposed correctly). If those requirements aren't satisfied, the generator will complain.

The specified name needs to be fully qualified (with all namespaces), and include all template arguments, e.g. `--expose-as-struct 'MyLibrary::Vector3<int>'`. (The `'...'` quotes are not a part of the syntax, use quotes appropriate for your shell if needed.)

You can expose several classes via a regex, e.g. to expose `Foo::Bar<T>` for any `T`, you could do `--expose-as-struct '/Foo::Bar<.*>/'`. (Again,  the `'...'` are your shell's quotes, while `/.../` is a part of the syntax, to indicate that this is a regex.)

### Make generated headers include each other

The generated headers are shy about including each other, preferring forward declarations when possible. The end result is that the end user will often have to include many ancillary headers (e.g. if a function returns `std::string` and you want to interact with its return value, you need to manually include the header with the binding for `std::string` too).

`--add-convenience-includes` fixes this. It's not enabled by default because it can be too eager with the includes, slowing down the user builds (though it adds a macro that lets users opt out of the extra includes).

### Don't generate elementwise constructors for large structs

When a C++ struct is an aggregate (i.e. has no constructors, and in C++ can be initialized with a list of its members in braces), we try to generate a C function for it that acts as a constructor, with a parameter for every member.

This can get out of hand with huge structs. Use `--preferred-max-num-aggregate-init-fields N` (with e.g. `N`=`20`) to not generate those functions for structs with more than `N` members.

This flag is ignored for non-default-constructible structs, as this could make them impossible to construct.

### Using fixed-size typedefs

Passing `--canonicalize-to-fixed-size-typedefs` will use `int32_t` and other similar standard typedefs instead of all built-in integer types.

This is purely a style choice, and doesn't help portability. For portability, see [this](#making-the-bindings-cross-platform).

## Making the bindings cross-platform

If you don't go out of your way, by default the bindings will be usable only on the platform you've generated them on.

But with some care, it's possible to make them fully consistent across platforms. After following those steps, it's *your* job to compare the results from Windows, Linux and Mac, to make sure they're all the same. Each of those platforms has some unique differences that can affect the output if not addressed.

First the simple things:

### Underlying types of enums

On Windows, the underlying type of plain `enum`s defaults to `int`, while on Linux it's either `int` or `unsigned int` depending on whether there are negative constants or not. This underlying type shows up in the generated C headers.

This only affects the plain `enum`, not `enum class`, which is specified by the C++ standard to default to the `int` type.

The fix is to pass `--implicit-enum-underlying-type-is-always-int` to the **parser**. This will make it report the default type as `int`, regardless of what it actually is.

So far this hasn't caused any breakage for us.

### `std::expected` vs `tl::expected`

If you switch between `std::expected` and `tl::expected` on different platforms, depending on what's available, this is for you.

Pass `--merge-std-and-tl-expected` to the **generator** to remove the namespaces from both, calling both just `expected`.

This purely renames things in the output, and shouldn't cause any breakage.

### `size_t` and other standard typedefs

This is the biggest source of problems and differences between platforms.

The problem:

* MRBind expands the typedefs when generating C. So among other things, it's going to expand `std::size_t`, `std::int64_t`, etc.

* On different platforms those typedefs expand to different types, causing inconsistency: `long` vs `long long`, etc.

The fix currently only makes the bindings portable between 64-bit platforms. 32-bit ones would need a separate set of C sources and headers generated for them.

Here is the TL;DR of the fix. The rationale is discussed after.

* **In any API you bind, there are restrictions on what 64-bit integer types you can use:**

  * **Bad:** `[unsigned] long` and `[unsigned] long long`

  * **Good:** `std::size_t`, `std::ptrdiff_t`, `std::intptr_t`, `std::uintptr_t`

  * **Bad:** `std::int64_t`, `std::uint64_t`

  * **Bad:** any of `std::[u]int_fastXX_t` and `std::[u]int_leastXX_t`

  Those errors should be caught by the generator automatically, if you enable certain flags mentioned below *and* test on all of: Windows, Linux, Mac, then at least one platform will catch this.

  So if you can't use `std::[u]int64_t`, then what do you use in its place? You make your own typedef for your library, along the lines of:

  ```cpp
  namespace mylib
  {
      #ifdef __APPLE__
      using Int64 = std::ptrdiff_t;
      using Uint64 = std::size_t;
      static_assert(sizeof(Int64) == 8);
      static_assert(sizeof(Uint64) == 8);
      #else
      using Int64 = std::int64_t;
      using Uint64 = std::uint64_t;
      #endif
  }
  ```

  This `#ifdef __APPLE__` is somewhat cosmetic, because on other 64-bit platforms (tested Windows and Linux), `std::[u]int64_t` expand to the same type as `std::size_t` and `std::ptrdiff_t` anyway. It's only there to support 32-bit platforms.

  You can **not** replace `#ifdef __APPLE__` with `#ifdef` to check if the parser is running, that's not going to work correctly in general.

  The generated C code will receive a similar typedef, but generated automatically.

* **And plus you need the following flags:**

  * For the generator: `--reject-long-and-long-long --use-size_t-typedef-for-uint64_t`
  * For the parser: `--canonicalize-64-to-fixed-size-typedefs --canonicalize-size_t-to-uint64_t`

    Notice that `--canonicalize-64-to-fixed-size-typedefs` is a subset of [`--canonicalize-to-fixed-size-typedefs`](#using-fixed-size-typedefs), so if you're already using the latter, you can skip this flag.

The end effect of all this is that the generator will make its own typedef for 64-bit wide integers (`MyLib_[u]int64_t`), and use it everywhere, including for what was originally `size_t`.

Alternatively you have the option of inverting the allowed typedefs, allowing the use of `[u]int64_t` but disabling `size_t` and friends. This is achieved by removing `--use-size_t-typedef-for-uint64_t` and `--canonicalize-size_t-to-uint64_t`. This also makes the custom 64-bit typedefs unnecessary (both in your code and in the generated output).

#### Why are we doing all this?

This is a long story.

To recap the problem: all 64-bit standard typedefs expand to different types (`long` vs `long long`) on different platforms. In particular:

* On Windows, `long` is 32 bits wide, so `size_t`, `int64_t`, and all other 64-bit wide standard typedefs use `long long`.
* On Linux, `long` is 64 bits wide, so it's used for all those typedefs instead.
* On Mac, `long` is 64 bits wide, but both `long` and `long long` are used for different typedefs (because of course they are!). The typedefs with digits in their names (e.g. `int64_t`) use `long long`, while all the other ones (e.g. `size_t`) use `long`.

#### Why is this a problem? Can't we have the parser *not* expand typedefs in the input?

Turns out we can't. Consider the following code:
```cpp
template <typename T>
struct Vec3
{
    T x, y, z;
};

Vec3<long> a();
Vec3<long long> b();
Vec3<std::int64_t> c();
```
We want this to generate **3** different C types: `A_long`, `A_long_long`, and `A_int64_t`. `A_int64_t` can be a typedef for one of the other two, but it still needs its own (appropriately named!) copies of all the member functions. Because to interact with the return value of `c()`, the clients should be using `A_int64_t_Get_x(...)`, not `A_long_Get_x(...)`, which would be non-portable.

Doing it this way appears to be impossible, or at least very difficult. While I can make Clang substitute `long` and `long long` into the `Vec3<T>` template, I have no idea how to substitute `int64_t` in a way that produces the third distinct class I can interact with. Even if it can be hacked to do this, this makes no sense from the C++ point of view, this isn't something that a compiler is expected to be able to do.

And we can't just take e.g. `A<long>` and replace every mention of `long` inside with `int64_t`, because what if it originally was a literal `long`?

So in the end, a fully generic solution appears to be impossible. So instead we do the next best thing.

#### Unifying Windows and Linux

Mac adds its own issues (which I unfortunately realized late), it'll be addressed later.

The idea is simple. You get rid of all mentions of `long` and `long long` in your API, and instead use the standard typedefs, doesn't matter which ones.

Then on Windows, we have the generator rewrite every `long long` back to `int64_t` (so all typedefs converge to this one), and complain if sees any `long`. And on Linux we do the opposite, rewriting any `long` back to `int64_t`, and complaining if we see any `long long`.

The end result is that you lose the ability to use `long` and `long long` in your API directly. You still can use the standard 64-bit wide typedefs, but all of them get rewritten to `[u]int64_t`. This means `size_t` also gets rewritten as `uint64_t`, which is a bit sad, but acceptable.

This is achieved with the following flags:

* `--canonicalize-64-to-fixed-size-typedefs` makes the parser replace `long long` with `int64_t` on Windows, and `long` with `int64_t` on Linux.

* `--reject-long-and-long-long` then makes the generator complain if it sees any `long` or `long long` (that wasn't replaced with a typedef).

Are we done yet? No.

#### Unifying Mac with Windows and Linux

Mac breaks this beautiful hack, because it has typedefs for both `long` and `long long`. There `size_t` and `ptrdiff_t` use `[unsigned] long`, while `[u]int64_t` use `[unsigned] long long`. The rule of thumb is that if a typedef has digits in its name, it's going to expand to `long long`, and otherwise to `long`.

Because of this, you can't have both `[u]int64_t` and `size_t` in your API, you must choose one.

If you do nothing, `size_t` will get rejected, and `[u]int64_t` will work normally.

Some libraries might want this to stop at this, but since `size_t` seems more valuable then `[u]int64_t`, we provide a workaround that lets you keep it.

Passing `--canonicalize-size_t-to-uint64_t` to the parser (which only has effect on Mac, but can be passed everywhere for consistency) makes it replace the wrong type with with `[u]int64_t`: instead of `long long`, it'll replace `long`.

Normally this would produce broken code, but we counteract it with `--use-size_t-typedef-for-uint64_t` in the generator, which then rewrites `[u]int64_t` into a custom typedef `MyLib_[u]int64_t`, which on Mac is made to point to `std::size_t` or `std::ptrdiff_t` respectively.

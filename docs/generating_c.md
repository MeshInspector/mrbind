# Generating C bindings

The C bindings are generated by a separate executable (`build/mrbind_gen_c`). It consumes the [parser output JSON](/docs/running_parser.md) and generates the C code, which you are then free to compile with any compiler.

## Running the generator

The minimal generation invocation looks like this:

```sh
mrbind_gen_c \
    --input parse_result.json \
    --output-header-dir output/include \
    --output-source-dir output/src \
    --helper-name-prefix MyLib_ \
    --map-path path/to/input/headers . \
    --assume-include-dir path/to/input
```

Let's go over the options. You can find more detailed descriptions in `mrbind_gen_c --help`.
* **`--input __.json`** is the input JSON as [produced by the parser](/docs/running_parser.md) (`mrbind`).
* **`--output-header-dir __` `--output-source-dir __`**** are the output directories for the headers and source files respectively.

  The default behavior is to error if those aren't empty. Pass `--clean-output-dirs` to automatically delete all contents before generation.

* **`--helper-name-prefix MyLib_`** sets the name prefix for certain generated functions/types/etc. This can be anything, but ideally you should pass your C++ namespace name followed by `_`.

  This isn't used for everything. The parsed names from the input will be prefixed with their C++ namespace names regardless of this flag. This prefix is used primarly for additional helper functions that we sometimes generate.

  This prefix is also used for macros by default. If you want a different prefix for macros (e.g. because this one isn't in all caps), pass it to `--helper-macro-name-prefix MYLIB_`.

* **`--map-path IN OUT`** controls the output directory hierarchy. Can be passed multiple times.

  For each input C++ header, we generate the respective output C header with the same name, and a C source file with the same name. (This only happens for headers that didn't have their contents filtered out by the parser's `--ignore`, so you don't need to worry about the standard library or third-party library headers.)

  Every such input C++ header must be located in one of the `IN` directories (this flag can be used several times to specify several directories). `IN` can be absolute or relative, it's made absolute internally anyway.

  `OUT` must always be relative. It's treated as relative to `--output-header-dir`/`--output-source-dir`.

  For example, if your input headers are `a/b/c/d/1.hpp`, `a/b/c/d/2.hpp`, and the output directories are `--output-header-dir include --output-source-dir src`, then:

  * `--map-path a/b .` would generate `include/c/d/1.h`, `include/c/d/2.h` and `src/c/d/1.c`, `src/c/d/2.c`.

  * `--map-path a/b foo/bar` would generate `include/foo/bar/c/d/1.h`, `include/foo/bar/c/d/2.h` and `src/foo/bar/c/d/1.c`, `src/foo/bar/c/d/2.c`.

  * `--map-path a/b/c .` would generate `include/d/1.h`, `include/d/2.h` and `src/d/1.c`, `src/d/2.c`, and so on.

* **`--assume-include-dir IN`** specifies which directories will be given to the compiler as include directories (via `-I...`).

  It's similar to `--map-path` in that it can be used multiple times, and every input C++ header must be one of the `IN` directories.

  For example, if your input headers are `a/b/c/d/1.hpp`, `a/b/c/d/2.hpp`, then `--assume-include-dir a/b` would cause the generator to use `#include <c/d/1.hpp>`, `#include <c/d/2.hpp>` to include those headers.

  NOTE: If your input headers use the `.h` extension, they can end up conflicting with the output `.h` headers with same names. To avoid this, don't pass directories that directly contain input headers, and instead pass their parents.

  For example, if your input header is named `a/b/c/d/1.h`, then don't pass `--assume-include-dir a/b/c/d`, and instead pass `a/b/c` or `a/b` or `a`.

  If you pass `--assume-include-dir a/b/c/d`, then the following will happen. The generated `1.c` will contain:

  ```c
  #include "1.h" // Include the generated C header `1.h`.
  #include <1.h> // Include the parsed C++ input header `1.h`.
  ```
  At least one of those will resolve incorrectly. (Since neither of those headers will be in the same directory as `1.c`.)

  And if you instead pass `--assume-include-dir a/b/c`, then you'll get:
  ```c
  #include "1.h"
  #include <d/1.h>
  ```
  Which is unambiguous, assuming you correctly set your include paths.

## Ignoring problematic parts of the code

If the generation fails because of certain problematic functions/types/etc, [exclude them from the bindings](/docs/skipping_entities.md).

## Completeness

Unlike Python, if C bindings generate and then compile successfully, you can be fairly sure that nothing is missing and they'll work correctly.

## Compiling the generated code

On success, the directories passed to `--output-header-dir`, `--output-source-dir` will contain the resulting C code, which you can compile with your preferred compiler, usually into a library.

You need at least following compiler flags:

* Add both `--output-header-dir` and `--output-source-dir` to the include search paths.

* Add your input C++ headers to the include search paths. Use the same directories you passed to `--assume-include-dir`.

* If you're compiling a shared library, define `MyLib_BUILD_LIBRARY`. This only matters on Windows, to enable `__declspec(dllexport)` for your functions.

  This macro is checked in `exports.h`, which is one of the generated headers.

  The `MyLib_` prefix is what you passe d to `--helper-macro-name-prefix` or `--helper-name-prefix`.

## Tuning the generated bindings

All flags beflow are for `mrbind_gen_c`, unless mentioned otherwise.

### File name length limit

Some generated headers can end up with long filenames (e.g. if you bind `std::tuple` with a 100 members). To set a limit on filename length, use `--max-header-name-length N` (e.g. with `N`=`100`). Longer filenames will get truncated, and hashes will be appended to those names to make them unique.

### Expose simple structs as structs

The default behavior is to expose all classes/structs as opaque heap-allocated pointers.

If you have sufficiently simple structs, you can opt into exposing them as plain C structs instead. The prime candidates for this are `struct Vec3 {float x,y,z;};` and such.

To do this, pass your struct name to `--expose-as-struct ...`. Use this flag multiple times to expose multiple structs. Invalid names are silently ignored.

The struct must be trivial enough: [trivially-copyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable), [standard-layout](https://en.cppreference.com/w/cpp/language/classes.html#Standard-layout_class), all members are public, no base classes. The members must have built-in types, or must themselves be structs passed to `--expose-as-struct` (so e.g. `struct Mat3 {Vec3 x,y,z;};` can be exposed correctly). If those requirements aren't satisfied, the generator will complain.

The specified name needs to be fully qualified (with all namespaces), and include all template arguments, e.g. `--expose-as-struct 'MyLibrary::Vector3<int>'`. (The `'...'` quotes are not a part of the syntax, use quotes appropriate for your shell if needed.)

You can expose several classes via a regex, e.g. to expose `Foo::Bar<T>` for any `T`, you could do `--expose-as-struct '/Foo::Bar<.*>/'`. (Again,  the `'...'` are your shell's quotes, while `/.../` is a part of the syntax, to indicate that this is a regex.)

### Make generated headers include each other

The generated headers are shy about including each other, preferring forward declarations when possible. The end result is that the end user will often have to include many ancillary headers (e.g. if a function returns `std::string` and you want to interact with its return value, you need to manually include the header with the binding for `std::string` too).

`--add-convenience-includes` fixes this. It's not enabled by default because it can be too eager with the includes, slowing down the user builds (though it adds a macro that lets users opt out of the extra includes).

### Don't generate elementwise constructors for large structs

When a C++ struct is an aggregate (i.e. has no constructors, and in C++ can be initialized with a list of its members in braces), we try to generate a C function for it that acts as a constructor, with a parameter for every member.

This can get out of hand with huge structs. Use `--preferred-max-num-aggregate-init-fields N` (with e.g. `N`=`20`) to not generate those functions for structs with more than `N` members.

This flag is ignored for non-default-constructible structs, as this could make them impossible to construct.
